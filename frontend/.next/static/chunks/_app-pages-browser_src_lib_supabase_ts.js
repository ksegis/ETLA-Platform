"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_supabase_ts"],{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   signInWithRole: () => (/* binding */ signInWithRole),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   userManagement: () => (/* binding */ userManagement)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst supabaseUrl = \"https://placeholder.supabase.co\";\nconst supabaseAnonKey = \"placeholder_key\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Export createClient function for compatibility\nconst createClient = ()=>(0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Auth helpers\nconst signInWithRole = async (email, password)=>{\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (data.user) {\n        // Get user profile with role and tenant\n        const { data: profile } = await supabase.from('users').select('role, tenant_id, first_name, last_name').eq('id', data.user.id).single();\n        return {\n            user: data.user,\n            profile,\n            error\n        };\n    }\n    return {\n        user: null,\n        profile: null,\n        error\n    };\n};\nconst signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    return {\n        error\n    };\n};\n// Database helpers\nconst getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data: profile } = await supabase.from('users').select('*').eq('id', user.id).single();\n    return {\n        ...user,\n        profile\n    };\n};\n// User Management Methods\nconst userManagement = {\n    // Create a new user\n    createUser: async (userData)=>{\n        try {\n            // First, create the auth user\n            const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n                email: userData.email,\n                password: userData.password,\n                email_confirm: true,\n                user_metadata: {\n                    full_name: userData.full_name,\n                    role: userData.role,\n                    role_level: userData.role_level\n                }\n            });\n            if (authError) {\n                return {\n                    success: false,\n                    error: authError.message\n                };\n            }\n            if (!authData.user) {\n                return {\n                    success: false,\n                    error: 'Failed to create user account'\n                };\n            }\n            // Then create the user profile\n            const { error: profileError } = await supabase.from('user_profiles').insert({\n                id: authData.user.id,\n                email: userData.email,\n                full_name: userData.full_name,\n                phone: userData.phone,\n                department: userData.department,\n                job_title: userData.job_title,\n                role: userData.role,\n                role_level: userData.role_level,\n                tenant_id: userData.tenant_id,\n                is_active: true,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (profileError) {\n                // If profile creation fails, we should clean up the auth user\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                return {\n                    success: false,\n                    error: profileError.message\n                };\n            }\n            return {\n                success: true,\n                data: authData.user\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to create user'\n            };\n        }\n    },\n    // Invite users via email\n    inviteUsers: async (invitationData)=>{\n        try {\n            const invitations = [];\n            for (const email of invitationData.emails){\n                // Create invitation record\n                const { data: invitation, error: inviteError } = await supabase.from('user_invitations').insert({\n                    email,\n                    role: invitationData.role,\n                    role_level: invitationData.role_level,\n                    tenant_id: invitationData.tenant_id,\n                    message: invitationData.message,\n                    expires_at: new Date(Date.now() + invitationData.expires_in_days * 24 * 60 * 60 * 1000).toISOString(),\n                    created_at: new Date().toISOString()\n                }).select().single();\n                if (inviteError) {\n                    console.error(\"Failed to create invitation for \".concat(email, \":\"), inviteError);\n                    continue;\n                }\n                // Send invitation email using Supabase Auth\n                const { error: emailError } = await supabase.auth.admin.inviteUserByEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/accept-invitation?token=\").concat(invitation.id),\n                    data: {\n                        role: invitationData.role,\n                        role_level: invitationData.role_level,\n                        tenant_id: invitationData.tenant_id,\n                        invitation_id: invitation.id\n                    }\n                });\n                if (emailError) {\n                    console.error(\"Failed to send invitation email to \".concat(email, \":\"), emailError);\n                    // Mark invitation as failed\n                    await supabase.from('user_invitations').update({\n                        status: 'failed'\n                    }).eq('id', invitation.id);\n                } else {\n                    invitations.push(invitation);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    sent: invitations.length,\n                    total: invitationData.emails.length\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to send invitations'\n            };\n        }\n    },\n    // Update user information\n    updateUser: async (userId, updateData)=>{\n        try {\n            const { error } = await supabase.from('user_profiles').update({\n                ...updateData,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to update user'\n            };\n        }\n    },\n    // Deactivate user\n    deactivateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('user_profiles').update({\n                is_active: false,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to deactivate user'\n            };\n        }\n    },\n    // Activate user\n    activateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('user_profiles').update({\n                is_active: true,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to activate user'\n            };\n        }\n    },\n    // Reset user password\n    resetUserPassword: async (email, newPassword)=>{\n        try {\n            if (newPassword) {\n                // Direct password reset (admin function)\n                const { error } = await supabase.auth.admin.updateUserById(email, {\n                    password: newPassword\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            } else {\n                // Email-based password reset\n                const { error } = await supabase.auth.resetPasswordForEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/reset-password\")\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to reset password'\n            };\n        }\n    },\n    // Preview cleanup operations\n    previewUserCleanup: async (options)=>{\n        try {\n            let inactiveUsers = 0;\n            let unconfirmedUsers = 0;\n            let expiredInvites = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('user_profiles').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('last_login', cutoffDate).eq('is_active', true);\n                inactiveUsers = count || 0;\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('auth.users').select('*', {\n                    count: 'exact',\n                    head: true\n                }).is('email_confirmed_at', null).lt('created_at', cutoffDate);\n                unconfirmedUsers = count || 0;\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                expiredInvites = count || 0;\n            }\n            const totalToDelete = inactiveUsers + unconfirmedUsers + expiredInvites;\n            return {\n                success: true,\n                data: {\n                    inactiveUsers,\n                    unconfirmedUsers,\n                    expiredInvites,\n                    totalToDelete\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to preview cleanup'\n            };\n        }\n    },\n    // Execute cleanup operations\n    executeUserCleanup: async (options)=>{\n        try {\n            let deletedCount = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                // Get inactive users\n                const { data: inactiveUsers } = await supabase.from('user_profiles').select('id').lt('last_login', cutoffDate).eq('is_active', true);\n                if (inactiveUsers) {\n                    for (const user of inactiveUsers){\n                        // Delete auth user\n                        await supabase.auth.admin.deleteUser(user.id);\n                        // Delete profile\n                        await supabase.from('user_profiles').delete().eq('id', user.id);\n                    }\n                    deletedCount += inactiveUsers.length;\n                }\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                // This would require admin access to auth.users table\n                // For now, we'll mark them as inactive\n                const { data: unconfirmedUsers } = await supabase.from('user_profiles').select('id').lt('created_at', cutoffDate).eq('is_active', true);\n                if (unconfirmedUsers) {\n                    await supabase.from('user_profiles').update({\n                        is_active: false\n                    }).in('id', unconfirmedUsers.map((u)=>u.id));\n                    deletedCount += unconfirmedUsers.length;\n                }\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').delete().lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                deletedCount += count || 0;\n            }\n            return {\n                success: true,\n                data: {\n                    deletedCount\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to execute cleanup'\n            };\n        }\n    }\n};\n// Add user management methods to the main supabase object for backward compatibility\nObject.assign(supabase, userManagement);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU87Z0JBQUV3QixTQUFTO2dCQUFPeEIsT0FBT0EsTUFBTXlCLE9BQU8sSUFBSTtZQUE0QjtRQUMvRTtJQUNGO0FBQ0YsRUFBQztBQUVELHFGQUFxRjtBQUNyRnVFLE9BQU9DLE1BQU0sQ0FBQ3RHLFVBQVVrQiIsInNvdXJjZXMiOlsiL2hvbWUvdWJ1bnR1L0VUTEEtUGxhdGZvcm0vZnJvbnRlbmQvc3JjL2xpYi9zdXBhYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvc3VwYWJhc2UudHNcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCBhcyBjcmVhdGVTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX1RPS0VOIVxuXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuXG4vLyBFeHBvcnQgY3JlYXRlQ2xpZW50IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5XG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gKCkgPT4gY3JlYXRlU3VwYWJhc2VDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSlcblxuLy8gRGF0YWJhc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgV29ya1JlcXVlc3Qge1xuICBpZDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBjYXRlZ29yeTogc3RyaW5nXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJ1xuICB1cmdlbmN5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ3VyZ2VudCdcbiAgc3RhdHVzOiAnc3VibWl0dGVkJyB8ICd1bmRlcl9yZXZpZXcnIHwgJ2FwcHJvdmVkJyB8ICdyZWplY3RlZCcgfCAnc2NoZWR1bGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnXG4gIGN1c3RvbWVyX2lkOiBzdHJpbmdcbiAgYXNzaWduZWRfdG8/OiBzdHJpbmdcbiAgZXN0aW1hdGVkX2hvdXJzPzogbnVtYmVyXG4gIGFjdHVhbF9ob3VyczogbnVtYmVyXG4gIGJ1ZGdldD86IG51bWJlclxuICByZXF1aXJlZF9jb21wbGV0aW9uX2RhdGU/OiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3Qge1xuICBpZDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHdvcmtfcmVxdWVzdF9pZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgc3RhdHVzOiAnc2NoZWR1bGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdvbl9ob2xkJyB8ICdjYW5jZWxsZWQnXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJ1xuICBhc3NpZ25lZF90ZWFtX2xlYWQ6IHN0cmluZ1xuICBlc3RpbWF0ZWRfaG91cnM6IG51bWJlclxuICBhY3R1YWxfaG91cnM6IG51bWJlclxuICBidWRnZXQ/OiBudW1iZXJcbiAgc3RhcnRfZGF0ZTogc3RyaW5nXG4gIGVuZF9kYXRlOiBzdHJpbmdcbiAgY29tcGxldGlvbl9wZXJjZW50YWdlOiBudW1iZXJcbiAgY2xpZW50X3NhdGlzZmFjdGlvbl9zY29yZT86IG51bWJlclxuICBvbl90aW1lX2RlbGl2ZXJ5PzogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBjb21wYW55X25hbWU6IHN0cmluZ1xuICBzdWJkb21haW4/OiBzdHJpbmdcbiAgaW5kdXN0cnk/OiBzdHJpbmdcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICd0cmlhbCcgfCAnc3VzcGVuZGVkJyB8ICdjYW5jZWxsZWQnXG4gIHN1YnNjcmlwdGlvbl9wbGFuOiAndHJpYWwnIHwgJ3Byb2Zlc3Npb25hbCcgfCAnZW50ZXJwcmlzZSdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBmaXJzdF9uYW1lOiBzdHJpbmdcbiAgbGFzdF9uYW1lOiBzdHJpbmdcbiAgcm9sZTogJ2hvc3RfYWRtaW4nIHwgJ3Byb2dyYW1fbWFuYWdlcicgfCAnY2xpZW50X2FkbWluJyB8ICdjbGllbnRfdXNlcidcbiAgdGVuYW50X2lkPzogc3RyaW5nXG4gIGlzX2FjdGl2ZTogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbn1cblxuLy8gRXh0ZW5kZWQgVXNlciBpbnRlcmZhY2UgZm9yIHVzZXIgbWFuYWdlbWVudFxuZXhwb3J0IGludGVyZmFjZSBFeHRlbmRlZFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZnVsbF9uYW1lOiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB0ZW5hbnRfbmFtZT86IHN0cmluZ1xuICBpc19hY3RpdmU6IGJvb2xlYW5cbiAgY2FuX2ludml0ZV91c2VyczogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGxhc3RfbG9naW4/OiBzdHJpbmdcbn1cblxuLy8gVXNlciBjcmVhdGlvbiBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBVc2VyQ3JlYXRpb25EYXRhIHtcbiAgZW1haWw6IHN0cmluZ1xuICBmdWxsX25hbWU6IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBkZXBhcnRtZW50Pzogc3RyaW5nXG4gIGpvYl90aXRsZT86IHN0cmluZ1xuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHBhc3N3b3JkOiBzdHJpbmdcbiAgY2FuX2ludml0ZV91c2VyczogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU6IHN0cmluZ1xufVxuXG4vLyBVc2VyIGludml0YXRpb24gZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlckludml0YXRpb25EYXRhIHtcbiAgZW1haWxzOiBzdHJpbmdbXVxuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbiAgZXhwaXJlc19pbl9kYXlzOiBudW1iZXJcbn1cblxuLy8gVXNlciB1cGRhdGUgZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclVwZGF0ZURhdGEge1xuICBmdWxsX25hbWU/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZT86IHN0cmluZ1xuICByb2xlX2xldmVsPzogc3RyaW5nXG4gIHRlbmFudF9pZD86IHN0cmluZ1xuICBpc19hY3RpdmU/OiBib29sZWFuXG4gIGNhbl9pbnZpdGVfdXNlcnM/OiBib29sZWFuXG4gIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM/OiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU/OiBzdHJpbmdcbn1cblxuLy8gQ2xlYW51cCBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBDbGVhbnVwT3B0aW9ucyB7XG4gIGRlbGV0ZUluYWN0aXZlVXNlcnM6IGJvb2xlYW5cbiAgZGVsZXRlVW5jb25maXJtZWRVc2VyczogYm9vbGVhblxuICBkZWxldGVFeHBpcmVkSW52aXRlczogYm9vbGVhblxuICBpbmFjdGl2ZURheXM6IG51bWJlclxuICB1bmNvbmZpcm1lZERheXM6IG51bWJlclxufVxuXG4vLyBBdXRoIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzaWduSW5XaXRoUm9sZSA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZFxuICB9KVxuICBcbiAgaWYgKGRhdGEudXNlcikge1xuICAgIC8vIEdldCB1c2VyIHByb2ZpbGUgd2l0aCByb2xlIGFuZCB0ZW5hbnRcbiAgICBjb25zdCB7IGRhdGE6IHByb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgncm9sZSwgdGVuYW50X2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUnKVxuICAgICAgLmVxKCdpZCcsIGRhdGEudXNlci5pZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIFxuICAgIHJldHVybiB7IHVzZXI6IGRhdGEudXNlciwgcHJvZmlsZSwgZXJyb3IgfVxuICB9XG4gIFxuICByZXR1cm4geyB1c2VyOiBudWxsLCBwcm9maWxlOiBudWxsLCBlcnJvciB9XG59XG5cbmV4cG9ydCBjb25zdCBzaWduT3V0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKVxuICByZXR1cm4geyBlcnJvciB9XG59XG5cbi8vIERhdGFiYXNlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VXNlciA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgaWYgKCF1c2VyKSByZXR1cm4gbnVsbFxuICBcbiAgY29uc3QgeyBkYXRhOiBwcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCd1c2VycycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgLnNpbmdsZSgpXG4gIFxuICByZXR1cm4geyAuLi51c2VyLCBwcm9maWxlIH1cbn1cblxuLy8gVXNlciBNYW5hZ2VtZW50IE1ldGhvZHNcbmV4cG9ydCBjb25zdCB1c2VyTWFuYWdlbWVudCA9IHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHVzZXJcbiAgY3JlYXRlVXNlcjogYXN5bmMgKHVzZXJEYXRhOiBVc2VyQ3JlYXRpb25EYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCBjcmVhdGUgdGhlIGF1dGggdXNlclxuICAgICAgY29uc3QgeyBkYXRhOiBhdXRoRGF0YSwgZXJyb3I6IGF1dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5jcmVhdGVVc2VyKHtcbiAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICBwYXNzd29yZDogdXNlckRhdGEucGFzc3dvcmQsXG4gICAgICAgIGVtYWlsX2NvbmZpcm06IHRydWUsXG4gICAgICAgIHVzZXJfbWV0YWRhdGE6IHtcbiAgICAgICAgICBmdWxsX25hbWU6IHVzZXJEYXRhLmZ1bGxfbmFtZSxcbiAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKGF1dGhFcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGF1dGhFcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRoRGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgdXNlciBhY2NvdW50JyB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZW4gY3JlYXRlIHRoZSB1c2VyIHByb2ZpbGVcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHByb2ZpbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfcHJvZmlsZXMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBpZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUsXG4gICAgICAgICAgcGhvbmU6IHVzZXJEYXRhLnBob25lLFxuICAgICAgICAgIGRlcGFydG1lbnQ6IHVzZXJEYXRhLmRlcGFydG1lbnQsXG4gICAgICAgICAgam9iX3RpdGxlOiB1c2VyRGF0YS5qb2JfdGl0bGUsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgIHRlbmFudF9pZDogdXNlckRhdGEudGVuYW50X2lkLFxuICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjYW5faW52aXRlX3VzZXJzOiB1c2VyRGF0YS5jYW5faW52aXRlX3VzZXJzLFxuICAgICAgICAgIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IHVzZXJEYXRhLmNhbl9tYW5hZ2Vfc3ViX2NsaWVudHMsXG4gICAgICAgICAgcGVybWlzc2lvbl9zY29wZTogdXNlckRhdGEucGVybWlzc2lvbl9zY29wZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChwcm9maWxlRXJyb3IpIHtcbiAgICAgICAgLy8gSWYgcHJvZmlsZSBjcmVhdGlvbiBmYWlscywgd2Ugc2hvdWxkIGNsZWFuIHVwIHRoZSBhdXRoIHVzZXJcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcHJvZmlsZUVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBhdXRoRGF0YS51c2VyIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBJbnZpdGUgdXNlcnMgdmlhIGVtYWlsXG4gIGludml0ZVVzZXJzOiBhc3luYyAoaW52aXRhdGlvbkRhdGE6IFVzZXJJbnZpdGF0aW9uRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnZpdGF0aW9ucyA9IFtdXG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgaW52aXRhdGlvbkRhdGEuZW1haWxzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbnZpdGF0aW9uIHJlY29yZFxuICAgICAgICBjb25zdCB7IGRhdGE6IGludml0YXRpb24sIGVycm9yOiBpbnZpdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHJvbGU6IGludml0YXRpb25EYXRhLnJvbGUsXG4gICAgICAgICAgICByb2xlX2xldmVsOiBpbnZpdGF0aW9uRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgICAgdGVuYW50X2lkOiBpbnZpdGF0aW9uRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBpbnZpdGF0aW9uRGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIGludml0YXRpb25EYXRhLmV4cGlyZXNfaW5fZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGlmIChpbnZpdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgaW52aXRhdGlvbiBmb3IgJHtlbWFpbH06YCwgaW52aXRlRXJyb3IpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgaW52aXRhdGlvbiBlbWFpbCB1c2luZyBTdXBhYmFzZSBBdXRoXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGVtYWlsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIHtcbiAgICAgICAgICByZWRpcmVjdFRvOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hY2NlcHQtaW52aXRhdGlvbj90b2tlbj0ke2ludml0YXRpb24uaWR9YCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByb2xlOiBpbnZpdGF0aW9uRGF0YS5yb2xlLFxuICAgICAgICAgICAgcm9sZV9sZXZlbDogaW52aXRhdGlvbkRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICAgIHRlbmFudF9pZDogaW52aXRhdGlvbkRhdGEudGVuYW50X2lkLFxuICAgICAgICAgICAgaW52aXRhdGlvbl9pZDogaW52aXRhdGlvbi5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZW1haWxFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzZW5kIGludml0YXRpb24gZW1haWwgdG8gJHtlbWFpbH06YCwgZW1haWxFcnJvcilcbiAgICAgICAgICAvLyBNYXJrIGludml0YXRpb24gYXMgZmFpbGVkXG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAgIC51cGRhdGUoeyBzdGF0dXM6ICdmYWlsZWQnIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbi5pZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZpdGF0aW9ucy5wdXNoKGludml0YXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgICBkYXRhOiB7IFxuICAgICAgICAgIHNlbnQ6IGludml0YXRpb25zLmxlbmd0aCwgXG4gICAgICAgICAgdG90YWw6IGludml0YXRpb25EYXRhLmVtYWlscy5sZW5ndGggXG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc2VuZCBpbnZpdGF0aW9ucycgfVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgdXNlciBpbmZvcm1hdGlvblxuICB1cGRhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFVzZXJVcGRhdGVEYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgLi4udXBkYXRlRGF0YSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSB1c2VyJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIERlYWN0aXZhdGUgdXNlclxuICBkZWFjdGl2YXRlVXNlcjogYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgaXNfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGRlYWN0aXZhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBBY3RpdmF0ZSB1c2VyXG4gIGFjdGl2YXRlVXNlcjogYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYWN0aXZhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBSZXNldCB1c2VyIHBhc3N3b3JkXG4gIHJlc2V0VXNlclBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZywgbmV3UGFzc3dvcmQ/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5ld1Bhc3N3b3JkKSB7XG4gICAgICAgIC8vIERpcmVjdCBwYXNzd29yZCByZXNldCAoYWRtaW4gZnVuY3Rpb24pXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4udXBkYXRlVXNlckJ5SWQoXG4gICAgICAgICAgZW1haWwsIC8vIFRoaXMgc2hvdWxkIGJlIHVzZXIgSUQsIGJ1dCB3ZSdsbCBuZWVkIHRvIGdldCBpdCBmaXJzdFxuICAgICAgICAgIHsgcGFzc3dvcmQ6IG5ld1Bhc3N3b3JkIH1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtYWlsLWJhc2VkIHBhc3N3b3JkIHJlc2V0XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVzZXRQYXNzd29yZEZvckVtYWlsKGVtYWlsLCB7XG4gICAgICAgICAgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vcmVzZXQtcGFzc3dvcmRgXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHJlc2V0IHBhc3N3b3JkJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFByZXZpZXcgY2xlYW51cCBvcGVyYXRpb25zXG4gIHByZXZpZXdVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpbmFjdGl2ZVVzZXJzID0gMFxuICAgICAgbGV0IHVuY29uZmlybWVkVXNlcnMgPSAwXG4gICAgICBsZXQgZXhwaXJlZEludml0ZXMgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9wcm9maWxlcycpXG4gICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgICAubHQoJ2xhc3RfbG9naW4nLCBjdXRvZmZEYXRlKVxuICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICAgICAgICBpbmFjdGl2ZVVzZXJzID0gY291bnQgfHwgMFxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVVbmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy51bmNvbmZpcm1lZERheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2F1dGgudXNlcnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmlzKCdlbWFpbF9jb25maXJtZWRfYXQnLCBudWxsKVxuICAgICAgICAgIC5sdCgnY3JlYXRlZF9hdCcsIGN1dG9mZkRhdGUpXG5cbiAgICAgICAgdW5jb25maXJtZWRVc2VycyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlRXhwaXJlZEludml0ZXMpIHtcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgICAubHQoJ2V4cGlyZXNfYXQnLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXG4gICAgICAgICAgLm5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcblxuICAgICAgICBleHBpcmVkSW52aXRlcyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG90YWxUb0RlbGV0ZSA9IGluYWN0aXZlVXNlcnMgKyB1bmNvbmZpcm1lZFVzZXJzICsgZXhwaXJlZEludml0ZXNcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGluYWN0aXZlVXNlcnMsXG4gICAgICAgICAgdW5jb25maXJtZWRVc2VycyxcbiAgICAgICAgICBleHBpcmVkSW52aXRlcyxcbiAgICAgICAgICB0b3RhbFRvRGVsZXRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBwcmV2aWV3IGNsZWFudXAnIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gRXhlY3V0ZSBjbGVhbnVwIG9wZXJhdGlvbnNcbiAgZXhlY3V0ZVVzZXJDbGVhbnVwOiBhc3luYyAob3B0aW9uczogQ2xlYW51cE9wdGlvbnMpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRlbGV0ZWRDb3VudCA9IDBcblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlSW5hY3RpdmVVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMuaW5hY3RpdmVEYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGluYWN0aXZlIHVzZXJzXG4gICAgICAgIGNvbnN0IHsgZGF0YTogaW5hY3RpdmVVc2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9wcm9maWxlcycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgIC5sdCgnbGFzdF9sb2dpbicsIGN1dG9mZkRhdGUpXG4gICAgICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuXG4gICAgICAgIGlmIChpbmFjdGl2ZVVzZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB1c2VyIG9mIGluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhdXRoIHVzZXJcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZGVsZXRlVXNlcih1c2VyLmlkKVxuICAgICAgICAgICAgLy8gRGVsZXRlIHByb2ZpbGVcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCd1c2VyX3Byb2ZpbGVzJylcbiAgICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGVkQ291bnQgKz0gaW5hY3RpdmVVc2Vycy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVVbmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy51bmNvbmZpcm1lZERheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIFxuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgYWRtaW4gYWNjZXNzIHRvIGF1dGgudXNlcnMgdGFibGVcbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgbWFyayB0aGVtIGFzIGluYWN0aXZlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogdW5jb25maXJtZWRVc2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9wcm9maWxlcycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgIC5sdCgnY3JlYXRlZF9hdCcsIGN1dG9mZkRhdGUpXG4gICAgICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuXG4gICAgICAgIGlmICh1bmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VyX3Byb2ZpbGVzJylcbiAgICAgICAgICAgIC51cGRhdGUoeyBpc19hY3RpdmU6IGZhbHNlIH0pXG4gICAgICAgICAgICAuaW4oJ2lkJywgdW5jb25maXJtZWRVc2Vycy5tYXAodSA9PiB1LmlkKSlcbiAgICAgICAgICBcbiAgICAgICAgICBkZWxldGVkQ291bnQgKz0gdW5jb25maXJtZWRVc2Vycy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVFeHBpcmVkSW52aXRlcykge1xuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAubHQoJ2V4cGlyZXNfYXQnLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXG4gICAgICAgICAgLm5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcblxuICAgICAgICBkZWxldGVkQ291bnQgKz0gY291bnQgfHwgMFxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGRlbGV0ZWRDb3VudCB9IH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBleGVjdXRlIGNsZWFudXAnIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQWRkIHVzZXIgbWFuYWdlbWVudCBtZXRob2RzIHRvIHRoZSBtYWluIHN1cGFiYXNlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuT2JqZWN0LmFzc2lnbihzdXBhYmFzZSwgdXNlck1hbmFnZW1lbnQpXG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjcmVhdGVTdXBhYmFzZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4iLCJzdXBhYmFzZSIsInNpZ25JbldpdGhSb2xlIiwiZW1haWwiLCJwYXNzd29yZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJ1c2VyIiwicHJvZmlsZSIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwic2lnbk91dCIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlciIsInVzZXJNYW5hZ2VtZW50IiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwiYXV0aERhdGEiLCJhdXRoRXJyb3IiLCJhZG1pbiIsImVtYWlsX2NvbmZpcm0iLCJ1c2VyX21ldGFkYXRhIiwiZnVsbF9uYW1lIiwicm9sZSIsInJvbGVfbGV2ZWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsInByb2ZpbGVFcnJvciIsImluc2VydCIsInBob25lIiwiZGVwYXJ0bWVudCIsImpvYl90aXRsZSIsInRlbmFudF9pZCIsImlzX2FjdGl2ZSIsImNhbl9pbnZpdGVfdXNlcnMiLCJjYW5fbWFuYWdlX3N1Yl9jbGllbnRzIiwicGVybWlzc2lvbl9zY29wZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlVXNlciIsImludml0ZVVzZXJzIiwiaW52aXRhdGlvbkRhdGEiLCJpbnZpdGF0aW9ucyIsImVtYWlscyIsImludml0YXRpb24iLCJpbnZpdGVFcnJvciIsImV4cGlyZXNfYXQiLCJub3ciLCJleHBpcmVzX2luX2RheXMiLCJjb25zb2xlIiwiZW1haWxFcnJvciIsImludml0ZVVzZXJCeUVtYWlsIiwicmVkaXJlY3RUbyIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiaW52aXRhdGlvbl9pZCIsInVwZGF0ZSIsInN0YXR1cyIsInB1c2giLCJzZW50IiwibGVuZ3RoIiwidG90YWwiLCJ1cGRhdGVVc2VyIiwidXNlcklkIiwidXBkYXRlRGF0YSIsImRlYWN0aXZhdGVVc2VyIiwiYWN0aXZhdGVVc2VyIiwicmVzZXRVc2VyUGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsInVwZGF0ZVVzZXJCeUlkIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwicHJldmlld1VzZXJDbGVhbnVwIiwib3B0aW9ucyIsImluYWN0aXZlVXNlcnMiLCJ1bmNvbmZpcm1lZFVzZXJzIiwiZXhwaXJlZEludml0ZXMiLCJkZWxldGVJbmFjdGl2ZVVzZXJzIiwiY3V0b2ZmRGF0ZSIsImluYWN0aXZlRGF5cyIsImNvdW50IiwiaGVhZCIsImx0IiwiZGVsZXRlVW5jb25maXJtZWRVc2VycyIsInVuY29uZmlybWVkRGF5cyIsImlzIiwiZGVsZXRlRXhwaXJlZEludml0ZXMiLCJuZXEiLCJ0b3RhbFRvRGVsZXRlIiwiZXhlY3V0ZVVzZXJDbGVhbnVwIiwiZGVsZXRlZENvdW50IiwiZGVsZXRlIiwiaW4iLCJtYXAiLCJ1IiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

}]);