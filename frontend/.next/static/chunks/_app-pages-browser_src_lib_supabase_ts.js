"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_supabase_ts"],{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   mfaManagement: () => (/* binding */ mfaManagement),\n/* harmony export */   signInWithRole: () => (/* binding */ signInWithRole),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   userManagement: () => (/* binding */ userManagement)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst supabaseUrl = \"https://placeholder.supabase.co\";\nconst supabaseAnonKey = \"placeholder_key\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Export createClient function for compatibility\nconst createClient = ()=>(0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Auth helpers\nconst signInWithRole = async (email, password)=>{\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (data.user) {\n        // Get user profile with role and tenant\n        const { data: profile } = await supabase.from('users').select('role, tenant_id, first_name, last_name').eq('id', data.user.id).single();\n        return {\n            user: data.user,\n            profile,\n            error\n        };\n    }\n    return {\n        user: null,\n        profile: null,\n        error\n    };\n};\nconst signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    return {\n        error\n    };\n};\n// Database helpers\nconst getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data: profile } = await supabase.from('users').select('*').eq('id', user.id).single();\n    return {\n        ...user,\n        profile\n    };\n};\n// User Management Methods\nconst userManagement = {\n    // Create a new user with complete RBAC setup\n    createUser: async (userData)=>{\n        try {\n            // First, create the auth user\n            const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n                email: userData.email,\n                password: userData.password,\n                email_confirm: true,\n                user_metadata: {\n                    full_name: userData.full_name,\n                    role: userData.role,\n                    role_level: userData.role_level\n                }\n            });\n            if (authError) {\n                return {\n                    success: false,\n                    error: authError.message\n                };\n            }\n            if (!authData.user) {\n                return {\n                    success: false,\n                    error: 'Failed to create user account'\n                };\n            }\n            // Create the user profile (FIXED: using 'profiles' not 'user_profiles')\n            const { error: profileError } = await supabase.from('profiles').insert({\n                id: authData.user.id,\n                email: userData.email,\n                full_name: userData.full_name,\n                phone: userData.phone,\n                department: userData.department,\n                job_title: userData.job_title,\n                role: userData.role,\n                role_level: userData.role_level,\n                tenant_id: userData.tenant_id,\n                is_active: true,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (profileError) {\n                // If profile creation fails, clean up the auth user\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                return {\n                    success: false,\n                    error: \"Profile creation failed: \".concat(profileError.message)\n                };\n            }\n            // NEW: Create tenant_users record for RBAC\n            const { error: tenantUserError } = await supabase.from('tenant_users').insert({\n                tenant_id: userData.tenant_id,\n                user_id: authData.user.id,\n                role: userData.role,\n                role_level: userData.role_level,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (tenantUserError) {\n                // If tenant_users creation fails, clean up auth user and profile\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                await supabase.from('profiles').delete().eq('id', authData.user.id);\n                return {\n                    success: false,\n                    error: \"Tenant assignment failed: \".concat(tenantUserError.message)\n                };\n            }\n            // OPTIONAL: Create audit log if table exists\n            try {\n                await supabase.from('audit_logs').insert({\n                    user_id: authData.user.id,\n                    tenant_id: userData.tenant_id,\n                    action: 'user_created',\n                    resource_type: 'user',\n                    resource_id: authData.user.id,\n                    details: {\n                        created_by: 'admin_interface',\n                        role: userData.role,\n                        role_level: userData.role_level,\n                        email: userData.email\n                    },\n                    ip_address: '127.0.0.1',\n                    user_agent: 'Admin Interface',\n                    severity: 'info',\n                    created_at: new Date().toISOString()\n                });\n            } catch (auditError) {\n                // Audit log is optional, don't fail the user creation\n                console.warn('Audit log creation failed:', auditError);\n            }\n            return {\n                success: true,\n                data: authData.user\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to create user'\n            };\n        }\n    },\n    // Invite users via email\n    inviteUsers: async (invitationData)=>{\n        try {\n            const invitations = [];\n            for (const email of invitationData.emails){\n                // Create invitation record\n                const { data: invitation, error: inviteError } = await supabase.from('user_invitations').insert({\n                    email,\n                    role: invitationData.role,\n                    role_level: invitationData.role_level,\n                    tenant_id: invitationData.tenant_id,\n                    message: invitationData.message,\n                    expires_at: new Date(Date.now() + invitationData.expires_in_days * 24 * 60 * 60 * 1000).toISOString(),\n                    created_at: new Date().toISOString()\n                }).select().single();\n                if (inviteError) {\n                    console.error(\"Failed to create invitation for \".concat(email, \":\"), inviteError);\n                    continue;\n                }\n                // Send invitation email using Supabase Auth\n                const { error: emailError } = await supabase.auth.admin.inviteUserByEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/accept-invitation?token=\").concat(invitation.id),\n                    data: {\n                        role: invitationData.role,\n                        role_level: invitationData.role_level,\n                        tenant_id: invitationData.tenant_id,\n                        invitation_id: invitation.id\n                    }\n                });\n                if (emailError) {\n                    console.error(\"Failed to send invitation email to \".concat(email, \":\"), emailError);\n                    // Mark invitation as failed\n                    await supabase.from('user_invitations').update({\n                        status: 'failed'\n                    }).eq('id', invitation.id);\n                } else {\n                    invitations.push(invitation);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    sent: invitations.length,\n                    total: invitationData.emails.length\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to send invitations'\n            };\n        }\n    },\n    // Update user information\n    updateUser: async (userId, updateData)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                ...updateData,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to update user'\n            };\n        }\n    },\n    // Deactivate user\n    deactivateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: false,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to deactivate user'\n            };\n        }\n    },\n    // Activate user\n    activateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: true,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to activate user'\n            };\n        }\n    },\n    // Reset user password\n    resetUserPassword: async (email, newPassword)=>{\n        try {\n            if (newPassword) {\n                // Direct password reset (admin function)\n                const { error } = await supabase.auth.admin.updateUserById(email, {\n                    password: newPassword\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            } else {\n                // Email-based password reset\n                const { error } = await supabase.auth.resetPasswordForEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/reset-password\")\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to reset password'\n            };\n        }\n    },\n    // Preview cleanup operations\n    previewUserCleanup: async (options)=>{\n        try {\n            let inactiveUsers = 0;\n            let unconfirmedUsers = 0;\n            let expiredInvites = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('profiles').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('last_login', cutoffDate).eq('is_active', true);\n                inactiveUsers = count || 0;\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('auth.users').select('*', {\n                    count: 'exact',\n                    head: true\n                }).is('email_confirmed_at', null).lt('created_at', cutoffDate);\n                unconfirmedUsers = count || 0;\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                expiredInvites = count || 0;\n            }\n            const totalToDelete = inactiveUsers + unconfirmedUsers + expiredInvites;\n            return {\n                success: true,\n                data: {\n                    inactiveUsers,\n                    unconfirmedUsers,\n                    expiredInvites,\n                    totalToDelete\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to preview cleanup'\n            };\n        }\n    },\n    // Execute cleanup operations\n    executeUserCleanup: async (options)=>{\n        try {\n            let deletedCount = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                // Get inactive users\n                const { data: inactiveUsers } = await supabase.from('profiles').select('id').lt('last_login', cutoffDate).eq('is_active', true);\n                if (inactiveUsers) {\n                    for (const user of inactiveUsers){\n                        // Delete auth user\n                        await supabase.auth.admin.deleteUser(user.id);\n                        // Delete profile\n                        await supabase.from('profiles').delete().eq('id', user.id);\n                    }\n                    deletedCount += inactiveUsers.length;\n                }\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                // This would require admin access to auth.users table\n                // For now, we'll mark them as inactive\n                const { data: unconfirmedUsers } = await supabase.from('profiles').select('id').lt('created_at', cutoffDate).eq('is_active', true);\n                if (unconfirmedUsers) {\n                    await supabase.from('profiles').update({\n                        is_active: false\n                    }).in('id', unconfirmedUsers.map((u)=>u.id));\n                    deletedCount += unconfirmedUsers.length;\n                }\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').delete().lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                deletedCount += count || 0;\n            }\n            return {\n                success: true,\n                data: {\n                    deletedCount\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to execute cleanup'\n            };\n        }\n    }\n};\nconst mfaManagement = {\n    // Check if user has MFA enabled\n    checkMFAStatus: async (userId)=>{\n        try {\n            const { data, error } = await supabase.from('profiles').select('mfa_enabled').eq('id', userId).single();\n            if (error) throw error;\n            return {\n                mfaEnabled: (data === null || data === void 0 ? void 0 : data.mfa_enabled) || false\n            };\n        } catch (error) {\n            console.error('Error checking MFA status:', error);\n            return {\n                mfaEnabled: false,\n                error: error.message\n            };\n        }\n    },\n    // Enable MFA for user\n    enableMFA: async ()=>{\n        try {\n            // Enroll for TOTP MFA\n            const { data, error } = await supabase.auth.mfa.enroll({\n                factorType: 'totp',\n                friendlyName: 'ETLA Platform TOTP'\n            });\n            if (error) throw error;\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error enabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify MFA setup\n    verifyMFASetup: async (factorId, code)=>{\n        try {\n            // Create challenge first\n            const { data: challenge, error: challengeError } = await supabase.auth.mfa.challenge({\n                factorId\n            });\n            if (challengeError) throw challengeError;\n            // Verify the code\n            const { data, error } = await supabase.auth.mfa.verify({\n                factorId,\n                challengeId: challenge.id,\n                code\n            });\n            if (error) throw error;\n            // Update user profile to indicate MFA is enabled\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: true,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error verifying MFA setup:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Disable MFA for user\n    disableMFA: async ()=>{\n        try {\n            // Get all factors\n            const { data: factors, error: factorsError } = await supabase.auth.mfa.listFactors();\n            if (factorsError) throw factorsError;\n            // Unenroll all TOTP factors\n            if (factors === null || factors === void 0 ? void 0 : factors.totp) {\n                for (const factor of factors.totp){\n                    await supabase.auth.mfa.unenroll({\n                        factorId: factor.id\n                    });\n                }\n            }\n            // Update user profile\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: false,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error('Error disabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Generate backup codes (simulated - in production this would be handled by your backend)\n    generateBackupCodes: async ()=>{\n        try {\n            // Generate 8 backup codes\n            const codes = Array.from({\n                length: 8\n            }, ()=>Math.random().toString(36).substring(2, 8).toUpperCase());\n            // In production, you would store these securely in your backend\n            // For now, we'll just return them\n            return {\n                success: true,\n                codes\n            };\n        } catch (error) {\n            console.error('Error generating backup codes:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify backup code (simulated - in production this would verify against stored codes)\n    verifyBackupCode: async (code)=>{\n        try {\n            // In production, you would verify this against stored backup codes\n            // For demo purposes, we'll accept any 6+ character code\n            if (code.length >= 6) {\n                return {\n                    success: true\n                };\n            } else {\n                throw new Error('Invalid backup code');\n            }\n        } catch (error) {\n            console.error('Error verifying backup code:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n};\n// Add user management methods to the main supabase object for backward compatibility\nObject.assign(supabase, userManagement);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLEdBQUdDLFdBQVc7WUFHeEQsZ0VBQWdFO1lBQ2hFLGtDQUFrQztZQUNsQyxPQUFPO2dCQUFFbEgsU0FBUztnQkFBTTRHO1lBQU07UUFDaEMsRUFBRSxPQUFPcEksT0FBWTtZQUNuQnFELFFBQVFyRCxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxPQUFPO2dCQUFFd0IsU0FBUztnQkFBT3hCLE9BQU9BLE1BQU15QixPQUFPO1lBQUM7UUFDaEQ7SUFDRjtJQUVBLHdGQUF3RjtJQUN4RmtILGtCQUFrQixPQUFPcEI7UUFDdkIsSUFBSTtZQUNGLG1FQUFtRTtZQUNuRSx3REFBd0Q7WUFDeEQsSUFBSUEsS0FBSzVDLE1BQU0sSUFBSSxHQUFHO2dCQUNwQixPQUFPO29CQUFFbkQsU0FBUztnQkFBSztZQUN6QixPQUFPO2dCQUNMLE1BQU0sSUFBSW9ILE1BQU07WUFDbEI7UUFDRixFQUFFLE9BQU81SSxPQUFZO1lBQ25CcUQsUUFBUXJELEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDLE9BQU87Z0JBQUV3QixTQUFTO2dCQUFPeEIsT0FBT0EsTUFBTXlCLE9BQU87WUFBQztRQUNoRDtJQUNGO0FBQ0YsRUFBQztBQUVELHFGQUFxRjtBQUNyRm9ILE9BQU9DLE1BQU0sQ0FBQ25KLFVBQVVrQiIsInNvdXJjZXMiOlsiL2hvbWUvdWJ1bnR1L0VUTEEtUGxhdGZvcm0vZnJvbnRlbmQvc3JjL2xpYi9zdXBhYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvc3VwYWJhc2UudHNcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCBhcyBjcmVhdGVTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX1RPS0VOIVxuXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuXG4vLyBFeHBvcnQgY3JlYXRlQ2xpZW50IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5XG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gKCkgPT4gY3JlYXRlU3VwYWJhc2VDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSlcblxuLy8gRGF0YWJhc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgV29ya1JlcXVlc3Qge1xuICBpZDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBjYXRlZ29yeTogc3RyaW5nXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJ1xuICB1cmdlbmN5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ3VyZ2VudCdcbiAgc3RhdHVzOiAnc3VibWl0dGVkJyB8ICd1bmRlcl9yZXZpZXcnIHwgJ2FwcHJvdmVkJyB8ICdyZWplY3RlZCcgfCAnc2NoZWR1bGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnXG4gIGN1c3RvbWVyX2lkOiBzdHJpbmdcbiAgYXNzaWduZWRfdG8/OiBzdHJpbmdcbiAgZXN0aW1hdGVkX2hvdXJzPzogbnVtYmVyXG4gIGFjdHVhbF9ob3VyczogbnVtYmVyXG4gIGJ1ZGdldD86IG51bWJlclxuICByZXF1aXJlZF9jb21wbGV0aW9uX2RhdGU/OiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3Qge1xuICBpZDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHdvcmtfcmVxdWVzdF9pZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgc3RhdHVzOiAnc2NoZWR1bGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdvbl9ob2xkJyB8ICdjYW5jZWxsZWQnXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJ1xuICBhc3NpZ25lZF90ZWFtX2xlYWQ6IHN0cmluZ1xuICBlc3RpbWF0ZWRfaG91cnM6IG51bWJlclxuICBhY3R1YWxfaG91cnM6IG51bWJlclxuICBidWRnZXQ/OiBudW1iZXJcbiAgc3RhcnRfZGF0ZTogc3RyaW5nXG4gIGVuZF9kYXRlOiBzdHJpbmdcbiAgY29tcGxldGlvbl9wZXJjZW50YWdlOiBudW1iZXJcbiAgY2xpZW50X3NhdGlzZmFjdGlvbl9zY29yZT86IG51bWJlclxuICBvbl90aW1lX2RlbGl2ZXJ5PzogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBjb21wYW55X25hbWU6IHN0cmluZ1xuICBzdWJkb21haW4/OiBzdHJpbmdcbiAgaW5kdXN0cnk/OiBzdHJpbmdcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICd0cmlhbCcgfCAnc3VzcGVuZGVkJyB8ICdjYW5jZWxsZWQnXG4gIHN1YnNjcmlwdGlvbl9wbGFuOiAndHJpYWwnIHwgJ3Byb2Zlc3Npb25hbCcgfCAnZW50ZXJwcmlzZSdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBmaXJzdF9uYW1lOiBzdHJpbmdcbiAgbGFzdF9uYW1lOiBzdHJpbmdcbiAgcm9sZTogJ2hvc3RfYWRtaW4nIHwgJ3Byb2dyYW1fbWFuYWdlcicgfCAnY2xpZW50X2FkbWluJyB8ICdjbGllbnRfdXNlcidcbiAgdGVuYW50X2lkPzogc3RyaW5nXG4gIGlzX2FjdGl2ZTogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbn1cblxuLy8gRXh0ZW5kZWQgVXNlciBpbnRlcmZhY2UgZm9yIHVzZXIgbWFuYWdlbWVudFxuZXhwb3J0IGludGVyZmFjZSBFeHRlbmRlZFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZnVsbF9uYW1lOiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB0ZW5hbnRfbmFtZT86IHN0cmluZ1xuICBpc19hY3RpdmU6IGJvb2xlYW5cbiAgY2FuX2ludml0ZV91c2VyczogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGxhc3RfbG9naW4/OiBzdHJpbmdcbn1cblxuLy8gVXNlciBjcmVhdGlvbiBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBVc2VyQ3JlYXRpb25EYXRhIHtcbiAgZW1haWw6IHN0cmluZ1xuICBmdWxsX25hbWU6IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBkZXBhcnRtZW50Pzogc3RyaW5nXG4gIGpvYl90aXRsZT86IHN0cmluZ1xuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHBhc3N3b3JkOiBzdHJpbmdcbiAgY2FuX2ludml0ZV91c2VyczogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU6IHN0cmluZ1xufVxuXG4vLyBVc2VyIGludml0YXRpb24gZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlckludml0YXRpb25EYXRhIHtcbiAgZW1haWxzOiBzdHJpbmdbXVxuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbiAgZXhwaXJlc19pbl9kYXlzOiBudW1iZXJcbn1cblxuLy8gVXNlciB1cGRhdGUgZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclVwZGF0ZURhdGEge1xuICBmdWxsX25hbWU/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZT86IHN0cmluZ1xuICByb2xlX2xldmVsPzogc3RyaW5nXG4gIHRlbmFudF9pZD86IHN0cmluZ1xuICBpc19hY3RpdmU/OiBib29sZWFuXG4gIGNhbl9pbnZpdGVfdXNlcnM/OiBib29sZWFuXG4gIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM/OiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU/OiBzdHJpbmdcbn1cblxuLy8gQ2xlYW51cCBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBDbGVhbnVwT3B0aW9ucyB7XG4gIGRlbGV0ZUluYWN0aXZlVXNlcnM6IGJvb2xlYW5cbiAgZGVsZXRlVW5jb25maXJtZWRVc2VyczogYm9vbGVhblxuICBkZWxldGVFeHBpcmVkSW52aXRlczogYm9vbGVhblxuICBpbmFjdGl2ZURheXM6IG51bWJlclxuICB1bmNvbmZpcm1lZERheXM6IG51bWJlclxufVxuXG4vLyBBdXRoIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzaWduSW5XaXRoUm9sZSA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZFxuICB9KVxuICBcbiAgaWYgKGRhdGEudXNlcikge1xuICAgIC8vIEdldCB1c2VyIHByb2ZpbGUgd2l0aCByb2xlIGFuZCB0ZW5hbnRcbiAgICBjb25zdCB7IGRhdGE6IHByb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgncm9sZSwgdGVuYW50X2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUnKVxuICAgICAgLmVxKCdpZCcsIGRhdGEudXNlci5pZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIFxuICAgIHJldHVybiB7IHVzZXI6IGRhdGEudXNlciwgcHJvZmlsZSwgZXJyb3IgfVxuICB9XG4gIFxuICByZXR1cm4geyB1c2VyOiBudWxsLCBwcm9maWxlOiBudWxsLCBlcnJvciB9XG59XG5cbmV4cG9ydCBjb25zdCBzaWduT3V0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKVxuICByZXR1cm4geyBlcnJvciB9XG59XG5cbi8vIERhdGFiYXNlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VXNlciA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgaWYgKCF1c2VyKSByZXR1cm4gbnVsbFxuICBcbiAgY29uc3QgeyBkYXRhOiBwcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCd1c2VycycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgLnNpbmdsZSgpXG4gIFxuICByZXR1cm4geyAuLi51c2VyLCBwcm9maWxlIH1cbn1cblxuLy8gVXNlciBNYW5hZ2VtZW50IE1ldGhvZHNcbmV4cG9ydCBjb25zdCB1c2VyTWFuYWdlbWVudCA9IHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHVzZXIgd2l0aCBjb21wbGV0ZSBSQkFDIHNldHVwXG4gIGNyZWF0ZVVzZXI6IGFzeW5jICh1c2VyRGF0YTogVXNlckNyZWF0aW9uRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCwgY3JlYXRlIHRoZSBhdXRoIHVzZXJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXV0aERhdGEsIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uY3JlYXRlVXNlcih7XG4gICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgcGFzc3dvcmQ6IHVzZXJEYXRhLnBhc3N3b3JkLFxuICAgICAgICBlbWFpbF9jb25maXJtOiB0cnVlLFxuICAgICAgICB1c2VyX21ldGFkYXRhOiB7XG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChhdXRoRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBhdXRoRXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXV0aERhdGEudXNlcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIHVzZXIgYWNjb3VudCcgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHVzZXIgcHJvZmlsZSAoRklYRUQ6IHVzaW5nICdwcm9maWxlcycgbm90ICd1c2VyX3Byb2ZpbGVzJylcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHByb2ZpbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICAgIGZ1bGxfbmFtZTogdXNlckRhdGEuZnVsbF9uYW1lLFxuICAgICAgICAgIHBob25lOiB1c2VyRGF0YS5waG9uZSxcbiAgICAgICAgICBkZXBhcnRtZW50OiB1c2VyRGF0YS5kZXBhcnRtZW50LFxuICAgICAgICAgIGpvYl90aXRsZTogdXNlckRhdGEuam9iX3RpdGxlLFxuICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgcm9sZV9sZXZlbDogdXNlckRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICB0ZW5hbnRfaWQ6IHVzZXJEYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgY2FuX2ludml0ZV91c2VyczogdXNlckRhdGEuY2FuX2ludml0ZV91c2VycyxcbiAgICAgICAgICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiB1c2VyRGF0YS5jYW5fbWFuYWdlX3N1Yl9jbGllbnRzLFxuICAgICAgICAgIHBlcm1pc3Npb25fc2NvcGU6IHVzZXJEYXRhLnBlcm1pc3Npb25fc2NvcGUsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuXG4gICAgICBpZiAocHJvZmlsZUVycm9yKSB7XG4gICAgICAgIC8vIElmIHByb2ZpbGUgY3JlYXRpb24gZmFpbHMsIGNsZWFuIHVwIHRoZSBhdXRoIHVzZXJcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFByb2ZpbGUgY3JlYXRpb24gZmFpbGVkOiAke3Byb2ZpbGVFcnJvci5tZXNzYWdlfWAgfVxuICAgICAgfVxuXG4gICAgICAvLyBORVc6IENyZWF0ZSB0ZW5hbnRfdXNlcnMgcmVjb3JkIGZvciBSQkFDXG4gICAgICBjb25zdCB7IGVycm9yOiB0ZW5hbnRVc2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0ZW5hbnRfdXNlcnMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB0ZW5hbnRfaWQ6IHVzZXJEYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICB1c2VyX2lkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgcm9sZV9sZXZlbDogdXNlckRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICBjYW5faW52aXRlX3VzZXJzOiB1c2VyRGF0YS5jYW5faW52aXRlX3VzZXJzLFxuICAgICAgICAgIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IHVzZXJEYXRhLmNhbl9tYW5hZ2Vfc3ViX2NsaWVudHMsXG4gICAgICAgICAgcGVybWlzc2lvbl9zY29wZTogdXNlckRhdGEucGVybWlzc2lvbl9zY29wZSxcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuXG4gICAgICBpZiAodGVuYW50VXNlckVycm9yKSB7XG4gICAgICAgIC8vIElmIHRlbmFudF91c2VycyBjcmVhdGlvbiBmYWlscywgY2xlYW4gdXAgYXV0aCB1c2VyIGFuZCBwcm9maWxlXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZGVsZXRlVXNlcihhdXRoRGF0YS51c2VyLmlkKVxuICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLmRlbGV0ZSgpLmVxKCdpZCcsIGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFRlbmFudCBhc3NpZ25tZW50IGZhaWxlZDogJHt0ZW5hbnRVc2VyRXJyb3IubWVzc2FnZX1gIH1cbiAgICAgIH1cblxuICAgICAgLy8gT1BUSU9OQUw6IENyZWF0ZSBhdWRpdCBsb2cgaWYgdGFibGUgZXhpc3RzXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdhdWRpdF9sb2dzJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgICB0ZW5hbnRfaWQ6IHVzZXJEYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJfY3JlYXRlZCcsXG4gICAgICAgICAgICByZXNvdXJjZV90eXBlOiAndXNlcicsXG4gICAgICAgICAgICByZXNvdXJjZV9pZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgY3JlYXRlZF9ieTogJ2FkbWluX2ludGVyZmFjZScsXG4gICAgICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlwX2FkZHJlc3M6ICcxMjcuMC4wLjEnLFxuICAgICAgICAgICAgdXNlcl9hZ2VudDogJ0FkbWluIEludGVyZmFjZScsXG4gICAgICAgICAgICBzZXZlcml0eTogJ2luZm8nLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGF1ZGl0RXJyb3IpIHtcbiAgICAgICAgLy8gQXVkaXQgbG9nIGlzIG9wdGlvbmFsLCBkb24ndCBmYWlsIHRoZSB1c2VyIGNyZWF0aW9uXG4gICAgICAgIGNvbnNvbGUud2FybignQXVkaXQgbG9nIGNyZWF0aW9uIGZhaWxlZDonLCBhdWRpdEVycm9yKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBhdXRoRGF0YS51c2VyIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBJbnZpdGUgdXNlcnMgdmlhIGVtYWlsXG4gIGludml0ZVVzZXJzOiBhc3luYyAoaW52aXRhdGlvbkRhdGE6IFVzZXJJbnZpdGF0aW9uRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnZpdGF0aW9ucyA9IFtdXG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgaW52aXRhdGlvbkRhdGEuZW1haWxzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbnZpdGF0aW9uIHJlY29yZFxuICAgICAgICBjb25zdCB7IGRhdGE6IGludml0YXRpb24sIGVycm9yOiBpbnZpdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHJvbGU6IGludml0YXRpb25EYXRhLnJvbGUsXG4gICAgICAgICAgICByb2xlX2xldmVsOiBpbnZpdGF0aW9uRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgICAgdGVuYW50X2lkOiBpbnZpdGF0aW9uRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBpbnZpdGF0aW9uRGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIGludml0YXRpb25EYXRhLmV4cGlyZXNfaW5fZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGlmIChpbnZpdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgaW52aXRhdGlvbiBmb3IgJHtlbWFpbH06YCwgaW52aXRlRXJyb3IpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgaW52aXRhdGlvbiBlbWFpbCB1c2luZyBTdXBhYmFzZSBBdXRoXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGVtYWlsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIHtcbiAgICAgICAgICByZWRpcmVjdFRvOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hY2NlcHQtaW52aXRhdGlvbj90b2tlbj0ke2ludml0YXRpb24uaWR9YCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByb2xlOiBpbnZpdGF0aW9uRGF0YS5yb2xlLFxuICAgICAgICAgICAgcm9sZV9sZXZlbDogaW52aXRhdGlvbkRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICAgIHRlbmFudF9pZDogaW52aXRhdGlvbkRhdGEudGVuYW50X2lkLFxuICAgICAgICAgICAgaW52aXRhdGlvbl9pZDogaW52aXRhdGlvbi5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZW1haWxFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzZW5kIGludml0YXRpb24gZW1haWwgdG8gJHtlbWFpbH06YCwgZW1haWxFcnJvcilcbiAgICAgICAgICAvLyBNYXJrIGludml0YXRpb24gYXMgZmFpbGVkXG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAgIC51cGRhdGUoeyBzdGF0dXM6ICdmYWlsZWQnIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbi5pZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZpdGF0aW9ucy5wdXNoKGludml0YXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgICBkYXRhOiB7IFxuICAgICAgICAgIHNlbnQ6IGludml0YXRpb25zLmxlbmd0aCwgXG4gICAgICAgICAgdG90YWw6IGludml0YXRpb25EYXRhLmVtYWlscy5sZW5ndGggXG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc2VuZCBpbnZpdGF0aW9ucycgfVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgdXNlciBpbmZvcm1hdGlvblxuICB1cGRhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFVzZXJVcGRhdGVEYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIC4uLnVwZGF0ZURhdGEsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBEZWFjdGl2YXRlIHVzZXJcbiAgZGVhY3RpdmF0ZVVzZXI6IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBpc19hY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVhY3RpdmF0ZSB1c2VyJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEFjdGl2YXRlIHVzZXJcbiAgYWN0aXZhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYWN0aXZhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBSZXNldCB1c2VyIHBhc3N3b3JkXG4gIHJlc2V0VXNlclBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZywgbmV3UGFzc3dvcmQ/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5ld1Bhc3N3b3JkKSB7XG4gICAgICAgIC8vIERpcmVjdCBwYXNzd29yZCByZXNldCAoYWRtaW4gZnVuY3Rpb24pXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4udXBkYXRlVXNlckJ5SWQoXG4gICAgICAgICAgZW1haWwsIC8vIFRoaXMgc2hvdWxkIGJlIHVzZXIgSUQsIGJ1dCB3ZSdsbCBuZWVkIHRvIGdldCBpdCBmaXJzdFxuICAgICAgICAgIHsgcGFzc3dvcmQ6IG5ld1Bhc3N3b3JkIH1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtYWlsLWJhc2VkIHBhc3N3b3JkIHJlc2V0XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVzZXRQYXNzd29yZEZvckVtYWlsKGVtYWlsLCB7XG4gICAgICAgICAgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vcmVzZXQtcGFzc3dvcmRgXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHJlc2V0IHBhc3N3b3JkJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFByZXZpZXcgY2xlYW51cCBvcGVyYXRpb25zXG4gIHByZXZpZXdVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpbmFjdGl2ZVVzZXJzID0gMFxuICAgICAgbGV0IHVuY29uZmlybWVkVXNlcnMgPSAwXG4gICAgICBsZXQgZXhwaXJlZEludml0ZXMgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmx0KCdsYXN0X2xvZ2luJywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaW5hY3RpdmVVc2VycyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlVW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMudW5jb25maXJtZWREYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdhdXRoLnVzZXJzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5pcygnZW1haWxfY29uZmlybWVkX2F0JywgbnVsbClcbiAgICAgICAgICAubHQoJ2NyZWF0ZWRfYXQnLCBjdXRvZmZEYXRlKVxuXG4gICAgICAgIHVuY29uZmlybWVkVXNlcnMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUV4cGlyZWRJbnZpdGVzKSB7XG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgICAgIC5uZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG5cbiAgICAgICAgZXhwaXJlZEludml0ZXMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsVG9EZWxldGUgPSBpbmFjdGl2ZVVzZXJzICsgdW5jb25maXJtZWRVc2VycyArIGV4cGlyZWRJbnZpdGVzXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmFjdGl2ZVVzZXJzLFxuICAgICAgICAgIHVuY29uZmlybWVkVXNlcnMsXG4gICAgICAgICAgZXhwaXJlZEludml0ZXMsXG4gICAgICAgICAgdG90YWxUb0RlbGV0ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJldmlldyBjbGVhbnVwJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEV4ZWN1dGUgY2xlYW51cCBvcGVyYXRpb25zXG4gIGV4ZWN1dGVVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZWxldGVkQ291bnQgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBpbmFjdGl2ZSB1c2Vyc1xuICAgICAgICBjb25zdCB7IGRhdGE6IGluYWN0aXZlVXNlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgLmx0KCdsYXN0X2xvZ2luJywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaWYgKGluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHVzZXIgb2YgaW5hY3RpdmVVc2Vycykge1xuICAgICAgICAgICAgLy8gRGVsZXRlIGF1dGggdXNlclxuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKHVzZXIuaWQpXG4gICAgICAgICAgICAvLyBEZWxldGUgcHJvZmlsZVxuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGVkQ291bnQgKz0gaW5hY3RpdmVVc2Vycy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVVbmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy51bmNvbmZpcm1lZERheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIFxuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgYWRtaW4gYWNjZXNzIHRvIGF1dGgudXNlcnMgdGFibGVcbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgbWFyayB0aGVtIGFzIGluYWN0aXZlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogdW5jb25maXJtZWRVc2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAubHQoJ2NyZWF0ZWRfYXQnLCBjdXRvZmZEYXRlKVxuICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICAgICAgICBpZiAodW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7IGlzX2FjdGl2ZTogZmFsc2UgfSlcbiAgICAgICAgICAgIC5pbignaWQnLCB1bmNvbmZpcm1lZFVzZXJzLm1hcCh1ID0+IHUuaWQpKVxuICAgICAgICAgIFxuICAgICAgICAgIGRlbGV0ZWRDb3VudCArPSB1bmNvbmZpcm1lZFVzZXJzLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUV4cGlyZWRJbnZpdGVzKSB7XG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5sdCgnZXhwaXJlc19hdCcsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgICAgICAubmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuXG4gICAgICAgIGRlbGV0ZWRDb3VudCArPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgZGVsZXRlZENvdW50IH0gfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGV4ZWN1dGUgY2xlYW51cCcgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWZhTWFuYWdlbWVudCA9IHtcbiAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgTUZBIGVuYWJsZWRcbiAgY2hlY2tNRkFTdGF0dXM6IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAuc2VsZWN0KCdtZmFfZW5hYmxlZCcpXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBtZmFFbmFibGVkOiBkYXRhPy5tZmFfZW5hYmxlZCB8fCBmYWxzZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgTUZBIHN0YXR1czonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IG1mYUVuYWJsZWQ6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEVuYWJsZSBNRkEgZm9yIHVzZXJcbiAgZW5hYmxlTUZBOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVucm9sbCBmb3IgVE9UUCBNRkFcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLmVucm9sbCh7XG4gICAgICAgIGZhY3RvclR5cGU6ICd0b3RwJyxcbiAgICAgICAgZnJpZW5kbHlOYW1lOiAnRVRMQSBQbGF0Zm9ybSBUT1RQJ1xuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5hYmxpbmcgTUZBOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gVmVyaWZ5IE1GQSBzZXR1cFxuICB2ZXJpZnlNRkFTZXR1cDogYXN5bmMgKGZhY3RvcklkOiBzdHJpbmcsIGNvZGU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgY2hhbGxlbmdlIGZpcnN0XG4gICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLm1mYS5jaGFsbGVuZ2Uoe1xuICAgICAgICBmYWN0b3JJZFxuICAgICAgfSlcblxuICAgICAgaWYgKGNoYWxsZW5nZUVycm9yKSB0aHJvdyBjaGFsbGVuZ2VFcnJvclxuXG4gICAgICAvLyBWZXJpZnkgdGhlIGNvZGVcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLnZlcmlmeSh7XG4gICAgICAgIGZhY3RvcklkLFxuICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlLmlkLFxuICAgICAgICBjb2RlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHByb2ZpbGUgdG8gaW5kaWNhdGUgTUZBIGlzIGVuYWJsZWRcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICBpZiAodXNlcikge1xuICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgICAgbWZhX2VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgTUZBIHNldHVwOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gRGlzYWJsZSBNRkEgZm9yIHVzZXJcbiAgZGlzYWJsZU1GQTogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgYWxsIGZhY3RvcnNcbiAgICAgIGNvbnN0IHsgZGF0YTogZmFjdG9ycywgZXJyb3I6IGZhY3RvcnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEubGlzdEZhY3RvcnMoKVxuICAgICAgXG4gICAgICBpZiAoZmFjdG9yc0Vycm9yKSB0aHJvdyBmYWN0b3JzRXJyb3JcblxuICAgICAgLy8gVW5lbnJvbGwgYWxsIFRPVFAgZmFjdG9yc1xuICAgICAgaWYgKGZhY3RvcnM/LnRvdHApIHtcbiAgICAgICAgZm9yIChjb25zdCBmYWN0b3Igb2YgZmFjdG9ycy50b3RwKSB7XG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEudW5lbnJvbGwoeyBmYWN0b3JJZDogZmFjdG9yLmlkIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHVzZXIgcHJvZmlsZVxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgICBtZmFfZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkaXNhYmxpbmcgTUZBOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gR2VuZXJhdGUgYmFja3VwIGNvZGVzIChzaW11bGF0ZWQgLSBpbiBwcm9kdWN0aW9uIHRoaXMgd291bGQgYmUgaGFuZGxlZCBieSB5b3VyIGJhY2tlbmQpXG4gIGdlbmVyYXRlQmFja3VwQ29kZXM6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhdGUgOCBiYWNrdXAgY29kZXNcbiAgICAgIGNvbnN0IGNvZGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogOCB9LCAoKSA9PiBcbiAgICAgICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpLnRvVXBwZXJDYXNlKClcbiAgICAgIClcblxuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IHdvdWxkIHN0b3JlIHRoZXNlIHNlY3VyZWx5IGluIHlvdXIgYmFja2VuZFxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCByZXR1cm4gdGhlbVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY29kZXMgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgYmFja3VwIGNvZGVzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gVmVyaWZ5IGJhY2t1cCBjb2RlIChzaW11bGF0ZWQgLSBpbiBwcm9kdWN0aW9uIHRoaXMgd291bGQgdmVyaWZ5IGFnYWluc3Qgc3RvcmVkIGNvZGVzKVxuICB2ZXJpZnlCYWNrdXBDb2RlOiBhc3luYyAoY29kZTogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSB3b3VsZCB2ZXJpZnkgdGhpcyBhZ2FpbnN0IHN0b3JlZCBiYWNrdXAgY29kZXNcbiAgICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCB3ZSdsbCBhY2NlcHQgYW55IDYrIGNoYXJhY3RlciBjb2RlXG4gICAgICBpZiAoY29kZS5sZW5ndGggPj0gNikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAgY29kZScpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGJhY2t1cCBjb2RlOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQWRkIHVzZXIgbWFuYWdlbWVudCBtZXRob2RzIHRvIHRoZSBtYWluIHN1cGFiYXNlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuT2JqZWN0LmFzc2lnbihzdXBhYmFzZSwgdXNlck1hbmFnZW1lbnQpXG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjcmVhdGVTdXBhYmFzZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4iLCJzdXBhYmFzZSIsInNpZ25JbldpdGhSb2xlIiwiZW1haWwiLCJwYXNzd29yZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJ1c2VyIiwicHJvZmlsZSIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwic2lnbk91dCIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlciIsInVzZXJNYW5hZ2VtZW50IiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwiYXV0aERhdGEiLCJhdXRoRXJyb3IiLCJhZG1pbiIsImVtYWlsX2NvbmZpcm0iLCJ1c2VyX21ldGFkYXRhIiwiZnVsbF9uYW1lIiwicm9sZSIsInJvbGVfbGV2ZWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsInByb2ZpbGVFcnJvciIsImluc2VydCIsInBob25lIiwiZGVwYXJ0bWVudCIsImpvYl90aXRsZSIsInRlbmFudF9pZCIsImlzX2FjdGl2ZSIsImNhbl9pbnZpdGVfdXNlcnMiLCJjYW5fbWFuYWdlX3N1Yl9jbGllbnRzIiwicGVybWlzc2lvbl9zY29wZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlVXNlciIsInRlbmFudFVzZXJFcnJvciIsInVzZXJfaWQiLCJkZWxldGUiLCJhY3Rpb24iLCJyZXNvdXJjZV90eXBlIiwicmVzb3VyY2VfaWQiLCJkZXRhaWxzIiwiY3JlYXRlZF9ieSIsImlwX2FkZHJlc3MiLCJ1c2VyX2FnZW50Iiwic2V2ZXJpdHkiLCJhdWRpdEVycm9yIiwiY29uc29sZSIsIndhcm4iLCJpbnZpdGVVc2VycyIsImludml0YXRpb25EYXRhIiwiaW52aXRhdGlvbnMiLCJlbWFpbHMiLCJpbnZpdGF0aW9uIiwiaW52aXRlRXJyb3IiLCJleHBpcmVzX2F0Iiwibm93IiwiZXhwaXJlc19pbl9kYXlzIiwiZW1haWxFcnJvciIsImludml0ZVVzZXJCeUVtYWlsIiwicmVkaXJlY3RUbyIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiaW52aXRhdGlvbl9pZCIsInVwZGF0ZSIsInN0YXR1cyIsInB1c2giLCJzZW50IiwibGVuZ3RoIiwidG90YWwiLCJ1cGRhdGVVc2VyIiwidXNlcklkIiwidXBkYXRlRGF0YSIsImRlYWN0aXZhdGVVc2VyIiwiYWN0aXZhdGVVc2VyIiwicmVzZXRVc2VyUGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsInVwZGF0ZVVzZXJCeUlkIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwicHJldmlld1VzZXJDbGVhbnVwIiwib3B0aW9ucyIsImluYWN0aXZlVXNlcnMiLCJ1bmNvbmZpcm1lZFVzZXJzIiwiZXhwaXJlZEludml0ZXMiLCJkZWxldGVJbmFjdGl2ZVVzZXJzIiwiY3V0b2ZmRGF0ZSIsImluYWN0aXZlRGF5cyIsImNvdW50IiwiaGVhZCIsImx0IiwiZGVsZXRlVW5jb25maXJtZWRVc2VycyIsInVuY29uZmlybWVkRGF5cyIsImlzIiwiZGVsZXRlRXhwaXJlZEludml0ZXMiLCJuZXEiLCJ0b3RhbFRvRGVsZXRlIiwiZXhlY3V0ZVVzZXJDbGVhbnVwIiwiZGVsZXRlZENvdW50IiwiaW4iLCJtYXAiLCJ1IiwibWZhTWFuYWdlbWVudCIsImNoZWNrTUZBU3RhdHVzIiwibWZhRW5hYmxlZCIsIm1mYV9lbmFibGVkIiwiZW5hYmxlTUZBIiwibWZhIiwiZW5yb2xsIiwiZmFjdG9yVHlwZSIsImZyaWVuZGx5TmFtZSIsInZlcmlmeU1GQVNldHVwIiwiZmFjdG9ySWQiLCJjb2RlIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlRXJyb3IiLCJ2ZXJpZnkiLCJjaGFsbGVuZ2VJZCIsImRpc2FibGVNRkEiLCJmYWN0b3JzIiwiZmFjdG9yc0Vycm9yIiwibGlzdEZhY3RvcnMiLCJ0b3RwIiwiZmFjdG9yIiwidW5lbnJvbGwiLCJnZW5lcmF0ZUJhY2t1cENvZGVzIiwiY29kZXMiLCJBcnJheSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInRvVXBwZXJDYXNlIiwidmVyaWZ5QmFja3VwQ29kZSIsIkVycm9yIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

}]);