"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/access-control/page",{

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   signInWithRole: () => (/* binding */ signInWithRole),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   userManagement: () => (/* binding */ userManagement)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://your-project.supabase.co\";\nconst supabaseAnonKey = \"your_anon_token_here\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Auth helpers\nconst signInWithRole = async (email, password)=>{\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (data.user) {\n        // Get user profile with role and tenant\n        const { data: profile } = await supabase.from('users').select('role, tenant_id, first_name, last_name').eq('id', data.user.id).single();\n        return {\n            user: data.user,\n            profile,\n            error\n        };\n    }\n    return {\n        user: null,\n        profile: null,\n        error\n    };\n};\nconst signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    return {\n        error\n    };\n};\n// Database helpers\nconst getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data: profile } = await supabase.from('users').select('*').eq('id', user.id).single();\n    return {\n        ...user,\n        profile\n    };\n};\n// User Management Methods\nconst userManagement = {\n    // Create a new user with complete RBAC setup\n    createUser: async (userData)=>{\n        try {\n            // First, create the auth user\n            const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n                email: userData.email,\n                password: userData.password,\n                email_confirm: true,\n                user_metadata: {\n                    full_name: userData.full_name,\n                    role: userData.role,\n                    role_level: userData.role_level\n                }\n            });\n            if (authError) {\n                return {\n                    success: false,\n                    error: authError.message\n                };\n            }\n            if (!authData.user) {\n                return {\n                    success: false,\n                    error: 'Failed to create user account'\n                };\n            }\n            // Create the user profile\n            const { error: profileError } = await supabase.from('profiles').insert({\n                id: authData.user.id,\n                email: userData.email,\n                full_name: userData.full_name,\n                phone: userData.phone,\n                department: userData.department,\n                job_title: userData.job_title,\n                role: userData.role,\n                role_level: userData.role_level,\n                tenant_id: userData.tenant_id,\n                is_active: true,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (profileError) {\n                // If profile creation fails, clean up the auth user\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                return {\n                    success: false,\n                    error: \"Profile creation failed: \".concat(profileError.message)\n                };\n            }\n            // Create tenant_users record for RBAC\n            const { error: tenantUserError } = await supabase.from('tenant_users').insert({\n                tenant_id: userData.tenant_id,\n                user_id: authData.user.id,\n                role: userData.role,\n                role_level: userData.role_level,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (tenantUserError) {\n                // If tenant_users creation fails, clean up auth user and profile\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                await supabase.from('profiles').delete().eq('id', authData.user.id);\n                return {\n                    success: false,\n                    error: \"Tenant assignment failed: \".concat(tenantUserError.message)\n                };\n            }\n            return {\n                success: true,\n                data: authData.user\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to create user'\n            };\n        }\n    },\n    // Invite users via email\n    inviteUsers: async (invitationData)=>{\n        try {\n            const invitations = [];\n            for (const email of invitationData.emails){\n                // Create invitation record\n                const { data: invitation, error: inviteError } = await supabase.from('user_invitations').insert({\n                    email,\n                    role: invitationData.role,\n                    role_level: invitationData.role_level,\n                    tenant_id: invitationData.tenant_id,\n                    message: invitationData.message,\n                    expires_at: new Date(Date.now() + invitationData.expires_in_days * 24 * 60 * 60 * 1000).toISOString(),\n                    created_at: new Date().toISOString()\n                }).select().single();\n                if (inviteError) {\n                    console.error(\"Failed to create invitation for \".concat(email, \":\"), inviteError);\n                    continue;\n                }\n                // Send invitation email using Supabase Auth\n                const { error: emailError } = await supabase.auth.admin.inviteUserByEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/accept-invitation?token=\").concat(invitation.id),\n                    data: {\n                        role: invitationData.role,\n                        role_level: invitationData.role_level,\n                        tenant_id: invitationData.tenant_id,\n                        invitation_id: invitation.id\n                    }\n                });\n                if (emailError) {\n                    console.error(\"Failed to send invitation email to \".concat(email, \":\"), emailError);\n                    // Mark invitation as failed\n                    await supabase.from('user_invitations').update({\n                        status: 'failed'\n                    }).eq('id', invitation.id);\n                } else {\n                    invitations.push(invitation);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    sent: invitations.length,\n                    total: invitationData.emails.length\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to send invitations'\n            };\n        }\n    },\n    // Update user information\n    updateUser: async (userId, updateData)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                ...updateData,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to update user'\n            };\n        }\n    },\n    // Reset user password\n    resetUserPassword: async (email, newPassword)=>{\n        try {\n            if (newPassword) {\n                // Direct password reset (admin function)\n                const { error } = await supabase.auth.admin.updateUserById(email, {\n                    password: newPassword\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            } else {\n                // Email-based password reset\n                const { error } = await supabase.auth.resetPasswordForEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/reset-password\")\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to reset password'\n            };\n        }\n    },\n    // Preview cleanup operations\n    previewUserCleanup: async (options)=>{\n        try {\n            let inactiveUsers = 0;\n            let unconfirmedUsers = 0;\n            let expiredInvites = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('profiles').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('last_login', cutoffDate).eq('is_active', true);\n                inactiveUsers = count || 0;\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('auth.users').select('*', {\n                    count: 'exact',\n                    head: true\n                }).is('email_confirmed_at', null).lt('created_at', cutoffDate);\n                unconfirmedUsers = count || 0;\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                expiredInvites = count || 0;\n            }\n            const totalToDelete = inactiveUsers + unconfirmedUsers + expiredInvites;\n            return {\n                success: true,\n                data: {\n                    inactiveUsers,\n                    unconfirmedUsers,\n                    expiredInvites,\n                    totalToDelete\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to preview cleanup'\n            };\n        }\n    },\n    // Execute cleanup operations\n    executeUserCleanup: async (options)=>{\n        try {\n            let deletedCount = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                // Get inactive users\n                const { data: inactiveUsers } = await supabase.from('profiles').select('id').lt('last_login', cutoffDate).eq('is_active', true);\n                if (inactiveUsers && inactiveUsers.length > 0) {\n                    // Delete from auth\n                    for (const user of inactiveUsers){\n                        await supabase.auth.admin.deleteUser(user.id);\n                    }\n                    deletedCount += inactiveUsers.length;\n                }\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                // This would require admin access to auth.users table\n                // For now, we'll just return success\n                console.log('Unconfirmed users cleanup would be executed here');\n            }\n            if (options.deleteExpiredInvites) {\n                const { error } = await supabase.from('user_invitations').delete().lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                if (error) {\n                    console.error('Failed to delete expired invites:', error);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    deletedCount\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to execute cleanup'\n            };\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU1oRCxXQUFXO2dCQUVuRyxzREFBc0Q7Z0JBQ3RELHFDQUFxQztnQkFDckNlLFFBQVF3QyxHQUFHLENBQUM7WUFDZDtZQUVBLElBQUlsQixRQUFRYSxvQkFBb0IsRUFBRTtnQkFDaEMsTUFBTSxFQUFFeEYsS0FBSyxFQUFFLEdBQUcsTUFBTUwsU0FDckJVLElBQUksQ0FBQyxvQkFDTHNDLE1BQU0sR0FDTnlDLEVBQUUsQ0FBQyxjQUFjLElBQUkvQyxPQUFPQyxXQUFXLElBQ3ZDbUQsR0FBRyxDQUFDLFVBQVU7Z0JBRWpCLElBQUl6RixPQUFPO29CQUNUcUQsUUFBUXJELEtBQUssQ0FBQyxxQ0FBcUNBO2dCQUNyRDtZQUNGO1lBRUEsT0FBTztnQkFDTHdCLFNBQVM7Z0JBQ1R6QixNQUFNO29CQUFFNkY7Z0JBQWE7WUFDdkI7UUFDRixFQUFFLE9BQU81RixPQUFZO1lBQ25CLE9BQU87Z0JBQUV3QixTQUFTO2dCQUFPeEIsT0FBT0EsTUFBTXlCLE9BQU8sSUFBSTtZQUE0QjtRQUMvRTtJQUNGO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvdWJ1bnR1L0VUTEEtUGxhdGZvcm0vZnJvbnRlbmQvc3JjL2xpYi9zdXBhYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5cbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIVxuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9UT0tFTiFcblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXG5cbi8vIERhdGFiYXNlIHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtSZXF1ZXN0IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgY2F0ZWdvcnk6IHN0cmluZ1xuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCdcbiAgdXJnZW5jeTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICd1cmdlbnQnXG4gIHN0YXR1czogJ3N1Ym1pdHRlZCcgfCAndW5kZXJfcmV2aWV3JyB8ICdhcHByb3ZlZCcgfCAncmVqZWN0ZWQnIHwgJ3NjaGVkdWxlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJ1xuICBjdXN0b21lcl9pZDogc3RyaW5nXG4gIGFzc2lnbmVkX3RvPzogc3RyaW5nXG4gIGVzdGltYXRlZF9ob3Vycz86IG51bWJlclxuICBhY3R1YWxfaG91cnM6IG51bWJlclxuICBidWRnZXQ/OiBudW1iZXJcbiAgcmVxdWlyZWRfY29tcGxldGlvbl9kYXRlPzogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB3b3JrX3JlcXVlc3RfaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIHN0YXR1czogJ3NjaGVkdWxlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnb25faG9sZCcgfCAnY2FuY2VsbGVkJ1xuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCdcbiAgYXNzaWduZWRfdGVhbV9sZWFkOiBzdHJpbmdcbiAgZXN0aW1hdGVkX2hvdXJzOiBudW1iZXJcbiAgYWN0dWFsX2hvdXJzOiBudW1iZXJcbiAgYnVkZ2V0PzogbnVtYmVyXG4gIHN0YXJ0X2RhdGU6IHN0cmluZ1xuICBlbmRfZGF0ZTogc3RyaW5nXG4gIGNvbXBsZXRpb25fcGVyY2VudGFnZTogbnVtYmVyXG4gIGNsaWVudF9zYXRpc2ZhY3Rpb25fc2NvcmU/OiBudW1iZXJcbiAgb25fdGltZV9kZWxpdmVyeT86IGJvb2xlYW5cbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbmFudCB7XG4gIGlkOiBzdHJpbmdcbiAgY29tcGFueV9uYW1lOiBzdHJpbmdcbiAgc3ViZG9tYWluPzogc3RyaW5nXG4gIGluZHVzdHJ5Pzogc3RyaW5nXG4gIHN0YXR1czogJ2FjdGl2ZScgfCAndHJpYWwnIHwgJ3N1c3BlbmRlZCcgfCAnY2FuY2VsbGVkJ1xuICBzdWJzY3JpcHRpb25fcGxhbjogJ3RyaWFsJyB8ICdwcm9mZXNzaW9uYWwnIHwgJ2VudGVycHJpc2UnXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZmlyc3RfbmFtZTogc3RyaW5nXG4gIGxhc3RfbmFtZTogc3RyaW5nXG4gIHJvbGU6ICdob3N0X2FkbWluJyB8ICdwcm9ncmFtX21hbmFnZXInIHwgJ2NsaWVudF9hZG1pbicgfCAnY2xpZW50X3VzZXInXG4gIHRlbmFudF9pZD86IHN0cmluZ1xuICBpc19hY3RpdmU6IGJvb2xlYW5cbiAgY3JlYXRlZF9hdDogc3RyaW5nXG59XG5cbi8vIEV4dGVuZGVkIFVzZXIgaW50ZXJmYWNlIGZvciB1c2VyIG1hbmFnZW1lbnRcbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZW5kZWRVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGZ1bGxfbmFtZTogc3RyaW5nXG4gIHBob25lPzogc3RyaW5nXG4gIGRlcGFydG1lbnQ/OiBzdHJpbmdcbiAgam9iX3RpdGxlPzogc3RyaW5nXG4gIHJvbGU6IHN0cmluZ1xuICByb2xlX2xldmVsOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgdGVuYW50X25hbWU/OiBzdHJpbmdcbiAgaXNfYWN0aXZlOiBib29sZWFuXG4gIGNhbl9pbnZpdGVfdXNlcnM6IGJvb2xlYW5cbiAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogYm9vbGVhblxuICBwZXJtaXNzaW9uX3Njb3BlOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBsYXN0X2xvZ2luPzogc3RyaW5nXG59XG5cbi8vIFVzZXIgY3JlYXRpb24gZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlckNyZWF0aW9uRGF0YSB7XG4gIGVtYWlsOiBzdHJpbmdcbiAgZnVsbF9uYW1lOiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIGNhbl9pbnZpdGVfdXNlcnM6IGJvb2xlYW5cbiAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogYm9vbGVhblxuICBwZXJtaXNzaW9uX3Njb3BlOiBzdHJpbmdcbn1cblxuLy8gVXNlciBpbnZpdGF0aW9uIGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJJbnZpdGF0aW9uRGF0YSB7XG4gIGVtYWlsczogc3RyaW5nW11cbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICBtZXNzYWdlPzogc3RyaW5nXG4gIGV4cGlyZXNfaW5fZGF5czogbnVtYmVyXG59XG5cbi8vIFVzZXIgdXBkYXRlIGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJVcGRhdGVEYXRhIHtcbiAgZnVsbF9uYW1lPzogc3RyaW5nXG4gIHBob25lPzogc3RyaW5nXG4gIGRlcGFydG1lbnQ/OiBzdHJpbmdcbiAgam9iX3RpdGxlPzogc3RyaW5nXG4gIHJvbGU/OiBzdHJpbmdcbiAgcm9sZV9sZXZlbD86IHN0cmluZ1xuICB0ZW5hbnRfaWQ/OiBzdHJpbmdcbiAgaXNfYWN0aXZlPzogYm9vbGVhblxuICBjYW5faW52aXRlX3VzZXJzPzogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzPzogYm9vbGVhblxuICBwZXJtaXNzaW9uX3Njb3BlPzogc3RyaW5nXG59XG5cbi8vIENsZWFudXAgb3B0aW9ucyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQ2xlYW51cE9wdGlvbnMge1xuICBkZWxldGVJbmFjdGl2ZVVzZXJzOiBib29sZWFuXG4gIGRlbGV0ZVVuY29uZmlybWVkVXNlcnM6IGJvb2xlYW5cbiAgZGVsZXRlRXhwaXJlZEludml0ZXM6IGJvb2xlYW5cbiAgaW5hY3RpdmVEYXlzOiBudW1iZXJcbiAgdW5jb25maXJtZWREYXlzOiBudW1iZXJcbn1cblxuLy8gQXV0aCBoZWxwZXJzXG5leHBvcnQgY29uc3Qgc2lnbkluV2l0aFJvbGUgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgZW1haWwsXG4gICAgcGFzc3dvcmRcbiAgfSlcbiAgXG4gIGlmIChkYXRhLnVzZXIpIHtcbiAgICAvLyBHZXQgdXNlciBwcm9maWxlIHdpdGggcm9sZSBhbmQgdGVuYW50XG4gICAgY29uc3QgeyBkYXRhOiBwcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgIC5zZWxlY3QoJ3JvbGUsIHRlbmFudF9pZCwgZmlyc3RfbmFtZSwgbGFzdF9uYW1lJylcbiAgICAgIC5lcSgnaWQnLCBkYXRhLnVzZXIuaWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBcbiAgICByZXR1cm4geyB1c2VyOiBkYXRhLnVzZXIsIHByb2ZpbGUsIGVycm9yIH1cbiAgfVxuICBcbiAgcmV0dXJuIHsgdXNlcjogbnVsbCwgcHJvZmlsZTogbnVsbCwgZXJyb3IgfVxufVxuXG5leHBvcnQgY29uc3Qgc2lnbk91dCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KClcbiAgcmV0dXJuIHsgZXJyb3IgfVxufVxuXG4vLyBEYXRhYmFzZSBoZWxwZXJzXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGxcbiAgXG4gIGNvbnN0IHsgZGF0YTogcHJvZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgndXNlcnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgIC5zaW5nbGUoKVxuICBcbiAgcmV0dXJuIHsgLi4udXNlciwgcHJvZmlsZSB9XG59XG5cblxuXG4vLyBVc2VyIE1hbmFnZW1lbnQgTWV0aG9kc1xuZXhwb3J0IGNvbnN0IHVzZXJNYW5hZ2VtZW50ID0ge1xuICAvLyBDcmVhdGUgYSBuZXcgdXNlciB3aXRoIGNvbXBsZXRlIFJCQUMgc2V0dXBcbiAgY3JlYXRlVXNlcjogYXN5bmMgKHVzZXJEYXRhOiBVc2VyQ3JlYXRpb25EYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCBjcmVhdGUgdGhlIGF1dGggdXNlclxuICAgICAgY29uc3QgeyBkYXRhOiBhdXRoRGF0YSwgZXJyb3I6IGF1dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5jcmVhdGVVc2VyKHtcbiAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICBwYXNzd29yZDogdXNlckRhdGEucGFzc3dvcmQsXG4gICAgICAgIGVtYWlsX2NvbmZpcm06IHRydWUsXG4gICAgICAgIHVzZXJfbWV0YWRhdGE6IHtcbiAgICAgICAgICBmdWxsX25hbWU6IHVzZXJEYXRhLmZ1bGxfbmFtZSxcbiAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKGF1dGhFcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGF1dGhFcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRoRGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgdXNlciBhY2NvdW50JyB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgdXNlciBwcm9maWxlXG4gICAgICBjb25zdCB7IGVycm9yOiBwcm9maWxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIGlkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgICBmdWxsX25hbWU6IHVzZXJEYXRhLmZ1bGxfbmFtZSxcbiAgICAgICAgICBwaG9uZTogdXNlckRhdGEucGhvbmUsXG4gICAgICAgICAgZGVwYXJ0bWVudDogdXNlckRhdGEuZGVwYXJ0bWVudCxcbiAgICAgICAgICBqb2JfdGl0bGU6IHVzZXJEYXRhLmpvYl90aXRsZSxcbiAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgdGVuYW50X2lkOiB1c2VyRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNhbl9pbnZpdGVfdXNlcnM6IHVzZXJEYXRhLmNhbl9pbnZpdGVfdXNlcnMsXG4gICAgICAgICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogdXNlckRhdGEuY2FuX21hbmFnZV9zdWJfY2xpZW50cyxcbiAgICAgICAgICBwZXJtaXNzaW9uX3Njb3BlOiB1c2VyRGF0YS5wZXJtaXNzaW9uX3Njb3BlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcblxuICAgICAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgICAgICAvLyBJZiBwcm9maWxlIGNyZWF0aW9uIGZhaWxzLCBjbGVhbiB1cCB0aGUgYXV0aCB1c2VyXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZGVsZXRlVXNlcihhdXRoRGF0YS51c2VyLmlkKVxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBQcm9maWxlIGNyZWF0aW9uIGZhaWxlZDogJHtwcm9maWxlRXJyb3IubWVzc2FnZX1gIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHRlbmFudF91c2VycyByZWNvcmQgZm9yIFJCQUNcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHRlbmFudFVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3RlbmFudF91c2VycycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHRlbmFudF9pZDogdXNlckRhdGEudGVuYW50X2lkLFxuICAgICAgICAgIHVzZXJfaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgIGNhbl9pbnZpdGVfdXNlcnM6IHVzZXJEYXRhLmNhbl9pbnZpdGVfdXNlcnMsXG4gICAgICAgICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogdXNlckRhdGEuY2FuX21hbmFnZV9zdWJfY2xpZW50cyxcbiAgICAgICAgICBwZXJtaXNzaW9uX3Njb3BlOiB1c2VyRGF0YS5wZXJtaXNzaW9uX3Njb3BlLFxuICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG5cbiAgICAgIGlmICh0ZW5hbnRVc2VyRXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGVuYW50X3VzZXJzIGNyZWF0aW9uIGZhaWxzLCBjbGVhbiB1cCBhdXRoIHVzZXIgYW5kIHByb2ZpbGVcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuZGVsZXRlKCkuZXEoJ2lkJywgYXV0aERhdGEudXNlci5pZClcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgVGVuYW50IGFzc2lnbm1lbnQgZmFpbGVkOiAke3RlbmFudFVzZXJFcnJvci5tZXNzYWdlfWAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBhdXRoRGF0YS51c2VyIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBJbnZpdGUgdXNlcnMgdmlhIGVtYWlsXG4gIGludml0ZVVzZXJzOiBhc3luYyAoaW52aXRhdGlvbkRhdGE6IFVzZXJJbnZpdGF0aW9uRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnZpdGF0aW9ucyA9IFtdXG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgaW52aXRhdGlvbkRhdGEuZW1haWxzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbnZpdGF0aW9uIHJlY29yZFxuICAgICAgICBjb25zdCB7IGRhdGE6IGludml0YXRpb24sIGVycm9yOiBpbnZpdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHJvbGU6IGludml0YXRpb25EYXRhLnJvbGUsXG4gICAgICAgICAgICByb2xlX2xldmVsOiBpbnZpdGF0aW9uRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgICAgdGVuYW50X2lkOiBpbnZpdGF0aW9uRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBpbnZpdGF0aW9uRGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIGludml0YXRpb25EYXRhLmV4cGlyZXNfaW5fZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGlmIChpbnZpdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgaW52aXRhdGlvbiBmb3IgJHtlbWFpbH06YCwgaW52aXRlRXJyb3IpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgaW52aXRhdGlvbiBlbWFpbCB1c2luZyBTdXBhYmFzZSBBdXRoXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGVtYWlsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIHtcbiAgICAgICAgICByZWRpcmVjdFRvOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hY2NlcHQtaW52aXRhdGlvbj90b2tlbj0ke2ludml0YXRpb24uaWR9YCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByb2xlOiBpbnZpdGF0aW9uRGF0YS5yb2xlLFxuICAgICAgICAgICAgcm9sZV9sZXZlbDogaW52aXRhdGlvbkRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICAgIHRlbmFudF9pZDogaW52aXRhdGlvbkRhdGEudGVuYW50X2lkLFxuICAgICAgICAgICAgaW52aXRhdGlvbl9pZDogaW52aXRhdGlvbi5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZW1haWxFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzZW5kIGludml0YXRpb24gZW1haWwgdG8gJHtlbWFpbH06YCwgZW1haWxFcnJvcilcbiAgICAgICAgICAvLyBNYXJrIGludml0YXRpb24gYXMgZmFpbGVkXG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAgIC51cGRhdGUoeyBzdGF0dXM6ICdmYWlsZWQnIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbi5pZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZpdGF0aW9ucy5wdXNoKGludml0YXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgICBkYXRhOiB7IFxuICAgICAgICAgIHNlbnQ6IGludml0YXRpb25zLmxlbmd0aCwgXG4gICAgICAgICAgdG90YWw6IGludml0YXRpb25EYXRhLmVtYWlscy5sZW5ndGggXG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc2VuZCBpbnZpdGF0aW9ucycgfVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgdXNlciBpbmZvcm1hdGlvblxuICB1cGRhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFVzZXJVcGRhdGVEYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIC4uLnVwZGF0ZURhdGEsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBSZXNldCB1c2VyIHBhc3N3b3JkXG4gIHJlc2V0VXNlclBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZywgbmV3UGFzc3dvcmQ/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5ld1Bhc3N3b3JkKSB7XG4gICAgICAgIC8vIERpcmVjdCBwYXNzd29yZCByZXNldCAoYWRtaW4gZnVuY3Rpb24pXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4udXBkYXRlVXNlckJ5SWQoXG4gICAgICAgICAgZW1haWwsIC8vIFRoaXMgc2hvdWxkIGJlIHVzZXIgSUQsIGJ1dCB3ZSdsbCBuZWVkIHRvIGdldCBpdCBmaXJzdFxuICAgICAgICAgIHsgcGFzc3dvcmQ6IG5ld1Bhc3N3b3JkIH1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtYWlsLWJhc2VkIHBhc3N3b3JkIHJlc2V0XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVzZXRQYXNzd29yZEZvckVtYWlsKGVtYWlsLCB7XG4gICAgICAgICAgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vcmVzZXQtcGFzc3dvcmRgXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHJlc2V0IHBhc3N3b3JkJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFByZXZpZXcgY2xlYW51cCBvcGVyYXRpb25zXG4gIHByZXZpZXdVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpbmFjdGl2ZVVzZXJzID0gMFxuICAgICAgbGV0IHVuY29uZmlybWVkVXNlcnMgPSAwXG4gICAgICBsZXQgZXhwaXJlZEludml0ZXMgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmx0KCdsYXN0X2xvZ2luJywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaW5hY3RpdmVVc2VycyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlVW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMudW5jb25maXJtZWREYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdhdXRoLnVzZXJzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5pcygnZW1haWxfY29uZmlybWVkX2F0JywgbnVsbClcbiAgICAgICAgICAubHQoJ2NyZWF0ZWRfYXQnLCBjdXRvZmZEYXRlKVxuXG4gICAgICAgIHVuY29uZmlybWVkVXNlcnMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUV4cGlyZWRJbnZpdGVzKSB7XG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgICAgIC5uZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG5cbiAgICAgICAgZXhwaXJlZEludml0ZXMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsVG9EZWxldGUgPSBpbmFjdGl2ZVVzZXJzICsgdW5jb25maXJtZWRVc2VycyArIGV4cGlyZWRJbnZpdGVzXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmFjdGl2ZVVzZXJzLFxuICAgICAgICAgIHVuY29uZmlybWVkVXNlcnMsXG4gICAgICAgICAgZXhwaXJlZEludml0ZXMsXG4gICAgICAgICAgdG90YWxUb0RlbGV0ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJldmlldyBjbGVhbnVwJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEV4ZWN1dGUgY2xlYW51cCBvcGVyYXRpb25zXG4gIGV4ZWN1dGVVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZWxldGVkQ291bnQgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBpbmFjdGl2ZSB1c2Vyc1xuICAgICAgICBjb25zdCB7IGRhdGE6IGluYWN0aXZlVXNlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgLmx0KCdsYXN0X2xvZ2luJywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaWYgKGluYWN0aXZlVXNlcnMgJiYgaW5hY3RpdmVVc2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gRGVsZXRlIGZyb20gYXV0aFxuICAgICAgICAgIGZvciAoY29uc3QgdXNlciBvZiBpbmFjdGl2ZVVzZXJzKSB7XG4gICAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLmRlbGV0ZVVzZXIodXNlci5pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlZENvdW50ICs9IGluYWN0aXZlVXNlcnMubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlVW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMudW5jb25maXJtZWREYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBcbiAgICAgICAgLy8gVGhpcyB3b3VsZCByZXF1aXJlIGFkbWluIGFjY2VzcyB0byBhdXRoLnVzZXJzIHRhYmxlXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgcmV0dXJuIHN1Y2Nlc3NcbiAgICAgICAgY29uc29sZS5sb2coJ1VuY29uZmlybWVkIHVzZXJzIGNsZWFudXAgd291bGQgYmUgZXhlY3V0ZWQgaGVyZScpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUV4cGlyZWRJbnZpdGVzKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5sdCgnZXhwaXJlc19hdCcsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgICAgICAubmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgZXhwaXJlZCBpbnZpdGVzOicsIGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHsgZGVsZXRlZENvdW50IH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBleGVjdXRlIGNsZWFudXAnIH1cbiAgICB9XG4gIH1cbn1cblxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4iLCJzdXBhYmFzZSIsInNpZ25JbldpdGhSb2xlIiwiZW1haWwiLCJwYXNzd29yZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJ1c2VyIiwicHJvZmlsZSIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwic2lnbk91dCIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlciIsInVzZXJNYW5hZ2VtZW50IiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwiYXV0aERhdGEiLCJhdXRoRXJyb3IiLCJhZG1pbiIsImVtYWlsX2NvbmZpcm0iLCJ1c2VyX21ldGFkYXRhIiwiZnVsbF9uYW1lIiwicm9sZSIsInJvbGVfbGV2ZWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsInByb2ZpbGVFcnJvciIsImluc2VydCIsInBob25lIiwiZGVwYXJ0bWVudCIsImpvYl90aXRsZSIsInRlbmFudF9pZCIsImlzX2FjdGl2ZSIsImNhbl9pbnZpdGVfdXNlcnMiLCJjYW5fbWFuYWdlX3N1Yl9jbGllbnRzIiwicGVybWlzc2lvbl9zY29wZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlVXNlciIsInRlbmFudFVzZXJFcnJvciIsInVzZXJfaWQiLCJkZWxldGUiLCJpbnZpdGVVc2VycyIsImludml0YXRpb25EYXRhIiwiaW52aXRhdGlvbnMiLCJlbWFpbHMiLCJpbnZpdGF0aW9uIiwiaW52aXRlRXJyb3IiLCJleHBpcmVzX2F0Iiwibm93IiwiZXhwaXJlc19pbl9kYXlzIiwiY29uc29sZSIsImVtYWlsRXJyb3IiLCJpbnZpdGVVc2VyQnlFbWFpbCIsInJlZGlyZWN0VG8iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImludml0YXRpb25faWQiLCJ1cGRhdGUiLCJzdGF0dXMiLCJwdXNoIiwic2VudCIsImxlbmd0aCIsInRvdGFsIiwidXBkYXRlVXNlciIsInVzZXJJZCIsInVwZGF0ZURhdGEiLCJyZXNldFVzZXJQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwidXBkYXRlVXNlckJ5SWQiLCJyZXNldFBhc3N3b3JkRm9yRW1haWwiLCJwcmV2aWV3VXNlckNsZWFudXAiLCJvcHRpb25zIiwiaW5hY3RpdmVVc2VycyIsInVuY29uZmlybWVkVXNlcnMiLCJleHBpcmVkSW52aXRlcyIsImRlbGV0ZUluYWN0aXZlVXNlcnMiLCJjdXRvZmZEYXRlIiwiaW5hY3RpdmVEYXlzIiwiY291bnQiLCJoZWFkIiwibHQiLCJkZWxldGVVbmNvbmZpcm1lZFVzZXJzIiwidW5jb25maXJtZWREYXlzIiwiaXMiLCJkZWxldGVFeHBpcmVkSW52aXRlcyIsIm5lcSIsInRvdGFsVG9EZWxldGUiLCJleGVjdXRlVXNlckNsZWFudXAiLCJkZWxldGVkQ291bnQiLCJsb2ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});