"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/mock-supabase.ts":
/*!**********************************!*\
  !*** ./src/lib/mock-supabase.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mockSupabase: () => (/* binding */ mockSupabase),\n/* harmony export */   shouldUseMockData: () => (/* binding */ shouldUseMockData)\n/* harmony export */ });\n// Mock Supabase client for testing when real credentials are not available\n// Mock data\nconst mockTenants = [\n    {\n        id: '99883779-9517-4ca9-a3f8-7fdc59051f0e',\n        name: 'Demo Company',\n        company_name: 'Demo Company',\n        status: 'active',\n        subscription_plan: 'professional',\n        created_at: '2024-01-01T00:00:00Z'\n    }\n];\nconst mockUsers = [\n    {\n        id: '3c1028ec-3b29-4a12-a881-f153ebf9406f',\n        email: 'demo@company.com',\n        full_name: 'Demo User',\n        role: 'host_admin',\n        role_level: 'senior',\n        tenant_id: '99883779-9517-4ca9-a3f8-7fdc59051f0e',\n        is_active: true,\n        can_invite_users: true,\n        can_manage_sub_clients: true,\n        permission_scope: 'all',\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T00:00:00Z'\n    },\n    {\n        id: '4d1028ec-3b29-4a12-a881-f153ebf9407f',\n        email: 'user1@company.com',\n        full_name: 'Test User 1',\n        role: 'client_admin',\n        role_level: 'mid',\n        tenant_id: '99883779-9517-4ca9-a3f8-7fdc59051f0e',\n        is_active: true,\n        can_invite_users: false,\n        can_manage_sub_clients: false,\n        permission_scope: 'own',\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T00:00:00Z'\n    },\n    {\n        id: '5e1028ec-3b29-4a12-a881-f153ebf9408f',\n        email: 'user2@company.com',\n        full_name: 'Test User 2',\n        role: 'client_user',\n        role_level: 'junior',\n        tenant_id: '99883779-9517-4ca9-a3f8-7fdc59051f0e',\n        is_active: true,\n        can_invite_users: false,\n        can_manage_sub_clients: false,\n        permission_scope: 'own',\n        created_at: '2024-01-01T00:00:00Z',\n        updated_at: '2024-01-01T00:00:00Z'\n    }\n];\nconst mockTenantUsers = mockUsers.map((user)=>({\n        user_id: user.id,\n        tenant_id: user.tenant_id,\n        role: user.role,\n        role_level: user.role_level,\n        is_active: user.is_active,\n        can_invite_users: user.can_invite_users,\n        can_manage_sub_clients: user.can_manage_sub_clients,\n        permission_scope: user.permission_scope,\n        profiles: {\n            id: user.id,\n            email: user.email,\n            full_name: user.full_name\n        }\n    }));\nconst mockInvitations = [\n    {\n        id: '1a1028ec-3b29-4a12-a881-f153ebf9401f',\n        email: 'pending@company.com',\n        full_name: 'Pending User',\n        role: 'client_user',\n        role_level: 'junior',\n        tenant_id: '99883779-9517-4ca9-a3f8-7fdc59051f0e',\n        status: 'pending',\n        expires_at: '2024-12-31T23:59:59Z',\n        created_at: '2024-01-01T00:00:00Z'\n    }\n];\nconst mockNotifications = [\n    {\n        id: '2b1028ec-3b29-4a12-a881-f153ebf9402f',\n        type: 'new_user',\n        title: 'New User Requires Assignment',\n        message: 'A new user has signed up and requires tenant assignment.',\n        is_read: false,\n        created_at: '2024-01-01T00:00:00Z'\n    }\n];\n// Mock query builder\nclass MockQueryBuilder {\n    select() {\n        let fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '*';\n        this.selectFields = fields;\n        return this;\n    }\n    eq(field, value) {\n        this.whereConditions.push({\n            field,\n            operator: 'eq',\n            value\n        });\n        return this;\n    }\n    neq(field, value) {\n        this.whereConditions.push({\n            field,\n            operator: 'neq',\n            value\n        });\n        return this;\n    }\n    or(condition) {\n        // Simple mock implementation\n        return this;\n    }\n    order(field) {\n        this.orderByField = field;\n        return this;\n    }\n    limit(count) {\n        this.limitValue = count;\n        return this;\n    }\n    range(start, end) {\n        this.rangeStart = start;\n        this.rangeEnd = end;\n        return this;\n    }\n    single() {\n        return this.execute().then((result)=>{\n            var _result_data;\n            return {\n                ...result,\n                data: ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data[0]) || null\n            };\n        });\n    }\n    async execute() {\n        // Simulate network delay\n        await new Promise((resolve)=>setTimeout(resolve, 100));\n        let data = [];\n        switch(this.tableName){\n            case 'tenants':\n                data = [\n                    ...mockTenants\n                ];\n                break;\n            case 'tenant_users':\n                data = [\n                    ...mockTenantUsers\n                ];\n                break;\n            case 'profiles':\n                data = [\n                    ...mockUsers\n                ];\n                break;\n            case 'user_invitations':\n                data = [\n                    ...mockInvitations\n                ];\n                break;\n            case 'admin_notifications':\n                data = [\n                    ...mockNotifications\n                ];\n                break;\n            default:\n                data = [];\n        }\n        // Apply where conditions\n        data = data.filter((item)=>{\n            return this.whereConditions.every((condition)=>{\n                const fieldValue = this.getNestedValue(item, condition.field);\n                switch(condition.operator){\n                    case 'eq':\n                        return fieldValue === condition.value;\n                    case 'neq':\n                        return fieldValue !== condition.value;\n                    default:\n                        return true;\n                }\n            });\n        });\n        // Apply range\n        const rangedData = data.slice(this.rangeStart, this.rangeEnd + 1);\n        return {\n            data: rangedData,\n            error: null,\n            count: data.length\n        };\n    }\n    getNestedValue(obj, path) {\n        return path.split('.').reduce((current, key)=>current === null || current === void 0 ? void 0 : current[key], obj);\n    }\n    // Make the query builder thenable so it can be awaited\n    then(onFulfilled, onRejected) {\n        return this.execute().then(onFulfilled, onRejected);\n    }\n    constructor(tableName){\n        this.selectFields = '*';\n        this.whereConditions = [];\n        this.orderByField = '';\n        this.limitValue = 1000;\n        this.rangeStart = 0;\n        this.rangeEnd = 1000;\n        this.tableName = tableName;\n    }\n}\n// Mock Supabase client\nconst mockSupabase = {\n    from: (tableName)=>new MockQueryBuilder(tableName),\n    auth: {\n        getUser: async ()=>({\n                data: {\n                    user: {\n                        id: '3c1028ec-3b29-4a12-a881-f153ebf9406f',\n                        email: 'demo@company.com'\n                    }\n                },\n                error: null\n            }),\n        signInWithPassword: async (param)=>{\n            let { email, password } = param;\n            return {\n                data: {\n                    user: {\n                        id: '3c1028ec-3b29-4a12-a881-f153ebf9406f',\n                        email: 'demo@company.com'\n                    }\n                },\n                error: null\n            };\n        },\n        signOut: async ()=>({\n                error: null\n            }),\n        admin: {\n            createUser: async (userData)=>({\n                    data: {\n                        user: {\n                            id: \"new-\".concat(Date.now()),\n                            email: userData.email\n                        }\n                    },\n                    error: null\n                }),\n            deleteUser: async (userId)=>({\n                    error: null\n                }),\n            updateUserById: async (userId, updates)=>({\n                    error: null\n                }),\n            inviteUserByEmail: async (email, options)=>({\n                    error: null\n                })\n        },\n        resetPasswordForEmail: async (email, options)=>({\n                error: null\n            })\n    }\n};\n// Check if we should use mock data\nconst shouldUseMockData = ()=>{\n    const supabaseUrl = \"https://your-project.supabase.co\";\n    return !supabaseUrl || supabaseUrl.includes('your-project.supabase.co') || supabaseUrl === 'https://your-project.supabase.co';\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbW9jay1zdXBhYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJFQUEyRTtBQVczRSxZQUFZO0FBQ1osTUFBTUEsY0FBYztJQUNsQjtRQUNFQyxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsY0FBYztRQUNkQyxRQUFRO1FBQ1JDLG1CQUFtQjtRQUNuQkMsWUFBWTtJQUNkO0NBQ0Q7QUFFRCxNQUFNQyxZQUFZO0lBQ2hCO1FBQ0VOLElBQUk7UUFDSk8sT0FBTztRQUNQQyxXQUFXO1FBQ1hDLE1BQU07UUFDTkMsWUFBWTtRQUNaQyxXQUFXO1FBQ1hDLFdBQVc7UUFDWEMsa0JBQWtCO1FBQ2xCQyx3QkFBd0I7UUFDeEJDLGtCQUFrQjtRQUNsQlYsWUFBWTtRQUNaVyxZQUFZO0lBQ2Q7SUFDQTtRQUNFaEIsSUFBSTtRQUNKTyxPQUFPO1FBQ1BDLFdBQVc7UUFDWEMsTUFBTTtRQUNOQyxZQUFZO1FBQ1pDLFdBQVc7UUFDWEMsV0FBVztRQUNYQyxrQkFBa0I7UUFDbEJDLHdCQUF3QjtRQUN4QkMsa0JBQWtCO1FBQ2xCVixZQUFZO1FBQ1pXLFlBQVk7SUFDZDtJQUNBO1FBQ0VoQixJQUFJO1FBQ0pPLE9BQU87UUFDUEMsV0FBVztRQUNYQyxNQUFNO1FBQ05DLFlBQVk7UUFDWkMsV0FBVztRQUNYQyxXQUFXO1FBQ1hDLGtCQUFrQjtRQUNsQkMsd0JBQXdCO1FBQ3hCQyxrQkFBa0I7UUFDbEJWLFlBQVk7UUFDWlcsWUFBWTtJQUNkO0NBQ0Q7QUFFRCxNQUFNQyxrQkFBa0JYLFVBQVVZLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUztRQUM3Q0MsU0FBU0QsS0FBS25CLEVBQUU7UUFDaEJXLFdBQVdRLEtBQUtSLFNBQVM7UUFDekJGLE1BQU1VLEtBQUtWLElBQUk7UUFDZkMsWUFBWVMsS0FBS1QsVUFBVTtRQUMzQkUsV0FBV08sS0FBS1AsU0FBUztRQUN6QkMsa0JBQWtCTSxLQUFLTixnQkFBZ0I7UUFDdkNDLHdCQUF3QkssS0FB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QUNKbkIsSUFBSTt3QkFDSk8sT0FBTztvQkFDVDtnQkFDRjtnQkFDQTZELE9BQU87WUFDVDs7UUFFQWlCLFNBQVMsVUFBYTtnQkFBRWpCLE9BQU87WUFBSztRQUVwQ2tCLE9BQU87WUFDTEMsWUFBWSxPQUFPQyxXQUFtQjtvQkFDcENoQyxNQUFNO3dCQUNKckMsTUFBTTs0QkFDSm5CLElBQUksT0FBa0IsT0FBWHlGLEtBQUtDLEdBQUc7NEJBQ25CbkYsT0FBT2lGLFNBQVNqRixLQUFLO3dCQUN2QjtvQkFDRjtvQkFDQTZELE9BQU87Z0JBQ1Q7WUFFQXVCLFlBQVksT0FBT0MsU0FBb0I7b0JBQUV4QixPQUFPO2dCQUFLO1lBRXJEeUIsZ0JBQWdCLE9BQU9ELFFBQWdCRSxVQUFrQjtvQkFBRTFCLE9BQU87Z0JBQUs7WUFFdkUyQixtQkFBbUIsT0FBT3hGLE9BQWV5RixVQUFrQjtvQkFBRTVCLE9BQU87Z0JBQUs7UUFDM0U7UUFFQTZCLHVCQUF1QixPQUFPMUYsT0FBZXlGLFVBQWtCO2dCQUFFNUIsT0FBTztZQUFLO0lBQy9FO0FBQ0YsRUFBQztBQUVELG1DQUFtQztBQUM1QixNQUFNOEIsb0JBQW9CO0lBQy9CLE1BQU1DLGNBQWNDLGtDQUFvQztJQUN4RCxPQUFPLENBQUNELGVBQWVBLFlBQVlJLFFBQVEsQ0FBQywrQkFBK0JKLGdCQUFnQjtBQUM3RixFQUFDIiwic291cmNlcyI6WyIvaG9tZS91YnVudHUvRVRMQS1QbGF0Zm9ybS9mcm9udGVuZC9zcmMvbGliL21vY2stc3VwYWJhc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTW9jayBTdXBhYmFzZSBjbGllbnQgZm9yIHRlc3Rpbmcgd2hlbiByZWFsIGNyZWRlbnRpYWxzIGFyZSBub3QgYXZhaWxhYmxlXG5pbXBvcnQgeyBcbiAgUkJBQ01hdHJpeFJvd1VzZXIsIFxuICBSQkFDUGVybWlzc2lvbkNhdGFsb2csIFxuICBSQkFDUGVybWlzc2lvbkNlbGwsIFxuICBSQkFDVXNlckRldGFpbCxcbiAgUkJBQ0FwcGx5Q2hhbmdlc1JlcXVlc3QsXG4gIFRlbmFudCxcbiAgVXNlclxufSBmcm9tICdAL3R5cGVzJ1xuXG4vLyBNb2NrIGRhdGFcbmNvbnN0IG1vY2tUZW5hbnRzID0gW1xuICB7XG4gICAgaWQ6ICc5OTg4Mzc3OS05NTE3LTRjYTktYTNmOC03ZmRjNTkwNTFmMGUnLFxuICAgIG5hbWU6ICdEZW1vIENvbXBhbnknLFxuICAgIGNvbXBhbnlfbmFtZTogJ0RlbW8gQ29tcGFueScsXG4gICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICBzdWJzY3JpcHRpb25fcGxhbjogJ3Byb2Zlc3Npb25hbCcsXG4gICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJ1xuICB9XG5dXG5cbmNvbnN0IG1vY2tVc2VycyA9IFtcbiAge1xuICAgIGlkOiAnM2MxMDI4ZWMtM2IyOS00YTEyLWE4ODEtZjE1M2ViZjk0MDZmJyxcbiAgICBlbWFpbDogJ2RlbW9AY29tcGFueS5jb20nLFxuICAgIGZ1bGxfbmFtZTogJ0RlbW8gVXNlcicsXG4gICAgcm9sZTogJ2hvc3RfYWRtaW4nLFxuICAgIHJvbGVfbGV2ZWw6ICdzZW5pb3InLFxuICAgIHRlbmFudF9pZDogJzk5ODgzNzc5LTk1MTctNGNhOS1hM2Y4LTdmZGM1OTA1MWYwZScsXG4gICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgIGNhbl9pbnZpdGVfdXNlcnM6IHRydWUsXG4gICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogdHJ1ZSxcbiAgICBwZXJtaXNzaW9uX3Njb3BlOiAnYWxsJyxcbiAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWidcbiAgfSxcbiAge1xuICAgIGlkOiAnNGQxMDI4ZWMtM2IyOS00YTEyLWE4ODEtZjE1M2ViZjk0MDdmJyxcbiAgICBlbWFpbDogJ3VzZXIxQGNvbXBhbnkuY29tJyxcbiAgICBmdWxsX25hbWU6ICdUZXN0IFVzZXIgMScsXG4gICAgcm9sZTogJ2NsaWVudF9hZG1pbicsXG4gICAgcm9sZV9sZXZlbDogJ21pZCcsXG4gICAgdGVuYW50X2lkOiAnOTk4ODM3NzktOTUxNy00Y2E5LWEzZjgtN2ZkYzU5MDUxZjBlJyxcbiAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgY2FuX2ludml0ZV91c2VyczogZmFsc2UsXG4gICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogZmFsc2UsXG4gICAgcGVybWlzc2lvbl9zY29wZTogJ293bicsXG4gICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonXG4gIH0sXG4gIHtcbiAgICBpZDogJzVlMTAyOGVjLTNiMjktNGExMi1hODgxLWYxNTNlYmY5NDA4ZicsXG4gICAgZW1haWw6ICd1c2VyMkBjb21wYW55LmNvbScsXG4gICAgZnVsbF9uYW1lOiAnVGVzdCBVc2VyIDInLFxuICAgIHJvbGU6ICdjbGllbnRfdXNlcicsXG4gICAgcm9sZV9sZXZlbDogJ2p1bmlvcicsXG4gICAgdGVuYW50X2lkOiAnOTk4ODM3NzktOTUxNy00Y2E5LWEzZjgtN2ZkYzU5MDUxZjBlJyxcbiAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgY2FuX2ludml0ZV91c2VyczogZmFsc2UsXG4gICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogZmFsc2UsXG4gICAgcGVybWlzc2lvbl9zY29wZTogJ293bicsXG4gICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonXG4gIH1cbl1cblxuY29uc3QgbW9ja1RlbmFudFVzZXJzID0gbW9ja1VzZXJzLm1hcCh1c2VyID0+ICh7XG4gIHVzZXJfaWQ6IHVzZXIuaWQsXG4gIHRlbmFudF9pZDogdXNlci50ZW5hbnRfaWQsXG4gIHJvbGU6IHVzZXIucm9sZSxcbiAgcm9sZV9sZXZlbDogdXNlci5yb2xlX2xldmVsLFxuICBpc19hY3RpdmU6IHVzZXIuaXNfYWN0aXZlLFxuICBjYW5faW52aXRlX3VzZXJzOiB1c2VyLmNhbl9pbnZpdGVfdXNlcnMsXG4gIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IHVzZXIuY2FuX21hbmFnZV9zdWJfY2xpZW50cyxcbiAgcGVybWlzc2lvbl9zY29wZTogdXNlci5wZXJtaXNzaW9uX3Njb3BlLFxuICBwcm9maWxlczoge1xuICAgIGlkOiB1c2VyLmlkLFxuICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgIGZ1bGxfbmFtZTogdXNlci5mdWxsX25hbWVcbiAgfVxufSkpXG5cbmNvbnN0IG1vY2tJbnZpdGF0aW9ucyA9IFtcbiAge1xuICAgIGlkOiAnMWExMDI4ZWMtM2IyOS00YTEyLWE4ODEtZjE1M2ViZjk0MDFmJyxcbiAgICBlbWFpbDogJ3BlbmRpbmdAY29tcGFueS5jb20nLFxuICAgIGZ1bGxfbmFtZTogJ1BlbmRpbmcgVXNlcicsXG4gICAgcm9sZTogJ2NsaWVudF91c2VyJyxcbiAgICByb2xlX2xldmVsOiAnanVuaW9yJyxcbiAgICB0ZW5hbnRfaWQ6ICc5OTg4Mzc3OS05NTE3LTRjYTktYTNmOC03ZmRjNTkwNTFmMGUnLFxuICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgIGV4cGlyZXNfYXQ6ICcyMDI0LTEyLTMxVDIzOjU5OjU5WicsXG4gICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJ1xuICB9XG5dXG5cbmNvbnN0IG1vY2tOb3RpZmljYXRpb25zID0gW1xuICB7XG4gICAgaWQ6ICcyYjEwMjhlYy0zYjI5LTRhMTItYTg4MS1mMTUzZWJmOTQwMmYnLFxuICAgIHR5cGU6ICduZXdfdXNlcicsXG4gICAgdGl0bGU6ICdOZXcgVXNlciBSZXF1aXJlcyBBc3NpZ25tZW50JyxcbiAgICBtZXNzYWdlOiAnQSBuZXcgdXNlciBoYXMgc2lnbmVkIHVwIGFuZCByZXF1aXJlcyB0ZW5hbnQgYXNzaWdubWVudC4nLFxuICAgIGlzX3JlYWQ6IGZhbHNlLFxuICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWidcbiAgfVxuXVxuXG4vLyBNb2NrIHF1ZXJ5IGJ1aWxkZXJcbmNsYXNzIE1vY2tRdWVyeUJ1aWxkZXIge1xuICBwcml2YXRlIHRhYmxlTmFtZTogc3RyaW5nXG4gIHByaXZhdGUgc2VsZWN0RmllbGRzOiBzdHJpbmcgPSAnKidcbiAgcHJpdmF0ZSB3aGVyZUNvbmRpdGlvbnM6IGFueVtdID0gW11cbiAgcHJpdmF0ZSBvcmRlckJ5RmllbGQ6IHN0cmluZyA9ICcnXG4gIHByaXZhdGUgbGltaXRWYWx1ZTogbnVtYmVyID0gMTAwMFxuICBwcml2YXRlIHJhbmdlU3RhcnQ6IG51bWJlciA9IDBcbiAgcHJpdmF0ZSByYW5nZUVuZDogbnVtYmVyID0gMTAwMFxuXG4gIGNvbnN0cnVjdG9yKHRhYmxlTmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWVcbiAgfVxuXG4gIHNlbGVjdChmaWVsZHM6IHN0cmluZyA9ICcqJykge1xuICAgIHRoaXMuc2VsZWN0RmllbGRzID0gZmllbGRzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVxKGZpZWxkOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLndoZXJlQ29uZGl0aW9ucy5wdXNoKHsgZmllbGQsIG9wZXJhdG9yOiAnZXEnLCB2YWx1ZSB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBuZXEoZmllbGQ6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIHRoaXMud2hlcmVDb25kaXRpb25zLnB1c2goeyBmaWVsZCwgb3BlcmF0b3I6ICduZXEnLCB2YWx1ZSB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcihjb25kaXRpb246IHN0cmluZykge1xuICAgIC8vIFNpbXBsZSBtb2NrIGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9yZGVyKGZpZWxkOiBzdHJpbmcpIHtcbiAgICB0aGlzLm9yZGVyQnlGaWVsZCA9IGZpZWxkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxpbWl0KGNvdW50OiBudW1iZXIpIHtcbiAgICB0aGlzLmxpbWl0VmFsdWUgPSBjb3VudFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIHRoaXMucmFuZ2VTdGFydCA9IHN0YXJ0XG4gICAgdGhpcy5yYW5nZUVuZCA9IGVuZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzaW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZSgpLnRoZW4ocmVzdWx0ID0+ICh7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YT8uWzBdIHx8IG51bGxcbiAgICB9KSlcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoKTogUHJvbWlzZTx7IGRhdGE6IGFueVtdIHwgbnVsbDsgZXJyb3I6IGFueTsgY291bnQ/OiBudW1iZXIgfT4ge1xuICAgIC8vIFNpbXVsYXRlIG5ldHdvcmsgZGVsYXlcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcblxuICAgIGxldCBkYXRhOiBhbnlbXSA9IFtdXG5cbiAgICBzd2l0Y2ggKHRoaXMudGFibGVOYW1lKSB7XG4gICAgICBjYXNlICd0ZW5hbnRzJzpcbiAgICAgICAgZGF0YSA9IFsuLi5tb2NrVGVuYW50c11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3RlbmFudF91c2Vycyc6XG4gICAgICAgIGRhdGEgPSBbLi4ubW9ja1RlbmFudFVzZXJzXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJvZmlsZXMnOlxuICAgICAgICBkYXRhID0gWy4uLm1vY2tVc2Vyc11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3VzZXJfaW52aXRhdGlvbnMnOlxuICAgICAgICBkYXRhID0gWy4uLm1vY2tJbnZpdGF0aW9uc11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2FkbWluX25vdGlmaWNhdGlvbnMnOlxuICAgICAgICBkYXRhID0gWy4uLm1vY2tOb3RpZmljYXRpb25zXVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGF0YSA9IFtdXG4gICAgfVxuXG4gICAgLy8gQXBwbHkgd2hlcmUgY29uZGl0aW9uc1xuICAgIGRhdGEgPSBkYXRhLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlQ29uZGl0aW9ucy5ldmVyeShjb25kaXRpb24gPT4ge1xuICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdGhpcy5nZXROZXN0ZWRWYWx1ZShpdGVtLCBjb25kaXRpb24uZmllbGQpXG4gICAgICAgIHN3aXRjaCAoY29uZGl0aW9uLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSAnZXEnOlxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUgPT09IGNvbmRpdGlvbi52YWx1ZVxuICAgICAgICAgIGNhc2UgJ25lcSc6XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZSAhPT0gY29uZGl0aW9uLnZhbHVlXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIEFwcGx5IHJhbmdlXG4gICAgY29uc3QgcmFuZ2VkRGF0YSA9IGRhdGEuc2xpY2UodGhpcy5yYW5nZVN0YXJ0LCB0aGlzLnJhbmdlRW5kICsgMSlcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiByYW5nZWREYXRhLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBjb3VudDogZGF0YS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE5lc3RlZFZhbHVlKG9iajogYW55LCBwYXRoOiBzdHJpbmcpOiBhbnkge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KCcuJykucmVkdWNlKChjdXJyZW50LCBrZXkpID0+IGN1cnJlbnQ/LltrZXldLCBvYmopXG4gIH1cblxuICAvLyBNYWtlIHRoZSBxdWVyeSBidWlsZGVyIHRoZW5hYmxlIHNvIGl0IGNhbiBiZSBhd2FpdGVkXG4gIHRoZW4ob25GdWxmaWxsZWQ/OiBhbnksIG9uUmVqZWN0ZWQ/OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgfVxufVxuXG4vLyBNb2NrIFN1cGFiYXNlIGNsaWVudFxuZXhwb3J0IGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcbiAgZnJvbTogKHRhYmxlTmFtZTogc3RyaW5nKSA9PiBuZXcgTW9ja1F1ZXJ5QnVpbGRlcih0YWJsZU5hbWUpLFxuICBcbiAgYXV0aDoge1xuICAgIGdldFVzZXI6IGFzeW5jICgpID0+ICh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJzNjMTAyOGVjLTNiMjktNGExMi1hODgxLWYxNTNlYmY5NDA2ZicsXG4gICAgICAgICAgZW1haWw6ICdkZW1vQGNvbXBhbnkuY29tJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KSxcbiAgICBcbiAgICBzaWduSW5XaXRoUGFzc3dvcmQ6IGFzeW5jICh7IGVtYWlsLCBwYXNzd29yZCB9OiB7IGVtYWlsOiBzdHJpbmc7IHBhc3N3b3JkOiBzdHJpbmcgfSkgPT4gKHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgIGlkOiAnM2MxMDI4ZWMtM2IyOS00YTEyLWE4ODEtZjE1M2ViZjk0MDZmJyxcbiAgICAgICAgICBlbWFpbDogJ2RlbW9AY29tcGFueS5jb20nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pLFxuICAgIFxuICAgIHNpZ25PdXQ6IGFzeW5jICgpID0+ICh7IGVycm9yOiBudWxsIH0pLFxuICAgIFxuICAgIGFkbWluOiB7XG4gICAgICBjcmVhdGVVc2VyOiBhc3luYyAodXNlckRhdGE6IGFueSkgPT4gKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgIGlkOiBgbmV3LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSksXG4gICAgICBcbiAgICAgIGRlbGV0ZVVzZXI6IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4gKHsgZXJyb3I6IG51bGwgfSksXG4gICAgICBcbiAgICAgIHVwZGF0ZVVzZXJCeUlkOiBhc3luYyAodXNlcklkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4gKHsgZXJyb3I6IG51bGwgfSksXG4gICAgICBcbiAgICAgIGludml0ZVVzZXJCeUVtYWlsOiBhc3luYyAoZW1haWw6IHN0cmluZywgb3B0aW9uczogYW55KSA9PiAoeyBlcnJvcjogbnVsbCB9KVxuICAgIH0sXG4gICAgXG4gICAgcmVzZXRQYXNzd29yZEZvckVtYWlsOiBhc3luYyAoZW1haWw6IHN0cmluZywgb3B0aW9uczogYW55KSA9PiAoeyBlcnJvcjogbnVsbCB9KVxuICB9XG59XG5cbi8vIENoZWNrIGlmIHdlIHNob3VsZCB1c2UgbW9jayBkYXRhXG5leHBvcnQgY29uc3Qgc2hvdWxkVXNlTW9ja0RhdGEgPSAoKSA9PiB7XG4gIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMXG4gIHJldHVybiAhc3VwYWJhc2VVcmwgfHwgc3VwYWJhc2VVcmwuaW5jbHVkZXMoJ3lvdXItcHJvamVjdC5zdXBhYmFzZS5jbycpIHx8IHN1cGFiYXNlVXJsID09PSAnaHR0cHM6Ly95b3VyLXByb2plY3Quc3VwYWJhc2UuY28nXG59XG5cbiJdLCJuYW1lcyI6WyJtb2NrVGVuYW50cyIsImlkIiwibmFtZSIsImNvbXBhbnlfbmFtZSIsInN0YXR1cyIsInN1YnNjcmlwdGlvbl9wbGFuIiwiY3JlYXRlZF9hdCIsIm1vY2tVc2VycyIsImVtYWlsIiwiZnVsbF9uYW1lIiwicm9sZSIsInJvbGVfbGV2ZWwiLCJ0ZW5hbnRfaWQiLCJpc19hY3RpdmUiLCJjYW5faW52aXRlX3VzZXJzIiwiY2FuX21hbmFnZV9zdWJfY2xpZW50cyIsInBlcm1pc3Npb25fc2NvcGUiLCJ1cGRhdGVkX2F0IiwibW9ja1RlbmFudFVzZXJzIiwibWFwIiwidXNlciIsInVzZXJfaWQiLCJwcm9maWxlcyIsIm1vY2tJbnZpdGF0aW9ucyIsImV4cGlyZXNfYXQiLCJtb2NrTm90aWZpY2F0aW9ucyIsInR5cGUiLCJ0aXRsZSIsIm1lc3NhZ2UiLCJpc19yZWFkIiwiTW9ja1F1ZXJ5QnVpbGRlciIsInNlbGVjdCIsImZpZWxkcyIsInNlbGVjdEZpZWxkcyIsImVxIiwiZmllbGQiLCJ2YWx1ZSIsIndoZXJlQ29uZGl0aW9ucyIsInB1c2giLCJvcGVyYXRvciIsIm5lcSIsIm9yIiwiY29uZGl0aW9uIiwib3JkZXIiLCJvcmRlckJ5RmllbGQiLCJsaW1pdCIsImNvdW50IiwibGltaXRWYWx1ZSIsInJhbmdlIiwic3RhcnQiLCJlbmQiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJzaW5nbGUiLCJleGVjdXRlIiwidGhlbiIsInJlc3VsdCIsImRhdGEiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0YWJsZU5hbWUiLCJmaWx0ZXIiLCJpdGVtIiwiZXZlcnkiLCJmaWVsZFZhbHVlIiwiZ2V0TmVzdGVkVmFsdWUiLCJyYW5nZWREYXRhIiwic2xpY2UiLCJlcnJvciIsImxlbmd0aCIsIm9iaiIsInBhdGgiLCJzcGxpdCIsInJlZHVjZSIsImN1cnJlbnQiLCJrZXkiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJjb25zdHJ1Y3RvciIsIm1vY2tTdXBhYmFzZSIsImZyb20iLCJhdXRoIiwiZ2V0VXNlciIsInNpZ25JbldpdGhQYXNzd29yZCIsInBhc3N3b3JkIiwic2lnbk91dCIsImFkbWluIiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwiRGF0ZSIsIm5vdyIsImRlbGV0ZVVzZXIiLCJ1c2VySWQiLCJ1cGRhdGVVc2VyQnlJZCIsInVwZGF0ZXMiLCJpbnZpdGVVc2VyQnlFbWFpbCIsIm9wdGlvbnMiLCJyZXNldFBhc3N3b3JkRm9yRW1haWwiLCJzaG91bGRVc2VNb2NrRGF0YSIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsImluY2x1ZGVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/mock-supabase.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   mfaManagement: () => (/* binding */ mfaManagement),\n/* harmony export */   signInWithRole: () => (/* binding */ signInWithRole),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   userManagement: () => (/* binding */ userManagement)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _mock_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mock-supabase */ \"(app-pages-browser)/./src/lib/mock-supabase.ts\");\n// lib/supabase.ts\n\n\nconst supabaseUrl = \"https://your-project.supabase.co\";\nconst supabaseAnonKey = \"your_anon_token_here\";\n// Use mock data if Supabase is not properly configured\nconst realSupabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\nconst supabase = (0,_mock_supabase__WEBPACK_IMPORTED_MODULE_0__.shouldUseMockData)() ? _mock_supabase__WEBPACK_IMPORTED_MODULE_0__.mockSupabase : realSupabase;\n// Export createClient function for compatibility\nconst createClient = ()=>(0,_mock_supabase__WEBPACK_IMPORTED_MODULE_0__.shouldUseMockData)() ? _mock_supabase__WEBPACK_IMPORTED_MODULE_0__.mockSupabase : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n// Auth helpers\nconst signInWithRole = async (email, password)=>{\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (data.user) {\n        // Get user profile with role and tenant\n        const { data: profile } = await supabase.from('users').select('role, tenant_id, first_name, last_name').eq('id', data.user.id).single();\n        return {\n            user: data.user,\n            profile,\n            error\n        };\n    }\n    return {\n        user: null,\n        profile: null,\n        error\n    };\n};\nconst signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    return {\n        error\n    };\n};\n// Database helpers\nconst getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data: profile } = await supabase.from('users').select('*').eq('id', user.id).single();\n    return {\n        ...user,\n        profile\n    };\n};\n// User Management Methods\nconst userManagement = {\n    // Create a new user with complete RBAC setup\n    createUser: async (userData)=>{\n        try {\n            // First, create the auth user\n            const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n                email: userData.email,\n                password: userData.password,\n                email_confirm: true,\n                user_metadata: {\n                    full_name: userData.full_name,\n                    role: userData.role,\n                    role_level: userData.role_level\n                }\n            });\n            if (authError) {\n                return {\n                    success: false,\n                    error: authError.message\n                };\n            }\n            if (!authData.user) {\n                return {\n                    success: false,\n                    error: 'Failed to create user account'\n                };\n            }\n            // Create the user profile (FIXED: using 'profiles' not 'user_profiles')\n            const { error: profileError } = await supabase.from('profiles').insert({\n                id: authData.user.id,\n                email: userData.email,\n                full_name: userData.full_name,\n                phone: userData.phone,\n                department: userData.department,\n                job_title: userData.job_title,\n                role: userData.role,\n                role_level: userData.role_level,\n                tenant_id: userData.tenant_id,\n                is_active: true,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (profileError) {\n                // If profile creation fails, clean up the auth user\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                return {\n                    success: false,\n                    error: \"Profile creation failed: \".concat(profileError.message)\n                };\n            }\n            // NEW: Create tenant_users record for RBAC\n            const { error: tenantUserError } = await supabase.from('tenant_users').insert({\n                tenant_id: userData.tenant_id,\n                user_id: authData.user.id,\n                role: userData.role,\n                role_level: userData.role_level,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (tenantUserError) {\n                // If tenant_users creation fails, clean up auth user and profile\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                await supabase.from('profiles').delete().eq('id', authData.user.id);\n                return {\n                    success: false,\n                    error: \"Tenant assignment failed: \".concat(tenantUserError.message)\n                };\n            }\n            // OPTIONAL: Create audit log if table exists\n            try {\n                await supabase.from('audit_logs').insert({\n                    user_id: authData.user.id,\n                    tenant_id: userData.tenant_id,\n                    action: 'user_created',\n                    resource_type: 'user',\n                    resource_id: authData.user.id,\n                    details: {\n                        created_by: 'admin_interface',\n                        role: userData.role,\n                        role_level: userData.role_level,\n                        email: userData.email\n                    },\n                    ip_address: '127.0.0.1',\n                    user_agent: 'Admin Interface',\n                    severity: 'info',\n                    created_at: new Date().toISOString()\n                });\n            } catch (auditError) {\n                // Audit log is optional, don't fail the user creation\n                console.warn('Audit log creation failed:', auditError);\n            }\n            return {\n                success: true,\n                data: authData.user\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to create user'\n            };\n        }\n    },\n    // Invite users via email\n    inviteUsers: async (invitationData)=>{\n        try {\n            const invitations = [];\n            for (const email of invitationData.emails){\n                // Create invitation record\n                const { data: invitation, error: inviteError } = await supabase.from('user_invitations').insert({\n                    email,\n                    role: invitationData.role,\n                    role_level: invitationData.role_level,\n                    tenant_id: invitationData.tenant_id,\n                    message: invitationData.message,\n                    expires_at: new Date(Date.now() + invitationData.expires_in_days * 24 * 60 * 60 * 1000).toISOString(),\n                    created_at: new Date().toISOString()\n                }).select().single();\n                if (inviteError) {\n                    console.error(\"Failed to create invitation for \".concat(email, \":\"), inviteError);\n                    continue;\n                }\n                // Send invitation email using Supabase Auth\n                const { error: emailError } = await supabase.auth.admin.inviteUserByEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/accept-invitation?token=\").concat(invitation.id),\n                    data: {\n                        role: invitationData.role,\n                        role_level: invitationData.role_level,\n                        tenant_id: invitationData.tenant_id,\n                        invitation_id: invitation.id\n                    }\n                });\n                if (emailError) {\n                    console.error(\"Failed to send invitation email to \".concat(email, \":\"), emailError);\n                    // Mark invitation as failed\n                    await supabase.from('user_invitations').update({\n                        status: 'failed'\n                    }).eq('id', invitation.id);\n                } else {\n                    invitations.push(invitation);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    sent: invitations.length,\n                    total: invitationData.emails.length\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to send invitations'\n            };\n        }\n    },\n    // Update user information\n    updateUser: async (userId, updateData)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                ...updateData,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to update user'\n            };\n        }\n    },\n    // Deactivate user\n    deactivateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: false,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to deactivate user'\n            };\n        }\n    },\n    // Activate user\n    activateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: true,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to activate user'\n            };\n        }\n    },\n    // Reset user password\n    resetUserPassword: async (email, newPassword)=>{\n        try {\n            if (newPassword) {\n                // Direct password reset (admin function)\n                const { error } = await supabase.auth.admin.updateUserById(email, {\n                    password: newPassword\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            } else {\n                // Email-based password reset\n                const { error } = await supabase.auth.resetPasswordForEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/reset-password\")\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to reset password'\n            };\n        }\n    },\n    // Preview cleanup operations\n    previewUserCleanup: async (options)=>{\n        try {\n            let inactiveUsers = 0;\n            let unconfirmedUsers = 0;\n            let expiredInvites = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('profiles').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('last_login', cutoffDate).eq('is_active', true);\n                inactiveUsers = count || 0;\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('auth.users').select('*', {\n                    count: 'exact',\n                    head: true\n                }).is('email_confirmed_at', null).lt('created_at', cutoffDate);\n                unconfirmedUsers = count || 0;\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                expiredInvites = count || 0;\n            }\n            const totalToDelete = inactiveUsers + unconfirmedUsers + expiredInvites;\n            return {\n                success: true,\n                data: {\n                    inactiveUsers,\n                    unconfirmedUsers,\n                    expiredInvites,\n                    totalToDelete\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to preview cleanup'\n            };\n        }\n    },\n    // Execute cleanup operations\n    executeUserCleanup: async (options)=>{\n        try {\n            let deletedCount = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                // Get inactive users\n                const { data: inactiveUsers } = await supabase.from('profiles').select('id').lt('last_login', cutoffDate).eq('is_active', true);\n                if (inactiveUsers) {\n                    for (const user of inactiveUsers){\n                        // Delete auth user\n                        await supabase.auth.admin.deleteUser(user.id);\n                        // Delete profile\n                        await supabase.from('profiles').delete().eq('id', user.id);\n                    }\n                    deletedCount += inactiveUsers.length;\n                }\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                // This would require admin access to auth.users table\n                // For now, we'll mark them as inactive\n                const { data: unconfirmedUsers } = await supabase.from('profiles').select('id').lt('created_at', cutoffDate).eq('is_active', true);\n                if (unconfirmedUsers) {\n                    await supabase.from('profiles').update({\n                        is_active: false\n                    }).in('id', unconfirmedUsers.map((u)=>u.id));\n                    deletedCount += unconfirmedUsers.length;\n                }\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').delete().lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                deletedCount += count || 0;\n            }\n            return {\n                success: true,\n                data: {\n                    deletedCount\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to execute cleanup'\n            };\n        }\n    }\n};\nconst mfaManagement = {\n    // Check if user has MFA enabled\n    checkMFAStatus: async (userId)=>{\n        try {\n            const { data, error } = await supabase.from('profiles').select('mfa_enabled').eq('id', userId).single();\n            if (error) throw error;\n            return {\n                mfaEnabled: (data === null || data === void 0 ? void 0 : data.mfa_enabled) || false\n            };\n        } catch (error) {\n            console.error('Error checking MFA status:', error);\n            return {\n                mfaEnabled: false,\n                error: error.message\n            };\n        }\n    },\n    // Enable MFA for user\n    enableMFA: async ()=>{\n        try {\n            // Enroll for TOTP MFA\n            const { data, error } = await supabase.auth.mfa.enroll({\n                factorType: 'totp',\n                friendlyName: 'ETLA Platform TOTP'\n            });\n            if (error) throw error;\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error enabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify MFA setup\n    verifyMFASetup: async (factorId, code)=>{\n        try {\n            // Create challenge first\n            const { data: challenge, error: challengeError } = await supabase.auth.mfa.challenge({\n                factorId\n            });\n            if (challengeError) throw challengeError;\n            // Verify the code\n            const { data, error } = await supabase.auth.mfa.verify({\n                factorId,\n                challengeId: challenge.id,\n                code\n            });\n            if (error) throw error;\n            // Update user profile to indicate MFA is enabled\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: true,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error verifying MFA setup:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Disable MFA for user\n    disableMFA: async ()=>{\n        try {\n            // Get all factors\n            const { data: factors, error: factorsError } = await supabase.auth.mfa.listFactors();\n            if (factorsError) throw factorsError;\n            // Unenroll all TOTP factors\n            if (factors === null || factors === void 0 ? void 0 : factors.totp) {\n                for (const factor of factors.totp){\n                    await supabase.auth.mfa.unenroll({\n                        factorId: factor.id\n                    });\n                }\n            }\n            // Update user profile\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: false,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error('Error disabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Generate backup codes (simulated - in production this would be handled by your backend)\n    generateBackupCodes: async ()=>{\n        try {\n            // Generate 8 backup codes\n            const codes = Array.from({\n                length: 8\n            }, ()=>Math.random().toString(36).substring(2, 8).toUpperCase());\n            // In production, you would store these securely in your backend\n            // For now, we'll just return them\n            return {\n                success: true,\n                codes\n            };\n        } catch (error) {\n            console.error('Error generating backup codes:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify backup code (simulated - in production this would verify against stored codes)\n    verifyBackupCode: async (code)=>{\n        try {\n            // In production, you would verify this against stored backup codes\n            // For demo purposes, we'll accept any 6+ character code\n            if (code.length >= 6) {\n                return {\n                    success: true\n                };\n            } else {\n                throw new Error('Invalid backup code');\n            }\n        } catch (error) {\n            console.error('Error verifying backup code:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n};\n// Add user management methods to the main supabase object for backward compatibility\nObject.assign(supabase, userManagement);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBMEI7WUFDMUIsTUFBTUMsUUFBUUMsTUFBTWhJLElBQUksQ0FBQztnQkFBRXNFLFFBQVE7WUFBRSxHQUFHLElBQ3RDMkQsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsR0FBR0MsV0FBVztZQUd4RCxnRUFBZ0U7WUFDaEUsa0NBQWtDO1lBQ2xDLE9BQU87Z0JBQUVsSCxTQUFTO2dCQUFNNEc7WUFBTTtRQUNoQyxFQUFFLE9BQU9wSSxPQUFZO1lBQ25CcUQsUUFBUXJELEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87Z0JBQUV3QixTQUFTO2dCQUFPeEIsT0FBT0EsTUFBTXlCLE9BQU87WUFBQztRQUNoRDtJQUNGO0lBRUEsd0ZBQXdGO0lBQ3hGa0gsa0JBQWtCLE9BQU9wQjtRQUN2QixJQUFJO1lBQ0YsbUVBQW1FO1lBQ25FLHdEQUF3RDtZQUN4RCxJQUFJQSxLQUFLNUMsTUFBTSxJQUFJLEdBQUc7Z0JBQ3BCLE9BQU87b0JBQUVuRCxTQUFTO2dCQUFLO1lBQ3pCLE9BQU87Z0JBQ0wsTUFBTSxJQUFJb0gsTUFBTTtZQUNsQjtRQUNGLEVBQUUsT0FBTzVJLE9BQVk7WUFDbkJxRCxRQUFRckQsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTztnQkFBRXdCLFNBQVM7Z0JBQU94QixPQUFPQSxNQUFNeUIsT0FBTztZQUFDO1FBQ2hEO0lBQ0Y7QUFDRixFQUFDO0FBRUQscUZBQXFGO0FBQ3JGb0gsT0FBT0MsTUFBTSxDQUFDbkosVUFBVWtCIiwic291cmNlcyI6WyIvaG9tZS91YnVudHUvRVRMQS1QbGF0Zm9ybS9mcm9udGVuZC9zcmMvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdXBhYmFzZS50c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IGFzIGNyZWF0ZVN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuaW1wb3J0IHsgbW9ja1N1cGFiYXNlLCBzaG91bGRVc2VNb2NrRGF0YSB9IGZyb20gJy4vbW9jay1zdXBhYmFzZSdcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX1RPS0VOIVxuXG4vLyBVc2UgbW9jayBkYXRhIGlmIFN1cGFiYXNlIGlzIG5vdCBwcm9wZXJseSBjb25maWd1cmVkXG5jb25zdCByZWFsU3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gc2hvdWxkVXNlTW9ja0RhdGEoKSA/IG1vY2tTdXBhYmFzZSA6IHJlYWxTdXBhYmFzZVxuXG4vLyBFeHBvcnQgY3JlYXRlQ2xpZW50IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5XG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gKCkgPT4gc2hvdWxkVXNlTW9ja0RhdGEoKSA/IG1vY2tTdXBhYmFzZSA6IGNyZWF0ZVN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXG5cbi8vIERhdGFiYXNlIHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtSZXF1ZXN0IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgY2F0ZWdvcnk6IHN0cmluZ1xuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCdcbiAgdXJnZW5jeTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICd1cmdlbnQnXG4gIHN0YXR1czogJ3N1Ym1pdHRlZCcgfCAndW5kZXJfcmV2aWV3JyB8ICdhcHByb3ZlZCcgfCAncmVqZWN0ZWQnIHwgJ3NjaGVkdWxlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJ1xuICBjdXN0b21lcl9pZDogc3RyaW5nXG4gIGFzc2lnbmVkX3RvPzogc3RyaW5nXG4gIGVzdGltYXRlZF9ob3Vycz86IG51bWJlclxuICBhY3R1YWxfaG91cnM6IG51bWJlclxuICBidWRnZXQ/OiBudW1iZXJcbiAgcmVxdWlyZWRfY29tcGxldGlvbl9kYXRlPzogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB3b3JrX3JlcXVlc3RfaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIHN0YXR1czogJ3NjaGVkdWxlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnb25faG9sZCcgfCAnY2FuY2VsbGVkJ1xuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCdcbiAgYXNzaWduZWRfdGVhbV9sZWFkOiBzdHJpbmdcbiAgZXN0aW1hdGVkX2hvdXJzOiBudW1iZXJcbiAgYWN0dWFsX2hvdXJzOiBudW1iZXJcbiAgYnVkZ2V0PzogbnVtYmVyXG4gIHN0YXJ0X2RhdGU6IHN0cmluZ1xuICBlbmRfZGF0ZTogc3RyaW5nXG4gIGNvbXBsZXRpb25fcGVyY2VudGFnZTogbnVtYmVyXG4gIGNsaWVudF9zYXRpc2ZhY3Rpb25fc2NvcmU/OiBudW1iZXJcbiAgb25fdGltZV9kZWxpdmVyeT86IGJvb2xlYW5cbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbmFudCB7XG4gIGlkOiBzdHJpbmdcbiAgY29tcGFueV9uYW1lOiBzdHJpbmdcbiAgc3ViZG9tYWluPzogc3RyaW5nXG4gIGluZHVzdHJ5Pzogc3RyaW5nXG4gIHN0YXR1czogJ2FjdGl2ZScgfCAndHJpYWwnIHwgJ3N1c3BlbmRlZCcgfCAnY2FuY2VsbGVkJ1xuICBzdWJzY3JpcHRpb25fcGxhbjogJ3RyaWFsJyB8ICdwcm9mZXNzaW9uYWwnIHwgJ2VudGVycHJpc2UnXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZmlyc3RfbmFtZTogc3RyaW5nXG4gIGxhc3RfbmFtZTogc3RyaW5nXG4gIHJvbGU6ICdob3N0X2FkbWluJyB8ICdwcm9ncmFtX21hbmFnZXInIHwgJ2NsaWVudF9hZG1pbicgfCAnY2xpZW50X3VzZXInXG4gIHRlbmFudF9pZD86IHN0cmluZ1xuICBpc19hY3RpdmU6IGJvb2xlYW5cbiAgY3JlYXRlZF9hdDogc3RyaW5nXG59XG5cbi8vIEV4dGVuZGVkIFVzZXIgaW50ZXJmYWNlIGZvciB1c2VyIG1hbmFnZW1lbnRcbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZW5kZWRVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGZ1bGxfbmFtZTogc3RyaW5nXG4gIHBob25lPzogc3RyaW5nXG4gIGRlcGFydG1lbnQ/OiBzdHJpbmdcbiAgam9iX3RpdGxlPzogc3RyaW5nXG4gIHJvbGU6IHN0cmluZ1xuICByb2xlX2xldmVsOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgdGVuYW50X25hbWU/OiBzdHJpbmdcbiAgaXNfYWN0aXZlOiBib29sZWFuXG4gIGNhbl9pbnZpdGVfdXNlcnM6IGJvb2xlYW5cbiAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogYm9vbGVhblxuICBwZXJtaXNzaW9uX3Njb3BlOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBsYXN0X2xvZ2luPzogc3RyaW5nXG59XG5cbi8vIFVzZXIgY3JlYXRpb24gZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlckNyZWF0aW9uRGF0YSB7XG4gIGVtYWlsOiBzdHJpbmdcbiAgZnVsbF9uYW1lOiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIGNhbl9pbnZpdGVfdXNlcnM6IGJvb2xlYW5cbiAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogYm9vbGVhblxuICBwZXJtaXNzaW9uX3Njb3BlOiBzdHJpbmdcbn1cblxuLy8gVXNlciBpbnZpdGF0aW9uIGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJJbnZpdGF0aW9uRGF0YSB7XG4gIGVtYWlsczogc3RyaW5nW11cbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICBtZXNzYWdlPzogc3RyaW5nXG4gIGV4cGlyZXNfaW5fZGF5czogbnVtYmVyXG59XG5cbi8vIFVzZXIgdXBkYXRlIGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJVcGRhdGVEYXRhIHtcbiAgZnVsbF9uYW1lPzogc3RyaW5nXG4gIHBob25lPzogc3RyaW5nXG4gIGRlcGFydG1lbnQ/OiBzdHJpbmdcbiAgam9iX3RpdGxlPzogc3RyaW5nXG4gIHJvbGU/OiBzdHJpbmdcbiAgcm9sZV9sZXZlbD86IHN0cmluZ1xuICB0ZW5hbnRfaWQ/OiBzdHJpbmdcbiAgaXNfYWN0aXZlPzogYm9vbGVhblxuICBjYW5faW52aXRlX3VzZXJzPzogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzPzogYm9vbGVhblxuICBwZXJtaXNzaW9uX3Njb3BlPzogc3RyaW5nXG59XG5cbi8vIENsZWFudXAgb3B0aW9ucyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQ2xlYW51cE9wdGlvbnMge1xuICBkZWxldGVJbmFjdGl2ZVVzZXJzOiBib29sZWFuXG4gIGRlbGV0ZVVuY29uZmlybWVkVXNlcnM6IGJvb2xlYW5cbiAgZGVsZXRlRXhwaXJlZEludml0ZXM6IGJvb2xlYW5cbiAgaW5hY3RpdmVEYXlzOiBudW1iZXJcbiAgdW5jb25maXJtZWREYXlzOiBudW1iZXJcbn1cblxuLy8gQXV0aCBoZWxwZXJzXG5leHBvcnQgY29uc3Qgc2lnbkluV2l0aFJvbGUgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgZW1haWwsXG4gICAgcGFzc3dvcmRcbiAgfSlcbiAgXG4gIGlmIChkYXRhLnVzZXIpIHtcbiAgICAvLyBHZXQgdXNlciBwcm9maWxlIHdpdGggcm9sZSBhbmQgdGVuYW50XG4gICAgY29uc3QgeyBkYXRhOiBwcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgIC5zZWxlY3QoJ3JvbGUsIHRlbmFudF9pZCwgZmlyc3RfbmFtZSwgbGFzdF9uYW1lJylcbiAgICAgIC5lcSgnaWQnLCBkYXRhLnVzZXIuaWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBcbiAgICByZXR1cm4geyB1c2VyOiBkYXRhLnVzZXIsIHByb2ZpbGUsIGVycm9yIH1cbiAgfVxuICBcbiAgcmV0dXJuIHsgdXNlcjogbnVsbCwgcHJvZmlsZTogbnVsbCwgZXJyb3IgfVxufVxuXG5leHBvcnQgY29uc3Qgc2lnbk91dCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KClcbiAgcmV0dXJuIHsgZXJyb3IgfVxufVxuXG4vLyBEYXRhYmFzZSBoZWxwZXJzXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGxcbiAgXG4gIGNvbnN0IHsgZGF0YTogcHJvZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgndXNlcnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgIC5zaW5nbGUoKVxuICBcbiAgcmV0dXJuIHsgLi4udXNlciwgcHJvZmlsZSB9XG59XG5cbi8vIFVzZXIgTWFuYWdlbWVudCBNZXRob2RzXG5leHBvcnQgY29uc3QgdXNlck1hbmFnZW1lbnQgPSB7XG4gIC8vIENyZWF0ZSBhIG5ldyB1c2VyIHdpdGggY29tcGxldGUgUkJBQyBzZXR1cFxuICBjcmVhdGVVc2VyOiBhc3luYyAodXNlckRhdGE6IFVzZXJDcmVhdGlvbkRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QsIGNyZWF0ZSB0aGUgYXV0aCB1c2VyXG4gICAgICBjb25zdCB7IGRhdGE6IGF1dGhEYXRhLCBlcnJvcjogYXV0aEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLmNyZWF0ZVVzZXIoe1xuICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICAgIHBhc3N3b3JkOiB1c2VyRGF0YS5wYXNzd29yZCxcbiAgICAgICAgZW1haWxfY29uZmlybTogdHJ1ZSxcbiAgICAgICAgdXNlcl9tZXRhZGF0YToge1xuICAgICAgICAgIGZ1bGxfbmFtZTogdXNlckRhdGEuZnVsbF9uYW1lLFxuICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgcm9sZV9sZXZlbDogdXNlckRhdGEucm9sZV9sZXZlbFxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoYXV0aEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYXV0aEVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF1dGhEYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIGNyZWF0ZSB1c2VyIGFjY291bnQnIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHRoZSB1c2VyIHByb2ZpbGUgKEZJWEVEOiB1c2luZyAncHJvZmlsZXMnIG5vdCAndXNlcl9wcm9maWxlcycpXG4gICAgICBjb25zdCB7IGVycm9yOiBwcm9maWxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIGlkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgICBmdWxsX25hbWU6IHVzZXJEYXRhLmZ1bGxfbmFtZSxcbiAgICAgICAgICBwaG9uZTogdXNlckRhdGEucGhvbmUsXG4gICAgICAgICAgZGVwYXJ0bWVudDogdXNlckRhdGEuZGVwYXJ0bWVudCxcbiAgICAgICAgICBqb2JfdGl0bGU6IHVzZXJEYXRhLmpvYl90aXRsZSxcbiAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgdGVuYW50X2lkOiB1c2VyRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNhbl9pbnZpdGVfdXNlcnM6IHVzZXJEYXRhLmNhbl9pbnZpdGVfdXNlcnMsXG4gICAgICAgICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogdXNlckRhdGEuY2FuX21hbmFnZV9zdWJfY2xpZW50cyxcbiAgICAgICAgICBwZXJtaXNzaW9uX3Njb3BlOiB1c2VyRGF0YS5wZXJtaXNzaW9uX3Njb3BlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcblxuICAgICAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgICAgICAvLyBJZiBwcm9maWxlIGNyZWF0aW9uIGZhaWxzLCBjbGVhbiB1cCB0aGUgYXV0aCB1c2VyXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZGVsZXRlVXNlcihhdXRoRGF0YS51c2VyLmlkKVxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBQcm9maWxlIGNyZWF0aW9uIGZhaWxlZDogJHtwcm9maWxlRXJyb3IubWVzc2FnZX1gIH1cbiAgICAgIH1cblxuICAgICAgLy8gTkVXOiBDcmVhdGUgdGVuYW50X3VzZXJzIHJlY29yZCBmb3IgUkJBQ1xuICAgICAgY29uc3QgeyBlcnJvcjogdGVuYW50VXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGVuYW50X3VzZXJzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdGVuYW50X2lkOiB1c2VyRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgdXNlcl9pZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgY2FuX2ludml0ZV91c2VyczogdXNlckRhdGEuY2FuX2ludml0ZV91c2VycyxcbiAgICAgICAgICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiB1c2VyRGF0YS5jYW5fbWFuYWdlX3N1Yl9jbGllbnRzLFxuICAgICAgICAgIHBlcm1pc3Npb25fc2NvcGU6IHVzZXJEYXRhLnBlcm1pc3Npb25fc2NvcGUsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcblxuICAgICAgaWYgKHRlbmFudFVzZXJFcnJvcikge1xuICAgICAgICAvLyBJZiB0ZW5hbnRfdXNlcnMgY3JlYXRpb24gZmFpbHMsIGNsZWFuIHVwIGF1dGggdXNlciBhbmQgcHJvZmlsZVxuICAgICAgICBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLmRlbGV0ZVVzZXIoYXV0aERhdGEudXNlci5pZClcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS5kZWxldGUoKS5lcSgnaWQnLCBhdXRoRGF0YS51c2VyLmlkKVxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBUZW5hbnQgYXNzaWdubWVudCBmYWlsZWQ6ICR7dGVuYW50VXNlckVycm9yLm1lc3NhZ2V9YCB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9QVElPTkFMOiBDcmVhdGUgYXVkaXQgbG9nIGlmIHRhYmxlIGV4aXN0c1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnYXVkaXRfbG9ncycpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICB1c2VyX2lkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgICAgICAgdGVuYW50X2lkOiB1c2VyRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgICBhY3Rpb246ICd1c2VyX2NyZWF0ZWQnLFxuICAgICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3VzZXInLFxuICAgICAgICAgICAgcmVzb3VyY2VfaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIGNyZWF0ZWRfYnk6ICdhZG1pbl9pbnRlcmZhY2UnLFxuICAgICAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpcF9hZGRyZXNzOiAnMTI3LjAuMC4xJyxcbiAgICAgICAgICAgIHVzZXJfYWdlbnQ6ICdBZG1pbiBJbnRlcmZhY2UnLFxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdpbmZvJyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChhdWRpdEVycm9yKSB7XG4gICAgICAgIC8vIEF1ZGl0IGxvZyBpcyBvcHRpb25hbCwgZG9uJ3QgZmFpbCB0aGUgdXNlciBjcmVhdGlvblxuICAgICAgICBjb25zb2xlLndhcm4oJ0F1ZGl0IGxvZyBjcmVhdGlvbiBmYWlsZWQ6JywgYXVkaXRFcnJvcilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogYXV0aERhdGEudXNlciB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gY3JlYXRlIHVzZXInIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gSW52aXRlIHVzZXJzIHZpYSBlbWFpbFxuICBpbnZpdGVVc2VyczogYXN5bmMgKGludml0YXRpb25EYXRhOiBVc2VySW52aXRhdGlvbkRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW52aXRhdGlvbnMgPSBbXVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGludml0YXRpb25EYXRhLmVtYWlscykge1xuICAgICAgICAvLyBDcmVhdGUgaW52aXRhdGlvbiByZWNvcmRcbiAgICAgICAgY29uc3QgeyBkYXRhOiBpbnZpdGF0aW9uLCBlcnJvcjogaW52aXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICByb2xlOiBpbnZpdGF0aW9uRGF0YS5yb2xlLFxuICAgICAgICAgICAgcm9sZV9sZXZlbDogaW52aXRhdGlvbkRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICAgIHRlbmFudF9pZDogaW52aXRhdGlvbkRhdGEudGVuYW50X2lkLFxuICAgICAgICAgICAgbWVzc2FnZTogaW52aXRhdGlvbkRhdGEubWVzc2FnZSxcbiAgICAgICAgICAgIGV4cGlyZXNfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyBpbnZpdGF0aW9uRGF0YS5leHBpcmVzX2luX2RheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAuc2luZ2xlKClcblxuICAgICAgICBpZiAoaW52aXRlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGludml0YXRpb24gZm9yICR7ZW1haWx9OmAsIGludml0ZUVycm9yKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZW5kIGludml0YXRpb24gZW1haWwgdXNpbmcgU3VwYWJhc2UgQXV0aFxuICAgICAgICBjb25zdCB7IGVycm9yOiBlbWFpbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLmludml0ZVVzZXJCeUVtYWlsKGVtYWlsLCB7XG4gICAgICAgICAgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vYWNjZXB0LWludml0YXRpb24/dG9rZW49JHtpbnZpdGF0aW9uLmlkfWAsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcm9sZTogaW52aXRhdGlvbkRhdGEucm9sZSxcbiAgICAgICAgICAgIHJvbGVfbGV2ZWw6IGludml0YXRpb25EYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgICB0ZW5hbnRfaWQ6IGludml0YXRpb25EYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICAgIGludml0YXRpb25faWQ6IGludml0YXRpb24uaWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGVtYWlsRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gc2VuZCBpbnZpdGF0aW9uIGVtYWlsIHRvICR7ZW1haWx9OmAsIGVtYWlsRXJyb3IpXG4gICAgICAgICAgLy8gTWFyayBpbnZpdGF0aW9uIGFzIGZhaWxlZFxuICAgICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgICAudXBkYXRlKHsgc3RhdHVzOiAnZmFpbGVkJyB9KVxuICAgICAgICAgICAgLmVxKCdpZCcsIGludml0YXRpb24uaWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52aXRhdGlvbnMucHVzaChpbnZpdGF0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiB0cnVlLCBcbiAgICAgICAgZGF0YTogeyBcbiAgICAgICAgICBzZW50OiBpbnZpdGF0aW9ucy5sZW5ndGgsIFxuICAgICAgICAgIHRvdGFsOiBpbnZpdGF0aW9uRGF0YS5lbWFpbHMubGVuZ3RoIFxuICAgICAgICB9IFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHNlbmQgaW52aXRhdGlvbnMnIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gVXBkYXRlIHVzZXIgaW5mb3JtYXRpb25cbiAgdXBkYXRlVXNlcjogYXN5bmMgKHVzZXJJZDogc3RyaW5nLCB1cGRhdGVEYXRhOiBVc2VyVXBkYXRlRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAuLi51cGRhdGVEYXRhLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHVzZXInIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gRGVhY3RpdmF0ZSB1c2VyXG4gIGRlYWN0aXZhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgaXNfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGRlYWN0aXZhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBBY3RpdmF0ZSB1c2VyXG4gIGFjdGl2YXRlVXNlcjogYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGFjdGl2YXRlIHVzZXInIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzZXQgdXNlciBwYXNzd29yZFxuICByZXNldFVzZXJQYXNzd29yZDogYXN5bmMgKGVtYWlsOiBzdHJpbmcsIG5ld1Bhc3N3b3JkPzogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuZXdQYXNzd29yZCkge1xuICAgICAgICAvLyBEaXJlY3QgcGFzc3dvcmQgcmVzZXQgKGFkbWluIGZ1bmN0aW9uKVxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLnVwZGF0ZVVzZXJCeUlkKFxuICAgICAgICAgIGVtYWlsLCAvLyBUaGlzIHNob3VsZCBiZSB1c2VyIElELCBidXQgd2UnbGwgbmVlZCB0byBnZXQgaXQgZmlyc3RcbiAgICAgICAgICB7IHBhc3N3b3JkOiBuZXdQYXNzd29yZCB9XG4gICAgICAgIClcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbWFpbC1iYXNlZCBwYXNzd29yZCByZXNldFxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwge1xuICAgICAgICAgIHJlZGlyZWN0VG86IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L3Jlc2V0LXBhc3N3b3JkYFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byByZXNldCBwYXNzd29yZCcgfVxuICAgIH1cbiAgfSxcblxuICAvLyBQcmV2aWV3IGNsZWFudXAgb3BlcmF0aW9uc1xuICBwcmV2aWV3VXNlckNsZWFudXA6IGFzeW5jIChvcHRpb25zOiBDbGVhbnVwT3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgaW5hY3RpdmVVc2VycyA9IDBcbiAgICAgIGxldCB1bmNvbmZpcm1lZFVzZXJzID0gMFxuICAgICAgbGV0IGV4cGlyZWRJbnZpdGVzID0gMFxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVJbmFjdGl2ZVVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy5pbmFjdGl2ZURheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5sdCgnbGFzdF9sb2dpbicsIGN1dG9mZkRhdGUpXG4gICAgICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuXG4gICAgICAgIGluYWN0aXZlVXNlcnMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZVVuY29uZmlybWVkVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLnVuY29uZmlybWVkRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnYXV0aC51c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgICAuaXMoJ2VtYWlsX2NvbmZpcm1lZF9hdCcsIG51bGwpXG4gICAgICAgICAgLmx0KCdjcmVhdGVkX2F0JywgY3V0b2ZmRGF0ZSlcblxuICAgICAgICB1bmNvbmZpcm1lZFVzZXJzID0gY291bnQgfHwgMFxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVFeHBpcmVkSW52aXRlcykge1xuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5sdCgnZXhwaXJlc19hdCcsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgICAgICAubmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuXG4gICAgICAgIGV4cGlyZWRJbnZpdGVzID0gY291bnQgfHwgMFxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b3RhbFRvRGVsZXRlID0gaW5hY3RpdmVVc2VycyArIHVuY29uZmlybWVkVXNlcnMgKyBleHBpcmVkSW52aXRlc1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaW5hY3RpdmVVc2VycyxcbiAgICAgICAgICB1bmNvbmZpcm1lZFVzZXJzLFxuICAgICAgICAgIGV4cGlyZWRJbnZpdGVzLFxuICAgICAgICAgIHRvdGFsVG9EZWxldGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHByZXZpZXcgY2xlYW51cCcgfVxuICAgIH1cbiAgfSxcblxuICAvLyBFeGVjdXRlIGNsZWFudXAgb3BlcmF0aW9uc1xuICBleGVjdXRlVXNlckNsZWFudXA6IGFzeW5jIChvcHRpb25zOiBDbGVhbnVwT3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZGVsZXRlZENvdW50ID0gMFxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVJbmFjdGl2ZVVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy5pbmFjdGl2ZURheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgaW5hY3RpdmUgdXNlcnNcbiAgICAgICAgY29uc3QgeyBkYXRhOiBpbmFjdGl2ZVVzZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgIC5sdCgnbGFzdF9sb2dpbicsIGN1dG9mZkRhdGUpXG4gICAgICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuXG4gICAgICAgIGlmIChpbmFjdGl2ZVVzZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB1c2VyIG9mIGluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhdXRoIHVzZXJcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZGVsZXRlVXNlcih1c2VyLmlkKVxuICAgICAgICAgICAgLy8gRGVsZXRlIHByb2ZpbGVcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlZENvdW50ICs9IGluYWN0aXZlVXNlcnMubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlVW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMudW5jb25maXJtZWREYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBcbiAgICAgICAgLy8gVGhpcyB3b3VsZCByZXF1aXJlIGFkbWluIGFjY2VzcyB0byBhdXRoLnVzZXJzIHRhYmxlXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIG1hcmsgdGhlbSBhcyBpbmFjdGl2ZVxuICAgICAgICBjb25zdCB7IGRhdGE6IHVuY29uZmlybWVkVXNlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgLmx0KCdjcmVhdGVkX2F0JywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaWYgKHVuY29uZmlybWVkVXNlcnMpIHtcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAgIC51cGRhdGUoeyBpc19hY3RpdmU6IGZhbHNlIH0pXG4gICAgICAgICAgICAuaW4oJ2lkJywgdW5jb25maXJtZWRVc2Vycy5tYXAodSA9PiB1LmlkKSlcbiAgICAgICAgICBcbiAgICAgICAgICBkZWxldGVkQ291bnQgKz0gdW5jb25maXJtZWRVc2Vycy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVFeHBpcmVkSW52aXRlcykge1xuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAubHQoJ2V4cGlyZXNfYXQnLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXG4gICAgICAgICAgLm5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcblxuICAgICAgICBkZWxldGVkQ291bnQgKz0gY291bnQgfHwgMFxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGRlbGV0ZWRDb3VudCB9IH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBleGVjdXRlIGNsZWFudXAnIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1mYU1hbmFnZW1lbnQgPSB7XG4gIC8vIENoZWNrIGlmIHVzZXIgaGFzIE1GQSBlbmFibGVkXG4gIGNoZWNrTUZBU3RhdHVzOiBhc3luYyAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnNlbGVjdCgnbWZhX2VuYWJsZWQnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgbWZhRW5hYmxlZDogZGF0YT8ubWZhX2VuYWJsZWQgfHwgZmFsc2UgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIE1GQSBzdGF0dXM6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBtZmFFbmFibGVkOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfSxcblxuICAvLyBFbmFibGUgTUZBIGZvciB1c2VyXG4gIGVuYWJsZU1GQTogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBFbnJvbGwgZm9yIFRPVFAgTUZBXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLm1mYS5lbnJvbGwoe1xuICAgICAgICBmYWN0b3JUeXBlOiAndG90cCcsXG4gICAgICAgIGZyaWVuZGx5TmFtZTogJ0VUTEEgUGxhdGZvcm0gVE9UUCdcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVuYWJsaW5nIE1GQTonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFZlcmlmeSBNRkEgc2V0dXBcbiAgdmVyaWZ5TUZBU2V0dXA6IGFzeW5jIChmYWN0b3JJZDogc3RyaW5nLCBjb2RlOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGNoYWxsZW5nZSBmaXJzdFxuICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2UsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEuY2hhbGxlbmdlKHtcbiAgICAgICAgZmFjdG9ySWRcbiAgICAgIH0pXG5cbiAgICAgIGlmIChjaGFsbGVuZ2VFcnJvcikgdGhyb3cgY2hhbGxlbmdlRXJyb3JcblxuICAgICAgLy8gVmVyaWZ5IHRoZSBjb2RlXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLm1mYS52ZXJpZnkoe1xuICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZS5pZCxcbiAgICAgICAgY29kZVxuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICAvLyBVcGRhdGUgdXNlciBwcm9maWxlIHRvIGluZGljYXRlIE1GQSBpcyBlbmFibGVkXG4gICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC51cGRhdGUoeyBcbiAgICAgICAgICAgIG1mYV9lbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIE1GQSBzZXR1cDonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9LFxuXG4gIC8vIERpc2FibGUgTUZBIGZvciB1c2VyXG4gIGRpc2FibGVNRkE6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGFsbCBmYWN0b3JzXG4gICAgICBjb25zdCB7IGRhdGE6IGZhY3RvcnMsIGVycm9yOiBmYWN0b3JzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLmxpc3RGYWN0b3JzKClcbiAgICAgIFxuICAgICAgaWYgKGZhY3RvcnNFcnJvcikgdGhyb3cgZmFjdG9yc0Vycm9yXG5cbiAgICAgIC8vIFVuZW5yb2xsIGFsbCBUT1RQIGZhY3RvcnNcbiAgICAgIGlmIChmYWN0b3JzPy50b3RwKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFjdG9yIG9mIGZhY3RvcnMudG90cCkge1xuICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLnVuZW5yb2xsKHsgZmFjdG9ySWQ6IGZhY3Rvci5pZCB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHByb2ZpbGVcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICBpZiAodXNlcikge1xuICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgICAgbWZhX2VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzYWJsaW5nIE1GQTonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEdlbmVyYXRlIGJhY2t1cCBjb2RlcyAoc2ltdWxhdGVkIC0gaW4gcHJvZHVjdGlvbiB0aGlzIHdvdWxkIGJlIGhhbmRsZWQgYnkgeW91ciBiYWNrZW5kKVxuICBnZW5lcmF0ZUJhY2t1cENvZGVzOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXRlIDggYmFja3VwIGNvZGVzXG4gICAgICBjb25zdCBjb2RlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDggfSwgKCkgPT4gXG4gICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KS50b1VwcGVyQ2FzZSgpXG4gICAgICApXG5cbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSB3b3VsZCBzdG9yZSB0aGVzZSBzZWN1cmVseSBpbiB5b3VyIGJhY2tlbmRcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgcmV0dXJuIHRoZW1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGNvZGVzIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGJhY2t1cCBjb2RlczonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFZlcmlmeSBiYWNrdXAgY29kZSAoc2ltdWxhdGVkIC0gaW4gcHJvZHVjdGlvbiB0aGlzIHdvdWxkIHZlcmlmeSBhZ2FpbnN0IHN0b3JlZCBjb2RlcylcbiAgdmVyaWZ5QmFja3VwQ29kZTogYXN5bmMgKGNvZGU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3Ugd291bGQgdmVyaWZ5IHRoaXMgYWdhaW5zdCBzdG9yZWQgYmFja3VwIGNvZGVzXG4gICAgICAvLyBGb3IgZGVtbyBwdXJwb3Nlcywgd2UnbGwgYWNjZXB0IGFueSA2KyBjaGFyYWN0ZXIgY29kZVxuICAgICAgaWYgKGNvZGUubGVuZ3RoID49IDYpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFja3VwIGNvZGUnKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBiYWNrdXAgY29kZTonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9XG59XG5cbi8vIEFkZCB1c2VyIG1hbmFnZW1lbnQgbWV0aG9kcyB0byB0aGUgbWFpbiBzdXBhYmFzZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbk9iamVjdC5hc3NpZ24oc3VwYWJhc2UsIHVzZXJNYW5hZ2VtZW50KVxuXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiY3JlYXRlU3VwYWJhc2VDbGllbnQiLCJtb2NrU3VwYWJhc2UiLCJzaG91bGRVc2VNb2NrRGF0YSIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4iLCJyZWFsU3VwYWJhc2UiLCJzdXBhYmFzZSIsInNpZ25JbldpdGhSb2xlIiwiZW1haWwiLCJwYXNzd29yZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJ1c2VyIiwicHJvZmlsZSIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwic2lnbk91dCIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlciIsInVzZXJNYW5hZ2VtZW50IiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwiYXV0aERhdGEiLCJhdXRoRXJyb3IiLCJhZG1pbiIsImVtYWlsX2NvbmZpcm0iLCJ1c2VyX21ldGFkYXRhIiwiZnVsbF9uYW1lIiwicm9sZSIsInJvbGVfbGV2ZWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsInByb2ZpbGVFcnJvciIsImluc2VydCIsInBob25lIiwiZGVwYXJ0bWVudCIsImpvYl90aXRsZSIsInRlbmFudF9pZCIsImlzX2FjdGl2ZSIsImNhbl9pbnZpdGVfdXNlcnMiLCJjYW5fbWFuYWdlX3N1Yl9jbGllbnRzIiwicGVybWlzc2lvbl9zY29wZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlVXNlciIsInRlbmFudFVzZXJFcnJvciIsInVzZXJfaWQiLCJkZWxldGUiLCJhY3Rpb24iLCJyZXNvdXJjZV90eXBlIiwicmVzb3VyY2VfaWQiLCJkZXRhaWxzIiwiY3JlYXRlZF9ieSIsImlwX2FkZHJlc3MiLCJ1c2VyX2FnZW50Iiwic2V2ZXJpdHkiLCJhdWRpdEVycm9yIiwiY29uc29sZSIsIndhcm4iLCJpbnZpdGVVc2VycyIsImludml0YXRpb25EYXRhIiwiaW52aXRhdGlvbnMiLCJlbWFpbHMiLCJpbnZpdGF0aW9uIiwiaW52aXRlRXJyb3IiLCJleHBpcmVzX2F0Iiwibm93IiwiZXhwaXJlc19pbl9kYXlzIiwiZW1haWxFcnJvciIsImludml0ZVVzZXJCeUVtYWlsIiwicmVkaXJlY3RUbyIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiaW52aXRhdGlvbl9pZCIsInVwZGF0ZSIsInN0YXR1cyIsInB1c2giLCJzZW50IiwibGVuZ3RoIiwidG90YWwiLCJ1cGRhdGVVc2VyIiwidXNlcklkIiwidXBkYXRlRGF0YSIsImRlYWN0aXZhdGVVc2VyIiwiYWN0aXZhdGVVc2VyIiwicmVzZXRVc2VyUGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsInVwZGF0ZVVzZXJCeUlkIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwicHJldmlld1VzZXJDbGVhbnVwIiwib3B0aW9ucyIsImluYWN0aXZlVXNlcnMiLCJ1bmNvbmZpcm1lZFVzZXJzIiwiZXhwaXJlZEludml0ZXMiLCJkZWxldGVJbmFjdGl2ZVVzZXJzIiwiY3V0b2ZmRGF0ZSIsImluYWN0aXZlRGF5cyIsImNvdW50IiwiaGVhZCIsImx0IiwiZGVsZXRlVW5jb25maXJtZWRVc2VycyIsInVuY29uZmlybWVkRGF5cyIsImlzIiwiZGVsZXRlRXhwaXJlZEludml0ZXMiLCJuZXEiLCJ0b3RhbFRvRGVsZXRlIiwiZXhlY3V0ZVVzZXJDbGVhbnVwIiwiZGVsZXRlZENvdW50IiwiaW4iLCJtYXAiLCJ1IiwibWZhTWFuYWdlbWVudCIsImNoZWNrTUZBU3RhdHVzIiwibWZhRW5hYmxlZCIsIm1mYV9lbmFibGVkIiwiZW5hYmxlTUZBIiwibWZhIiwiZW5yb2xsIiwiZmFjdG9yVHlwZSIsImZyaWVuZGx5TmFtZSIsInZlcmlmeU1GQVNldHVwIiwiZmFjdG9ySWQiLCJjb2RlIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlRXJyb3IiLCJ2ZXJpZnkiLCJjaGFsbGVuZ2VJZCIsImRpc2FibGVNRkEiLCJmYWN0b3JzIiwiZmFjdG9yc0Vycm9yIiwibGlzdEZhY3RvcnMiLCJ0b3RwIiwiZmFjdG9yIiwidW5lbnJvbGwiLCJnZW5lcmF0ZUJhY2t1cENvZGVzIiwiY29kZXMiLCJBcnJheSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInRvVXBwZXJDYXNlIiwidmVyaWZ5QmFja3VwQ29kZSIsIkVycm9yIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});