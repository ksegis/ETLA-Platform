"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/contexts/AuthContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/AuthContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _utils_serviceAuth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/serviceAuth */ \"(app-pages-browser)/./src/utils/serviceAuth.ts\");\n/* __next_internal_client_entry_do_not_use__ supabase,AuthProvider,useAuth,default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Initialize Supabase client\nconst supabaseUrl = \"https://your-project.supabase.co\" || 0;\nconst supabaseAnonKey = \"your_anon_token_here\" || 0;\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_3__.createClient)(supabaseUrl, supabaseAnonKey);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isStable, setIsStable] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Tenant state with demo fallback\n    const [tenant, setTenant] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n        name: 'Demo Company',\n        slug: 'demo-company',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    });\n    // Tenant user state with demo fallback\n    const [tenantUser, setTenantUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        id: 'demo-tenant-user-id',\n        tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n        user_id: 'demo-user-id',\n        role: 'client_admin',\n        is_active: true,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    });\n    // Computed properties for RBAC\n    const isDemoMode =  false || \"https://your-project.supabase.co\".includes('placeholder');\n    const isAuthenticated = !!user || !!session || isDemoMode;\n    const currentUserId = (user === null || user === void 0 ? void 0 : user.id) || (tenantUser === null || tenantUser === void 0 ? void 0 : tenantUser.user_id) || null;\n    const currentTenantId = (tenant === null || tenant === void 0 ? void 0 : tenant.id) || null;\n    const currentUserRole = (tenantUser === null || tenantUser === void 0 ? void 0 : tenantUser.role) || null;\n    // Helper function to update service auth context\n    const updateServiceAuthContext = ()=>{\n        (0,_utils_serviceAuth__WEBPACK_IMPORTED_MODULE_2__.setServiceAuthContext)({\n            userId: currentUserId,\n            tenantId: currentTenantId,\n            userRole: currentUserRole,\n            isAuthenticated,\n            isDemoMode\n        });\n    };\n    // Initialize authentication state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            console.log('ðŸ” AuthProvider: Initializing authentication state');\n            const getInitialSession = {\n                \"AuthProvider.useEffect.getInitialSession\": async ()=>{\n                    try {\n                        const { data: { session: initialSession }, error } = await supabase.auth.getSession();\n                        if (error) {\n                            console.error('âŒ AuthProvider: Error getting session:', error);\n                            // Fall back to demo mode\n                            setUser({\n                                id: 'demo-user-id',\n                                email: 'demo@company.com',\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString(),\n                                app_metadata: {},\n                                user_metadata: {},\n                                aud: 'authenticated',\n                                confirmation_sent_at: new Date().toISOString()\n                            });\n                            setTenantUser({\n                                id: 'demo-tenant-user-id',\n                                tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                                user_id: 'demo-user-id',\n                                role: 'client_admin',\n                                is_active: true,\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            });\n                        } else if (initialSession) {\n                            console.log('âœ… AuthProvider: Found existing session');\n                            setSession(initialSession);\n                            setUser(initialSession.user);\n                            // Set tenant user for authenticated user\n                            setTenantUser({\n                                id: 'demo-tenant-user-id',\n                                tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                                user_id: initialSession.user.id,\n                                role: 'client_admin',\n                                is_active: true,\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            });\n                        } else {\n                            console.log('âš ï¸ AuthProvider: No existing session, using demo user');\n                            // Fallback to demo user for stability\n                            setUser({\n                                id: 'demo-user-id',\n                                email: 'demo@company.com',\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString(),\n                                app_metadata: {},\n                                user_metadata: {},\n                                aud: 'authenticated',\n                                confirmation_sent_at: new Date().toISOString()\n                            });\n                            // Set demo tenant user\n                            setTenantUser({\n                                id: 'demo-tenant-user-id',\n                                tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                                user_id: 'demo-user-id',\n                                role: 'client_admin',\n                                is_active: true,\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            });\n                        }\n                        setLoading(false);\n                        setIsStable(true);\n                        updateServiceAuthContext();\n                        console.log('âœ… AuthProvider: Authentication state stabilized');\n                    } catch (error) {\n                        console.error('âŒ AuthProvider: Unexpected error during initialization:', error);\n                        // Ensure we always have a stable state\n                        setUser(null);\n                        setSession(null);\n                        setTenantUser({\n                            id: 'demo-tenant-user-id',\n                            tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                            user_id: 'demo-user-id',\n                            role: 'client_admin',\n                            is_active: true,\n                            created_at: new Date().toISOString(),\n                            updated_at: new Date().toISOString()\n                        });\n                        setLoading(false);\n                        setIsStable(true);\n                        updateServiceAuthContext();\n                    }\n                }\n            }[\"AuthProvider.useEffect.getInitialSession\"];\n            getInitialSession();\n            // Listen for auth changes\n            const { data: { subscription } } = supabase.auth.onAuthStateChange({\n                \"AuthProvider.useEffect\": async (event, newSession)=>{\n                    console.log('ðŸ”„ AuthProvider: Auth state changed:', event);\n                    if (newSession) {\n                        setSession(newSession);\n                        setUser(newSession.user);\n                        // Set tenant user for authenticated user\n                        setTenantUser({\n                            id: 'demo-tenant-user-id',\n                            tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                            user_id: newSession.user.id,\n                            role: 'client_admin',\n                            is_active: true,\n                            created_at: new Date().toISOString(),\n                            updated_at: new Date().toISOString()\n                        });\n                    } else {\n                        console.log('âš ï¸ AuthProvider: User signed out, falling back to demo user');\n                        // Fallback to demo user for stability\n                        setUser({\n                            id: 'demo-user-id',\n                            email: 'demo@company.com',\n                            created_at: new Date().toISOString(),\n                            updated_at: new Date().toISOString(),\n                            app_metadata: {},\n                            user_metadata: {},\n                            aud: 'authenticated',\n                            confirmation_sent_at: new Date().toISOString()\n                        });\n                        setSession(null);\n                        // Set demo tenant user\n                        setTenantUser({\n                            id: 'demo-tenant-user-id',\n                            tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                            user_id: 'demo-user-id',\n                            role: 'client_admin',\n                            is_active: true,\n                            created_at: new Date().toISOString(),\n                            updated_at: new Date().toISOString()\n                        });\n                    }\n                    setLoading(false);\n                    setIsStable(true);\n                    updateServiceAuthContext();\n                }\n            }[\"AuthProvider.useEffect\"]);\n            return ({\n                \"AuthProvider.useEffect\": ()=>{\n                    subscription.unsubscribe();\n                }\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    const signIn = async (email, password)=>{\n        try {\n            const { error } = await supabase.auth.signInWithPassword({\n                email,\n                password\n            });\n            return {\n                error\n            };\n        } catch (error) {\n            console.error('âŒ AuthProvider: Sign in error:', error);\n            return {\n                error\n            };\n        }\n    };\n    const signUp = async (email, password)=>{\n        try {\n            const { error } = await supabase.auth.signUp({\n                email,\n                password\n            });\n            return {\n                error\n            };\n        } catch (error) {\n            console.error('âŒ AuthProvider: Sign up error:', error);\n            return {\n                error\n            };\n        }\n    };\n    const signOut = async ()=>{\n        console.log('ðŸ” AuthProvider: Signing out');\n        try {\n            await supabase.auth.signOut();\n            // Reset to demo state\n            setUser(null);\n            setSession(null);\n            setTenantUser({\n                id: 'demo-tenant-user-id',\n                tenant_id: '54afbd1d-e72a-41e1-9d39-2c8a08a257ff',\n                user_id: 'demo-user-id',\n                role: 'client_admin',\n                is_active: true,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            setLoading(false);\n            setIsStable(true);\n            updateServiceAuthContext();\n            // Redirect to login page\n            if (true) {\n                window.location.href = '/login';\n            }\n        } catch (error) {\n            console.error('âŒ AuthProvider: Error during sign out:', error);\n            // Still redirect even if there's an error\n            if (true) {\n                window.location.href = '/login';\n            }\n        }\n    };\n    const refreshTenant = async ()=>{\n        console.log('ðŸ”„ AuthProvider: Refreshing tenant information');\n    // In a real implementation, this would fetch fresh tenant data\n    // For now, we maintain the demo state\n    };\n    const refreshSession = async ()=>{\n        console.log('ðŸ”„ AuthProvider: Refreshing session');\n        try {\n            const { data: { session }, error } = await supabase.auth.refreshSession();\n            if (error) {\n                console.error('âŒ AuthProvider: Error refreshing session:', error);\n            } else {\n                setSession(session);\n                if (session === null || session === void 0 ? void 0 : session.user) {\n                    setUser(session.user);\n                }\n            }\n        } catch (error) {\n            console.error('âŒ AuthProvider: Unexpected error refreshing session:', error);\n        }\n    };\n    const value = {\n        user,\n        tenant,\n        tenantUser,\n        session,\n        loading,\n        signIn,\n        signUp,\n        signOut,\n        refreshTenant,\n        refreshSession,\n        isStable,\n        isAuthenticated,\n        isDemoMode,\n        currentUserId,\n        currentTenantId,\n        currentUserRole\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/ubuntu/ETLA-Platform/frontend/src/contexts/AuthContext.tsx\",\n        lineNumber: 358,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"YEpTbEL9+YoQBsFfazIctBtacvE=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n}\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthContext);\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFaUY7QUFDN0I7QUFFTztBQXVDM0QsTUFBTU0sNEJBQWNOLG9EQUFhQSxDQUE4Qk87QUFFL0QsNkJBQTZCO0FBQzdCLE1BQU1DLGNBQWNDLGtDQUFvQyxJQUFJLENBQTBCO0FBQ3RGLE1BQU1HLGtCQUFrQkgsc0JBQTJDLElBQUksQ0FBVTtBQUUxRSxNQUFNSyxXQUFXVixtRUFBWUEsQ0FBQ0ksYUFBYUksaUJBQWdCO0FBRTNELFNBQVNHLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdmLCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ2dCLFNBQVNDLFdBQVcsR0FBR2pCLCtDQUFRQSxDQUFpQjtJQUN2RCxNQUFNLENBQUNrQixTQUFTQyxXQUFXLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNvQixVQUFVQyxZQUFZLEdBQUdyQiwrQ0FBUUEsQ0FBQztJQUV6QyxrQ0FBa0M7SUFDbEMsTUFBTSxDQUFDc0IsUUFBUUMsVUFBVSxHQUFHdkIsK0NBQVFBLENBQWdCO1FBQ2xEd0IsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO1FBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7SUFDcEM7SUFFQSx1Q0FBdUM7SUFDdkMsTUFBTSxDQUFDRSxZQUFZQyxjQUFjLEdBQUdoQywrQ0FBUUEsQ0FBb0I7UUFDOUR3QixJQUFJO1FBQ0pTLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxNQUFNO1FBQ05DLFdBQVc7UUFDWFQsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO1FBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7SUFDcEM7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTVEsYUFBYSxNQUNtRSxJ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QzNCLElBQUkyRSxZQUFZMUUsV0FBVztRQUN6QixNQUFNLElBQUkyRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVDtJQU5nQkQ7QUFRaEIsaUVBQWUxRSxXQUFXQSxFQUFBIiwic291cmNlcyI6WyIvaG9tZS91YnVudHUvRVRMQS1QbGF0Zm9ybS9mcm9udGVuZC9zcmMvY29udGV4dHMvQXV0aENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbmltcG9ydCB0eXBlIHsgVXNlciwgU2Vzc2lvbiB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbmltcG9ydCB7IHNldFNlcnZpY2VBdXRoQ29udGV4dCB9IGZyb20gJ0AvdXRpbHMvc2VydmljZUF1dGgnXG5cbmludGVyZmFjZSBUZW5hbnQge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzbHVnOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgVGVuYW50VXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgdXNlcl9pZDogc3RyaW5nXG4gIHJvbGU6IHN0cmluZ1xuICBpc19hY3RpdmU6IGJvb2xlYW5cbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgdXNlcjogVXNlciB8IG51bGxcbiAgdGVuYW50OiBUZW5hbnQgfCBudWxsXG4gIHRlbmFudFVzZXI6IFRlbmFudFVzZXIgfCBudWxsXG4gIHNlc3Npb246IFNlc3Npb24gfCBudWxsXG4gIGxvYWRpbmc6IGJvb2xlYW5cbiAgc2lnbkluOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx7IGVycm9yOiBhbnkgfT5cbiAgc2lnblVwOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx7IGVycm9yOiBhbnkgfT5cbiAgc2lnbk91dDogKCkgPT4gUHJvbWlzZTx2b2lkPlxuICByZWZyZXNoVGVuYW50OiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIHJlZnJlc2hTZXNzaW9uOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGlzU3RhYmxlOiBib29sZWFuXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhblxuICBpc0RlbW9Nb2RlOiBib29sZWFuXG4gIGN1cnJlbnRVc2VySWQ6IHN0cmluZyB8IG51bGxcbiAgY3VycmVudFRlbmFudElkOiBzdHJpbmcgfCBudWxsXG4gIGN1cnJlbnRVc2VyUm9sZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50XG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCB8fCAnaHR0cHM6Ly9kZW1vLnN1cGFiYXNlLmNvJ1xuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9UT0tFTiB8fCAnZGVtby1rZXknXG5cbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IHVzZVN0YXRlPFNlc3Npb24gfCBudWxsPihudWxsKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbaXNTdGFibGUsIHNldElzU3RhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBcbiAgLy8gVGVuYW50IHN0YXRlIHdpdGggZGVtbyBmYWxsYmFja1xuICBjb25zdCBbdGVuYW50LCBzZXRUZW5hbnRdID0gdXNlU3RhdGU8VGVuYW50IHwgbnVsbD4oe1xuICAgIGlkOiAnNTRhZmJkMWQtZTcyYS00MWUxLTlkMzktMmM4YTA4YTI1N2ZmJyxcbiAgICBuYW1lOiAnRGVtbyBDb21wYW55JyxcbiAgICBzbHVnOiAnZGVtby1jb21wYW55JyxcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH0pXG4gIFxuICAvLyBUZW5hbnQgdXNlciBzdGF0ZSB3aXRoIGRlbW8gZmFsbGJhY2tcbiAgY29uc3QgW3RlbmFudFVzZXIsIHNldFRlbmFudFVzZXJdID0gdXNlU3RhdGU8VGVuYW50VXNlciB8IG51bGw+KHtcbiAgICBpZDogJ2RlbW8tdGVuYW50LXVzZXItaWQnLFxuICAgIHRlbmFudF9pZDogJzU0YWZiZDFkLWU3MmEtNDFlMS05ZDM5LTJjOGEwOGEyNTdmZicsXG4gICAgdXNlcl9pZDogJ2RlbW8tdXNlci1pZCcsXG4gICAgcm9sZTogJ2NsaWVudF9hZG1pbicsIC8vIERlZmF1bHQgdG8gY2xpZW50X2FkbWluIGZvciBkZW1vXG4gICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfSlcblxuICAvLyBDb21wdXRlZCBwcm9wZXJ0aWVzIGZvciBSQkFDXG4gIGNvbnN0IGlzRGVtb01vZGUgPSAhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIHx8IFxuICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID09PSAnaHR0cHM6Ly9kZW1vLnN1cGFiYXNlLmNvJyB8fFxuICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMLmluY2x1ZGVzKCdwbGFjZWhvbGRlcicpXG4gIGNvbnN0IGlzQXV0aGVudGljYXRlZCA9ICEhdXNlciB8fCAhIXNlc3Npb24gfHwgaXNEZW1vTW9kZVxuICBjb25zdCBjdXJyZW50VXNlcklkID0gdXNlcj8uaWQgfHwgdGVuYW50VXNlcj8udXNlcl9pZCB8fCBudWxsXG4gIGNvbnN0IGN1cnJlbnRUZW5hbnRJZCA9IHRlbmFudD8uaWQgfHwgbnVsbFxuICBjb25zdCBjdXJyZW50VXNlclJvbGUgPSB0ZW5hbnRVc2VyPy5yb2xlIHx8IG51bGxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gdXBkYXRlIHNlcnZpY2UgYXV0aCBjb250ZXh0XG4gIGNvbnN0IHVwZGF0ZVNlcnZpY2VBdXRoQ29udGV4dCA9ICgpID0+IHtcbiAgICBzZXRTZXJ2aWNlQXV0aENvbnRleHQoe1xuICAgICAgdXNlcklkOiBjdXJyZW50VXNlcklkLFxuICAgICAgdGVuYW50SWQ6IGN1cnJlbnRUZW5hbnRJZCxcbiAgICAgIHVzZXJSb2xlOiBjdXJyZW50VXNlclJvbGUsXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQsXG4gICAgICBpc0RlbW9Nb2RlXG4gICAgfSlcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgYXV0aGVudGljYXRpb24gc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UkCBBdXRoUHJvdmlkZXI6IEluaXRpYWxpemluZyBhdXRoZW50aWNhdGlvbiBzdGF0ZScpXG4gICAgXG4gICAgY29uc3QgZ2V0SW5pdGlhbFNlc3Npb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbjogaW5pdGlhbFNlc3Npb24gfSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpXG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQXV0aFByb3ZpZGVyOiBFcnJvciBnZXR0aW5nIHNlc3Npb246JywgZXJyb3IpXG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGRlbW8gbW9kZVxuICAgICAgICAgIHNldFVzZXIoe1xuICAgICAgICAgICAgaWQ6ICdkZW1vLXVzZXItaWQnLFxuICAgICAgICAgICAgZW1haWw6ICdkZW1vQGNvbXBhbnkuY29tJyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGFwcF9tZXRhZGF0YToge30sXG4gICAgICAgICAgICB1c2VyX21ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIGF1ZDogJ2F1dGhlbnRpY2F0ZWQnLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uX3NlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0gYXMgdW5rbm93biBhcyBVc2VyKVxuICAgICAgICAgIFxuICAgICAgICAgIHNldFRlbmFudFVzZXIoe1xuICAgICAgICAgICAgaWQ6ICdkZW1vLXRlbmFudC11c2VyLWlkJyxcbiAgICAgICAgICAgIHRlbmFudF9pZDogJzU0YWZiZDFkLWU3MmEtNDFlMS05ZDM5LTJjOGEwOGEyNTdmZicsXG4gICAgICAgICAgICB1c2VyX2lkOiAnZGVtby11c2VyLWlkJyxcbiAgICAgICAgICAgIHJvbGU6ICdjbGllbnRfYWRtaW4nLFxuICAgICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2Vzc2lvbikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQXV0aFByb3ZpZGVyOiBGb3VuZCBleGlzdGluZyBzZXNzaW9uJylcbiAgICAgICAgICBzZXRTZXNzaW9uKGluaXRpYWxTZXNzaW9uKVxuICAgICAgICAgIHNldFVzZXIoaW5pdGlhbFNlc3Npb24udXNlcilcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdGVuYW50IHVzZXIgZm9yIGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgICAgICAgIHNldFRlbmFudFVzZXIoe1xuICAgICAgICAgICAgaWQ6ICdkZW1vLXRlbmFudC11c2VyLWlkJyxcbiAgICAgICAgICAgIHRlbmFudF9pZDogJzU0YWZiZDFkLWU3MmEtNDFlMS05ZDM5LTJjOGEwOGEyNTdmZicsXG4gICAgICAgICAgICB1c2VyX2lkOiBpbml0aWFsU2Vzc2lvbi51c2VyLmlkLFxuICAgICAgICAgICAgcm9sZTogJ2NsaWVudF9hZG1pbicsXG4gICAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQXV0aFByb3ZpZGVyOiBObyBleGlzdGluZyBzZXNzaW9uLCB1c2luZyBkZW1vIHVzZXInKVxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGRlbW8gdXNlciBmb3Igc3RhYmlsaXR5XG4gICAgICAgICAgc2V0VXNlcih7XG4gICAgICAgICAgICBpZDogJ2RlbW8tdXNlci1pZCcsXG4gICAgICAgICAgICBlbWFpbDogJ2RlbW9AY29tcGFueS5jb20nLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgYXBwX21ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIHVzZXJfbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgYXVkOiAnYXV0aGVudGljYXRlZCcsXG4gICAgICAgICAgICBjb25maXJtYXRpb25fc2VudF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSBhcyB1bmtub3duIGFzIFVzZXIpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IGRlbW8gdGVuYW50IHVzZXJcbiAgICAgICAgICBzZXRUZW5hbnRVc2VyKHtcbiAgICAgICAgICAgIGlkOiAnZGVtby10ZW5hbnQtdXNlci1pZCcsXG4gICAgICAgICAgICB0ZW5hbnRfaWQ6ICc1NGFmYmQxZC1lNzJhLTQxZTEtOWQzOS0yYzhhMDhhMjU3ZmYnLFxuICAgICAgICAgICAgdXNlcl9pZDogJ2RlbW8tdXNlci1pZCcsXG4gICAgICAgICAgICByb2xlOiAnY2xpZW50X2FkbWluJyxcbiAgICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICAgIHNldElzU3RhYmxlKHRydWUpXG4gICAgICAgIHVwZGF0ZVNlcnZpY2VBdXRoQ29udGV4dCgpXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgQXV0aFByb3ZpZGVyOiBBdXRoZW50aWNhdGlvbiBzdGF0ZSBzdGFiaWxpemVkJylcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQXV0aFByb3ZpZGVyOiBVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbjonLCBlcnJvcilcbiAgICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgc3RhYmxlIHN0YXRlXG4gICAgICAgIHNldFVzZXIobnVsbClcbiAgICAgICAgc2V0U2Vzc2lvbihudWxsKVxuICAgICAgICBzZXRUZW5hbnRVc2VyKHtcbiAgICAgICAgICBpZDogJ2RlbW8tdGVuYW50LXVzZXItaWQnLFxuICAgICAgICAgIHRlbmFudF9pZDogJzU0YWZiZDFkLWU3MmEtNDFlMS05ZDM5LTJjOGEwOGEyNTdmZicsXG4gICAgICAgICAgdXNlcl9pZDogJ2RlbW8tdXNlci1pZCcsXG4gICAgICAgICAgcm9sZTogJ2NsaWVudF9hZG1pbicsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgc2V0SXNTdGFibGUodHJ1ZSlcbiAgICAgICAgdXBkYXRlU2VydmljZUF1dGhDb250ZXh0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJbml0aWFsU2Vzc2lvbigpXG5cbiAgICAvLyBMaXN0ZW4gZm9yIGF1dGggY2hhbmdlc1xuICAgIGNvbnN0IHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9ID0gc3VwYWJhc2UuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShcbiAgICAgIGFzeW5jIChldmVudCwgbmV3U2Vzc2lvbikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBBdXRoUHJvdmlkZXI6IEF1dGggc3RhdGUgY2hhbmdlZDonLCBldmVudClcbiAgICAgICAgXG4gICAgICAgIGlmIChuZXdTZXNzaW9uKSB7XG4gICAgICAgICAgc2V0U2Vzc2lvbihuZXdTZXNzaW9uKVxuICAgICAgICAgIHNldFVzZXIobmV3U2Vzc2lvbi51c2VyKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB0ZW5hbnQgdXNlciBmb3IgYXV0aGVudGljYXRlZCB1c2VyXG4gICAgICAgICAgc2V0VGVuYW50VXNlcih7XG4gICAgICAgICAgICBpZDogJ2RlbW8tdGVuYW50LXVzZXItaWQnLFxuICAgICAgICAgICAgdGVuYW50X2lkOiAnNTRhZmJkMWQtZTcyYS00MWUxLTlkMzktMmM4YTA4YTI1N2ZmJyxcbiAgICAgICAgICAgIHVzZXJfaWQ6IG5ld1Nlc3Npb24udXNlci5pZCxcbiAgICAgICAgICAgIHJvbGU6ICdjbGllbnRfYWRtaW4nLFxuICAgICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIEF1dGhQcm92aWRlcjogVXNlciBzaWduZWQgb3V0LCBmYWxsaW5nIGJhY2sgdG8gZGVtbyB1c2VyJylcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBkZW1vIHVzZXIgZm9yIHN0YWJpbGl0eVxuICAgICAgICAgIHNldFVzZXIoe1xuICAgICAgICAgICAgaWQ6ICdkZW1vLXVzZXItaWQnLFxuICAgICAgICAgICAgZW1haWw6ICdkZW1vQGNvbXBhbnkuY29tJyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGFwcF9tZXRhZGF0YToge30sXG4gICAgICAgICAgICB1c2VyX21ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIGF1ZDogJ2F1dGhlbnRpY2F0ZWQnLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uX3NlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0gYXMgdW5rbm93biBhcyBVc2VyKVxuICAgICAgICAgIHNldFNlc3Npb24obnVsbClcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgZGVtbyB0ZW5hbnQgdXNlclxuICAgICAgICAgIHNldFRlbmFudFVzZXIoe1xuICAgICAgICAgICAgaWQ6ICdkZW1vLXRlbmFudC11c2VyLWlkJyxcbiAgICAgICAgICAgIHRlbmFudF9pZDogJzU0YWZiZDFkLWU3MmEtNDFlMS05ZDM5LTJjOGEwOGEyNTdmZicsXG4gICAgICAgICAgICB1c2VyX2lkOiAnZGVtby11c2VyLWlkJyxcbiAgICAgICAgICAgIHJvbGU6ICdjbGllbnRfYWRtaW4nLFxuICAgICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgc2V0SXNTdGFibGUodHJ1ZSlcbiAgICAgICAgdXBkYXRlU2VydmljZUF1dGhDb250ZXh0KClcbiAgICAgIH1cbiAgICApXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IHNpZ25JbiA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEF1dGhQcm92aWRlcjogU2lnbiBpbiBlcnJvcjonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBzaWduVXAgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25VcCh7XG4gICAgICAgIGVtYWlsLFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBBdXRoUHJvdmlkZXI6IFNpZ24gdXAgZXJyb3I6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2lnbk91dCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UkCBBdXRoUHJvdmlkZXI6IFNpZ25pbmcgb3V0JylcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KClcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgdG8gZGVtbyBzdGF0ZVxuICAgICAgc2V0VXNlcihudWxsKVxuICAgICAgc2V0U2Vzc2lvbihudWxsKVxuICAgICAgc2V0VGVuYW50VXNlcih7XG4gICAgICAgIGlkOiAnZGVtby10ZW5hbnQtdXNlci1pZCcsXG4gICAgICAgIHRlbmFudF9pZDogJzU0YWZiZDFkLWU3MmEtNDFlMS05ZDM5LTJjOGEwOGEyNTdmZicsXG4gICAgICAgIHVzZXJfaWQ6ICdkZW1vLXVzZXItaWQnLFxuICAgICAgICByb2xlOiAnY2xpZW50X2FkbWluJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICBzZXRJc1N0YWJsZSh0cnVlKVxuICAgICAgdXBkYXRlU2VydmljZUF1dGhDb250ZXh0KClcbiAgICAgIFxuICAgICAgLy8gUmVkaXJlY3QgdG8gbG9naW4gcGFnZVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbidcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEF1dGhQcm92aWRlcjogRXJyb3IgZHVyaW5nIHNpZ24gb3V0OicsIGVycm9yKVxuICAgICAgLy8gU3RpbGwgcmVkaXJlY3QgZXZlbiBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL2xvZ2luJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlZnJlc2hUZW5hbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/CflIQgQXV0aFByb3ZpZGVyOiBSZWZyZXNoaW5nIHRlbmFudCBpbmZvcm1hdGlvbicpXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGZldGNoIGZyZXNoIHRlbmFudCBkYXRhXG4gICAgLy8gRm9yIG5vdywgd2UgbWFpbnRhaW4gdGhlIGRlbW8gc3RhdGVcbiAgfVxuXG4gIGNvbnN0IHJlZnJlc2hTZXNzaW9uID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SEIEF1dGhQcm92aWRlcjogUmVmcmVzaGluZyBzZXNzaW9uJylcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVmcmVzaFNlc3Npb24oKVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBBdXRoUHJvdmlkZXI6IEVycm9yIHJlZnJlc2hpbmcgc2Vzc2lvbjonLCBlcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlc3Npb24oc2Vzc2lvbilcbiAgICAgICAgaWYgKHNlc3Npb24/LnVzZXIpIHtcbiAgICAgICAgICBzZXRVc2VyKHNlc3Npb24udXNlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQXV0aFByb3ZpZGVyOiBVbmV4cGVjdGVkIGVycm9yIHJlZnJlc2hpbmcgc2Vzc2lvbjonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWx1ZTogQXV0aENvbnRleHRUeXBlID0ge1xuICAgIHVzZXIsXG4gICAgdGVuYW50LFxuICAgIHRlbmFudFVzZXIsXG4gICAgc2Vzc2lvbixcbiAgICBsb2FkaW5nLFxuICAgIHNpZ25JbixcbiAgICBzaWduVXAsXG4gICAgc2lnbk91dCxcbiAgICByZWZyZXNoVGVuYW50LFxuICAgIHJlZnJlc2hTZXNzaW9uLFxuICAgIGlzU3RhYmxlLFxuICAgIGlzQXV0aGVudGljYXRlZCxcbiAgICBpc0RlbW9Nb2RlLFxuICAgIGN1cnJlbnRVc2VySWQsXG4gICAgY3VycmVudFRlbmFudElkLFxuICAgIGN1cnJlbnRVc2VyUm9sZVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBdXRoKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aENvbnRleHRcblxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJjcmVhdGVDbGllbnQiLCJzZXRTZXJ2aWNlQXV0aENvbnRleHQiLCJBdXRoQ29udGV4dCIsInVuZGVmaW5lZCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4iLCJzdXBhYmFzZSIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwidXNlciIsInNldFVzZXIiLCJzZXNzaW9uIiwic2V0U2Vzc2lvbiIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiaXNTdGFibGUiLCJzZXRJc1N0YWJsZSIsInRlbmFudCIsInNldFRlbmFudCIsImlkIiwibmFtZSIsInNsdWciLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZF9hdCIsInRlbmFudFVzZXIiLCJzZXRUZW5hbnRVc2VyIiwidGVuYW50X2lkIiwidXNlcl9pZCIsInJvbGUiLCJpc19hY3RpdmUiLCJpc0RlbW9Nb2RlIiwiaW5jbHVkZXMiLCJpc0F1dGhlbnRpY2F0ZWQiLCJjdXJyZW50VXNlcklkIiwiY3VycmVudFRlbmFudElkIiwiY3VycmVudFVzZXJSb2xlIiwidXBkYXRlU2VydmljZUF1dGhDb250ZXh0IiwidXNlcklkIiwidGVuYW50SWQiLCJ1c2VyUm9sZSIsImNvbnNvbGUiLCJsb2ciLCJnZXRJbml0aWFsU2Vzc2lvbiIsImRhdGEiLCJpbml0aWFsU2Vzc2lvbiIsImVycm9yIiwiYXV0aCIsImdldFNlc3Npb24iLCJlbWFpbCIsImFwcF9tZXRhZGF0YSIsInVzZXJfbWV0YWRhdGEiLCJhdWQiLCJjb25maXJtYXRpb25fc2VudF9hdCIsInN1YnNjcmlwdGlvbiIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJuZXdTZXNzaW9uIiwidW5zdWJzY3JpYmUiLCJzaWduSW4iLCJwYXNzd29yZCIsInNpZ25JbldpdGhQYXNzd29yZCIsInNpZ25VcCIsInNpZ25PdXQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJyZWZyZXNoVGVuYW50IiwicmVmcmVzaFNlc3Npb24iLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlQXV0aCIsImNvbnRleHQiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/AuthContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   mfaManagement: () => (/* binding */ mfaManagement),\n/* harmony export */   signInWithRole: () => (/* binding */ signInWithRole),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   userManagement: () => (/* binding */ userManagement)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst supabaseUrl = \"https://your-project.supabase.co\";\nconst supabaseAnonKey = \"your_anon_token_here\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Export createClient function for compatibility\nconst createClient = ()=>(0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Auth helpers\nconst signInWithRole = async (email, password)=>{\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (data.user) {\n        // Get user profile with role and tenant\n        const { data: profile } = await supabase.from('users').select('role, tenant_id, first_name, last_name').eq('id', data.user.id).single();\n        return {\n            user: data.user,\n            profile,\n            error\n        };\n    }\n    return {\n        user: null,\n        profile: null,\n        error\n    };\n};\nconst signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    return {\n        error\n    };\n};\n// Database helpers\nconst getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data: profile } = await supabase.from('users').select('*').eq('id', user.id).single();\n    return {\n        ...user,\n        profile\n    };\n};\n// User Management Methods\nconst userManagement = {\n    // Create a new user with complete RBAC setup\n    createUser: async (userData)=>{\n        try {\n            // First, create the auth user\n            const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n                email: userData.email,\n                password: userData.password,\n                email_confirm: true,\n                user_metadata: {\n                    full_name: userData.full_name,\n                    role: userData.role,\n                    role_level: userData.role_level\n                }\n            });\n            if (authError) {\n                return {\n                    success: false,\n                    error: authError.message\n                };\n            }\n            if (!authData.user) {\n                return {\n                    success: false,\n                    error: 'Failed to create user account'\n                };\n            }\n            // Create the user profile (FIXED: using 'profiles' not 'user_profiles')\n            const { error: profileError } = await supabase.from('profiles').insert({\n                id: authData.user.id,\n                email: userData.email,\n                full_name: userData.full_name,\n                phone: userData.phone,\n                department: userData.department,\n                job_title: userData.job_title,\n                role: userData.role,\n                role_level: userData.role_level,\n                tenant_id: userData.tenant_id,\n                is_active: true,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (profileError) {\n                // If profile creation fails, clean up the auth user\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                return {\n                    success: false,\n                    error: \"Profile creation failed: \".concat(profileError.message)\n                };\n            }\n            // NEW: Create tenant_users record for RBAC\n            const { error: tenantUserError } = await supabase.from('tenant_users').insert({\n                tenant_id: userData.tenant_id,\n                user_id: authData.user.id,\n                role: userData.role,\n                role_level: userData.role_level,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (tenantUserError) {\n                // If tenant_users creation fails, clean up auth user and profile\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                await supabase.from('profiles').delete().eq('id', authData.user.id);\n                return {\n                    success: false,\n                    error: \"Tenant assignment failed: \".concat(tenantUserError.message)\n                };\n            }\n            // OPTIONAL: Create audit log if table exists\n            try {\n                await supabase.from('audit_logs').insert({\n                    user_id: authData.user.id,\n                    tenant_id: userData.tenant_id,\n                    action: 'user_created',\n                    resource_type: 'user',\n                    resource_id: authData.user.id,\n                    details: {\n                        created_by: 'admin_interface',\n                        role: userData.role,\n                        role_level: userData.role_level,\n                        email: userData.email\n                    },\n                    ip_address: '127.0.0.1',\n                    user_agent: 'Admin Interface',\n                    severity: 'info',\n                    created_at: new Date().toISOString()\n                });\n            } catch (auditError) {\n                // Audit log is optional, don't fail the user creation\n                console.warn('Audit log creation failed:', auditError);\n            }\n            return {\n                success: true,\n                data: authData.user\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to create user'\n            };\n        }\n    },\n    // Invite users via email\n    inviteUsers: async (invitationData)=>{\n        try {\n            const invitations = [];\n            for (const email of invitationData.emails){\n                // Create invitation record\n                const { data: invitation, error: inviteError } = await supabase.from('user_invitations').insert({\n                    email,\n                    role: invitationData.role,\n                    role_level: invitationData.role_level,\n                    tenant_id: invitationData.tenant_id,\n                    message: invitationData.message,\n                    expires_at: new Date(Date.now() + invitationData.expires_in_days * 24 * 60 * 60 * 1000).toISOString(),\n                    created_at: new Date().toISOString()\n                }).select().single();\n                if (inviteError) {\n                    console.error(\"Failed to create invitation for \".concat(email, \":\"), inviteError);\n                    continue;\n                }\n                // Send invitation email using Supabase Auth\n                const { error: emailError } = await supabase.auth.admin.inviteUserByEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/accept-invitation?token=\").concat(invitation.id),\n                    data: {\n                        role: invitationData.role,\n                        role_level: invitationData.role_level,\n                        tenant_id: invitationData.tenant_id,\n                        invitation_id: invitation.id\n                    }\n                });\n                if (emailError) {\n                    console.error(\"Failed to send invitation email to \".concat(email, \":\"), emailError);\n                    // Mark invitation as failed\n                    await supabase.from('user_invitations').update({\n                        status: 'failed'\n                    }).eq('id', invitation.id);\n                } else {\n                    invitations.push(invitation);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    sent: invitations.length,\n                    total: invitationData.emails.length\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to send invitations'\n            };\n        }\n    },\n    // Update user information\n    updateUser: async (userId, updateData)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                ...updateData,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to update user'\n            };\n        }\n    },\n    // Deactivate user\n    deactivateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: false,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to deactivate user'\n            };\n        }\n    },\n    // Activate user\n    activateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: true,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to activate user'\n            };\n        }\n    },\n    // Reset user password\n    resetUserPassword: async (email, newPassword)=>{\n        try {\n            if (newPassword) {\n                // Direct password reset (admin function)\n                const { error } = await supabase.auth.admin.updateUserById(email, {\n                    password: newPassword\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            } else {\n                // Email-based password reset\n                const { error } = await supabase.auth.resetPasswordForEmail(email, {\n                    redirectTo: \"\".concat(window.location.origin, \"/reset-password\")\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to reset password'\n            };\n        }\n    },\n    // Preview cleanup operations\n    previewUserCleanup: async (options)=>{\n        try {\n            let inactiveUsers = 0;\n            let unconfirmedUsers = 0;\n            let expiredInvites = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('profiles').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('last_login', cutoffDate).eq('is_active', true);\n                inactiveUsers = count || 0;\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('auth.users').select('*', {\n                    count: 'exact',\n                    head: true\n                }).is('email_confirmed_at', null).lt('created_at', cutoffDate);\n                unconfirmedUsers = count || 0;\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                expiredInvites = count || 0;\n            }\n            const totalToDelete = inactiveUsers + unconfirmedUsers + expiredInvites;\n            return {\n                success: true,\n                data: {\n                    inactiveUsers,\n                    unconfirmedUsers,\n                    expiredInvites,\n                    totalToDelete\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to preview cleanup'\n            };\n        }\n    },\n    // Execute cleanup operations\n    executeUserCleanup: async (options)=>{\n        try {\n            let deletedCount = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                // Get inactive users\n                const { data: inactiveUsers } = await supabase.from('profiles').select('id').lt('last_login', cutoffDate).eq('is_active', true);\n                if (inactiveUsers) {\n                    for (const user of inactiveUsers){\n                        // Delete auth user\n                        await supabase.auth.admin.deleteUser(user.id);\n                        // Delete profile\n                        await supabase.from('profiles').delete().eq('id', user.id);\n                    }\n                    deletedCount += inactiveUsers.length;\n                }\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                // This would require admin access to auth.users table\n                // For now, we'll mark them as inactive\n                const { data: unconfirmedUsers } = await supabase.from('profiles').select('id').lt('created_at', cutoffDate).eq('is_active', true);\n                if (unconfirmedUsers) {\n                    await supabase.from('profiles').update({\n                        is_active: false\n                    }).in('id', unconfirmedUsers.map((u)=>u.id));\n                    deletedCount += unconfirmedUsers.length;\n                }\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').delete().lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                deletedCount += count || 0;\n            }\n            return {\n                success: true,\n                data: {\n                    deletedCount\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to execute cleanup'\n            };\n        }\n    }\n};\nconst mfaManagement = {\n    // Check if user has MFA enabled\n    checkMFAStatus: async (userId)=>{\n        try {\n            const { data, error } = await supabase.from('profiles').select('mfa_enabled').eq('id', userId).single();\n            if (error) throw error;\n            return {\n                mfaEnabled: (data === null || data === void 0 ? void 0 : data.mfa_enabled) || false\n            };\n        } catch (error) {\n            console.error('Error checking MFA status:', error);\n            return {\n                mfaEnabled: false,\n                error: error.message\n            };\n        }\n    },\n    // Enable MFA for user\n    enableMFA: async ()=>{\n        try {\n            // Enroll for TOTP MFA\n            const { data, error } = await supabase.auth.mfa.enroll({\n                factorType: 'totp',\n                friendlyName: 'ETLA Platform TOTP'\n            });\n            if (error) throw error;\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error enabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify MFA setup\n    verifyMFASetup: async (factorId, code)=>{\n        try {\n            // Create challenge first\n            const { data: challenge, error: challengeError } = await supabase.auth.mfa.challenge({\n                factorId\n            });\n            if (challengeError) throw challengeError;\n            // Verify the code\n            const { data, error } = await supabase.auth.mfa.verify({\n                factorId,\n                challengeId: challenge.id,\n                code\n            });\n            if (error) throw error;\n            // Update user profile to indicate MFA is enabled\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: true,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error verifying MFA setup:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Disable MFA for user\n    disableMFA: async ()=>{\n        try {\n            // Get all factors\n            const { data: factors, error: factorsError } = await supabase.auth.mfa.listFactors();\n            if (factorsError) throw factorsError;\n            // Unenroll all TOTP factors\n            if (factors === null || factors === void 0 ? void 0 : factors.totp) {\n                for (const factor of factors.totp){\n                    await supabase.auth.mfa.unenroll({\n                        factorId: factor.id\n                    });\n                }\n            }\n            // Update user profile\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: false,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error('Error disabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Generate backup codes (simulated - in production this would be handled by your backend)\n    generateBackupCodes: async ()=>{\n        try {\n            // Generate 8 backup codes\n            const codes = Array.from({\n                length: 8\n            }, ()=>Math.random().toString(36).substring(2, 8).toUpperCase());\n            // In production, you would store these securely in your backend\n            // For now, we'll just return them\n            return {\n                success: true,\n                codes\n            };\n        } catch (error) {\n            console.error('Error generating backup codes:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify backup code (simulated - in production this would verify against stored codes)\n    verifyBackupCode: async (code)=>{\n        try {\n            // In production, you would verify this against stored backup codes\n            // For demo purposes, we'll accept any 6+ character code\n            if (code.length >= 6) {\n                return {\n                    success: true\n                };\n            } else {\n                throw new Error('Invalid backup code');\n            }\n        } catch (error) {\n            console.error('Error verifying backup code:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n};\n// Add user management methods to the main supabase object for backward compatibility\nObject.assign(supabase, userManagement);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLEdBQUdDLFdBQVc7WUFHeEQsZ0VBQWdFO1lBQ2hFLGtDQUFrQztZQUNsQyxPQUFPO2dCQUFFbEgsU0FBUztnQkFBTTRHO1lBQU07UUFDaEMsRUFBRSxPQUFPcEksT0FBWTtZQUNuQnFELFFBQVFyRCxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxPQUFPO2dCQUFFd0IsU0FBUztnQkFBT3hCLE9BQU9BLE1BQU15QixPQUFPO1lBQUM7UUFDaEQ7SUFDRjtJQUVBLHdGQUF3RjtJQUN4RmtILGtCQUFrQixPQUFPcEI7UUFDdkIsSUFBSTtZQUNGLG1FQUFtRTtZQUNuRSx3REFBd0Q7WUFDeEQsSUFBSUEsS0FBSzVDLE1BQU0sSUFBSSxHQUFHO2dCQUNwQixPQUFPO29CQUFFbkQsU0FBUztnQkFBSztZQUN6QixPQUFPO2dCQUNMLE1BQU0sSUFBSW9ILE1BQU07WUFDbEI7UUFDRixFQUFFLE9BQU81SSxPQUFZO1lBQ25CcUQsUUFBUXJELEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDLE9BQU87Z0JBQUV3QixTQUFTO2dCQUFPeEIsT0FBT0EsTUFBTXlCLE9BQU87WUFBQztRQUNoRDtJQUNGO0FBQ0YsRUFBQztBQUVELHFGQUFxRjtBQUNyRm9ILE9BQU9DLE1BQU0sQ0FBQ25KLFVBQVVrQiIsInNvdXJjZXMiOlsiL2hvbWUvdWJ1bnR1L0VUTEEtUGxhdGZvcm0vZnJvbnRlbmQvc3JjL2xpYi9zdXBhYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvc3VwYWJhc2UudHNcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCBhcyBjcmVhdGVTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX1RPS0VOIVxuXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuXG4vLyBFeHBvcnQgY3JlYXRlQ2xpZW50IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5XG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gKCkgPT4gY3JlYXRlU3VwYWJhc2VDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSlcblxuLy8gRGF0YWJhc2UgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgV29ya1JlcXVlc3Qge1xuICBpZDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBjYXRlZ29yeTogc3RyaW5nXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJ1xuICB1cmdlbmN5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ3VyZ2VudCdcbiAgc3RhdHVzOiAnc3VibWl0dGVkJyB8ICd1bmRlcl9yZXZpZXcnIHwgJ2FwcHJvdmVkJyB8ICdyZWplY3RlZCcgfCAnc2NoZWR1bGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnXG4gIGN1c3RvbWVyX2lkOiBzdHJpbmdcbiAgYXNzaWduZWRfdG8/OiBzdHJpbmdcbiAgZXN0aW1hdGVkX2hvdXJzPzogbnVtYmVyXG4gIGFjdHVhbF9ob3VyczogbnVtYmVyXG4gIGJ1ZGdldD86IG51bWJlclxuICByZXF1aXJlZF9jb21wbGV0aW9uX2RhdGU/OiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3Qge1xuICBpZDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHdvcmtfcmVxdWVzdF9pZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgc3RhdHVzOiAnc2NoZWR1bGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdvbl9ob2xkJyB8ICdjYW5jZWxsZWQnXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJ1xuICBhc3NpZ25lZF90ZWFtX2xlYWQ6IHN0cmluZ1xuICBlc3RpbWF0ZWRfaG91cnM6IG51bWJlclxuICBhY3R1YWxfaG91cnM6IG51bWJlclxuICBidWRnZXQ/OiBudW1iZXJcbiAgc3RhcnRfZGF0ZTogc3RyaW5nXG4gIGVuZF9kYXRlOiBzdHJpbmdcbiAgY29tcGxldGlvbl9wZXJjZW50YWdlOiBudW1iZXJcbiAgY2xpZW50X3NhdGlzZmFjdGlvbl9zY29yZT86IG51bWJlclxuICBvbl90aW1lX2RlbGl2ZXJ5PzogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBjb21wYW55X25hbWU6IHN0cmluZ1xuICBzdWJkb21haW4/OiBzdHJpbmdcbiAgaW5kdXN0cnk/OiBzdHJpbmdcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICd0cmlhbCcgfCAnc3VzcGVuZGVkJyB8ICdjYW5jZWxsZWQnXG4gIHN1YnNjcmlwdGlvbl9wbGFuOiAndHJpYWwnIHwgJ3Byb2Zlc3Npb25hbCcgfCAnZW50ZXJwcmlzZSdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBmaXJzdF9uYW1lOiBzdHJpbmdcbiAgbGFzdF9uYW1lOiBzdHJpbmdcbiAgcm9sZTogJ2hvc3RfYWRtaW4nIHwgJ3Byb2dyYW1fbWFuYWdlcicgfCAnY2xpZW50X2FkbWluJyB8ICdjbGllbnRfdXNlcidcbiAgdGVuYW50X2lkPzogc3RyaW5nXG4gIGlzX2FjdGl2ZTogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbn1cblxuLy8gRXh0ZW5kZWQgVXNlciBpbnRlcmZhY2UgZm9yIHVzZXIgbWFuYWdlbWVudFxuZXhwb3J0IGludGVyZmFjZSBFeHRlbmRlZFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZnVsbF9uYW1lOiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZTogc3RyaW5nXG4gIHJvbGVfbGV2ZWw6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICB0ZW5hbnRfbmFtZT86IHN0cmluZ1xuICBpc19hY3RpdmU6IGJvb2xlYW5cbiAgY2FuX2ludml0ZV91c2VyczogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU6IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGxhc3RfbG9naW4/OiBzdHJpbmdcbn1cblxuLy8gVXNlciBjcmVhdGlvbiBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBVc2VyQ3JlYXRpb25EYXRhIHtcbiAgZW1haWw6IHN0cmluZ1xuICBmdWxsX25hbWU6IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBkZXBhcnRtZW50Pzogc3RyaW5nXG4gIGpvYl90aXRsZT86IHN0cmluZ1xuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHBhc3N3b3JkOiBzdHJpbmdcbiAgY2FuX2ludml0ZV91c2VyczogYm9vbGVhblxuICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU6IHN0cmluZ1xufVxuXG4vLyBVc2VyIGludml0YXRpb24gZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlckludml0YXRpb25EYXRhIHtcbiAgZW1haWxzOiBzdHJpbmdbXVxuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbiAgZXhwaXJlc19pbl9kYXlzOiBudW1iZXJcbn1cblxuLy8gVXNlciB1cGRhdGUgZGF0YSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclVwZGF0ZURhdGEge1xuICBmdWxsX25hbWU/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgZGVwYXJ0bWVudD86IHN0cmluZ1xuICBqb2JfdGl0bGU/OiBzdHJpbmdcbiAgcm9sZT86IHN0cmluZ1xuICByb2xlX2xldmVsPzogc3RyaW5nXG4gIHRlbmFudF9pZD86IHN0cmluZ1xuICBpc19hY3RpdmU/OiBib29sZWFuXG4gIGNhbl9pbnZpdGVfdXNlcnM/OiBib29sZWFuXG4gIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM/OiBib29sZWFuXG4gIHBlcm1pc3Npb25fc2NvcGU/OiBzdHJpbmdcbn1cblxuLy8gQ2xlYW51cCBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBDbGVhbnVwT3B0aW9ucyB7XG4gIGRlbGV0ZUluYWN0aXZlVXNlcnM6IGJvb2xlYW5cbiAgZGVsZXRlVW5jb25maXJtZWRVc2VyczogYm9vbGVhblxuICBkZWxldGVFeHBpcmVkSW52aXRlczogYm9vbGVhblxuICBpbmFjdGl2ZURheXM6IG51bWJlclxuICB1bmNvbmZpcm1lZERheXM6IG51bWJlclxufVxuXG4vLyBBdXRoIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzaWduSW5XaXRoUm9sZSA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZFxuICB9KVxuICBcbiAgaWYgKGRhdGEudXNlcikge1xuICAgIC8vIEdldCB1c2VyIHByb2ZpbGUgd2l0aCByb2xlIGFuZCB0ZW5hbnRcbiAgICBjb25zdCB7IGRhdGE6IHByb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgncm9sZSwgdGVuYW50X2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUnKVxuICAgICAgLmVxKCdpZCcsIGRhdGEudXNlci5pZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIFxuICAgIHJldHVybiB7IHVzZXI6IGRhdGEudXNlciwgcHJvZmlsZSwgZXJyb3IgfVxuICB9XG4gIFxuICByZXR1cm4geyB1c2VyOiBudWxsLCBwcm9maWxlOiBudWxsLCBlcnJvciB9XG59XG5cbmV4cG9ydCBjb25zdCBzaWduT3V0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKVxuICByZXR1cm4geyBlcnJvciB9XG59XG5cbi8vIERhdGFiYXNlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VXNlciA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgaWYgKCF1c2VyKSByZXR1cm4gbnVsbFxuICBcbiAgY29uc3QgeyBkYXRhOiBwcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCd1c2VycycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgLnNpbmdsZSgpXG4gIFxuICByZXR1cm4geyAuLi51c2VyLCBwcm9maWxlIH1cbn1cblxuLy8gVXNlciBNYW5hZ2VtZW50IE1ldGhvZHNcbmV4cG9ydCBjb25zdCB1c2VyTWFuYWdlbWVudCA9IHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHVzZXIgd2l0aCBjb21wbGV0ZSBSQkFDIHNldHVwXG4gIGNyZWF0ZVVzZXI6IGFzeW5jICh1c2VyRGF0YTogVXNlckNyZWF0aW9uRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCwgY3JlYXRlIHRoZSBhdXRoIHVzZXJcbiAgICAgIGNvbnN0IHsgZGF0YTogYXV0aERhdGEsIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uY3JlYXRlVXNlcih7XG4gICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgICAgcGFzc3dvcmQ6IHVzZXJEYXRhLnBhc3N3b3JkLFxuICAgICAgICBlbWFpbF9jb25maXJtOiB0cnVlLFxuICAgICAgICB1c2VyX21ldGFkYXRhOiB7XG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChhdXRoRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBhdXRoRXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXV0aERhdGEudXNlcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIHVzZXIgYWNjb3VudCcgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHVzZXIgcHJvZmlsZSAoRklYRUQ6IHVzaW5nICdwcm9maWxlcycgbm90ICd1c2VyX3Byb2ZpbGVzJylcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHByb2ZpbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICAgIGZ1bGxfbmFtZTogdXNlckRhdGEuZnVsbF9uYW1lLFxuICAgICAgICAgIHBob25lOiB1c2VyRGF0YS5waG9uZSxcbiAgICAgICAgICBkZXBhcnRtZW50OiB1c2VyRGF0YS5kZXBhcnRtZW50LFxuICAgICAgICAgIGpvYl90aXRsZTogdXNlckRhdGEuam9iX3RpdGxlLFxuICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgcm9sZV9sZXZlbDogdXNlckRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICB0ZW5hbnRfaWQ6IHVzZXJEYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgY2FuX2ludml0ZV91c2VyczogdXNlckRhdGEuY2FuX2ludml0ZV91c2VycyxcbiAgICAgICAgICBjYW5fbWFuYWdlX3N1Yl9jbGllbnRzOiB1c2VyRGF0YS5jYW5fbWFuYWdlX3N1Yl9jbGllbnRzLFxuICAgICAgICAgIHBlcm1pc3Npb25fc2NvcGU6IHVzZXJEYXRhLnBlcm1pc3Npb25fc2NvcGUsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuXG4gICAgICBpZiAocHJvZmlsZUVycm9yKSB7XG4gICAgICAgIC8vIElmIHByb2ZpbGUgY3JlYXRpb24gZmFpbHMsIGNsZWFuIHVwIHRoZSBhdXRoIHVzZXJcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFByb2ZpbGUgY3JlYXRpb24gZmFpbGVkOiAke3Byb2ZpbGVFcnJvci5tZXNzYWdlfWAgfVxuICAgICAgfVxuXG4gICAgICAvLyBORVc6IENyZWF0ZSB0ZW5hbnRfdXNlcnMgcmVjb3JkIGZvciBSQkFDXG4gICAgICBjb25zdCB7IGVycm9yOiB0ZW5hbnRVc2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0ZW5hbnRfdXNlcnMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB0ZW5hbnRfaWQ6IHVzZXJEYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICB1c2VyX2lkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgcm9sZV9sZXZlbDogdXNlckRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICBjYW5faW52aXRlX3VzZXJzOiB1c2VyRGF0YS5jYW5faW52aXRlX3VzZXJzLFxuICAgICAgICAgIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IHVzZXJEYXRhLmNhbl9tYW5hZ2Vfc3ViX2NsaWVudHMsXG4gICAgICAgICAgcGVybWlzc2lvbl9zY29wZTogdXNlckRhdGEucGVybWlzc2lvbl9zY29wZSxcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuXG4gICAgICBpZiAodGVuYW50VXNlckVycm9yKSB7XG4gICAgICAgIC8vIElmIHRlbmFudF91c2VycyBjcmVhdGlvbiBmYWlscywgY2xlYW4gdXAgYXV0aCB1c2VyIGFuZCBwcm9maWxlXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uZGVsZXRlVXNlcihhdXRoRGF0YS51c2VyLmlkKVxuICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLmRlbGV0ZSgpLmVxKCdpZCcsIGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFRlbmFudCBhc3NpZ25tZW50IGZhaWxlZDogJHt0ZW5hbnRVc2VyRXJyb3IubWVzc2FnZX1gIH1cbiAgICAgIH1cblxuICAgICAgLy8gT1BUSU9OQUw6IENyZWF0ZSBhdWRpdCBsb2cgaWYgdGFibGUgZXhpc3RzXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdhdWRpdF9sb2dzJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgICB0ZW5hbnRfaWQ6IHVzZXJEYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJfY3JlYXRlZCcsXG4gICAgICAgICAgICByZXNvdXJjZV90eXBlOiAndXNlcicsXG4gICAgICAgICAgICByZXNvdXJjZV9pZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgY3JlYXRlZF9ieTogJ2FkbWluX2ludGVyZmFjZScsXG4gICAgICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXG4gICAgICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlwX2FkZHJlc3M6ICcxMjcuMC4wLjEnLFxuICAgICAgICAgICAgdXNlcl9hZ2VudDogJ0FkbWluIEludGVyZmFjZScsXG4gICAgICAgICAgICBzZXZlcml0eTogJ2luZm8nLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGF1ZGl0RXJyb3IpIHtcbiAgICAgICAgLy8gQXVkaXQgbG9nIGlzIG9wdGlvbmFsLCBkb24ndCBmYWlsIHRoZSB1c2VyIGNyZWF0aW9uXG4gICAgICAgIGNvbnNvbGUud2FybignQXVkaXQgbG9nIGNyZWF0aW9uIGZhaWxlZDonLCBhdWRpdEVycm9yKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBhdXRoRGF0YS51c2VyIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBJbnZpdGUgdXNlcnMgdmlhIGVtYWlsXG4gIGludml0ZVVzZXJzOiBhc3luYyAoaW52aXRhdGlvbkRhdGE6IFVzZXJJbnZpdGF0aW9uRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnZpdGF0aW9ucyA9IFtdXG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgaW52aXRhdGlvbkRhdGEuZW1haWxzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbnZpdGF0aW9uIHJlY29yZFxuICAgICAgICBjb25zdCB7IGRhdGE6IGludml0YXRpb24sIGVycm9yOiBpbnZpdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHJvbGU6IGludml0YXRpb25EYXRhLnJvbGUsXG4gICAgICAgICAgICByb2xlX2xldmVsOiBpbnZpdGF0aW9uRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgICAgdGVuYW50X2lkOiBpbnZpdGF0aW9uRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBpbnZpdGF0aW9uRGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIGludml0YXRpb25EYXRhLmV4cGlyZXNfaW5fZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGlmIChpbnZpdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgaW52aXRhdGlvbiBmb3IgJHtlbWFpbH06YCwgaW52aXRlRXJyb3IpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgaW52aXRhdGlvbiBlbWFpbCB1c2luZyBTdXBhYmFzZSBBdXRoXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGVtYWlsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4uaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIHtcbiAgICAgICAgICByZWRpcmVjdFRvOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hY2NlcHQtaW52aXRhdGlvbj90b2tlbj0ke2ludml0YXRpb24uaWR9YCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByb2xlOiBpbnZpdGF0aW9uRGF0YS5yb2xlLFxuICAgICAgICAgICAgcm9sZV9sZXZlbDogaW52aXRhdGlvbkRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICAgIHRlbmFudF9pZDogaW52aXRhdGlvbkRhdGEudGVuYW50X2lkLFxuICAgICAgICAgICAgaW52aXRhdGlvbl9pZDogaW52aXRhdGlvbi5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZW1haWxFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzZW5kIGludml0YXRpb24gZW1haWwgdG8gJHtlbWFpbH06YCwgZW1haWxFcnJvcilcbiAgICAgICAgICAvLyBNYXJrIGludml0YXRpb24gYXMgZmFpbGVkXG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAgIC51cGRhdGUoeyBzdGF0dXM6ICdmYWlsZWQnIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbi5pZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZpdGF0aW9ucy5wdXNoKGludml0YXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgICBkYXRhOiB7IFxuICAgICAgICAgIHNlbnQ6IGludml0YXRpb25zLmxlbmd0aCwgXG4gICAgICAgICAgdG90YWw6IGludml0YXRpb25EYXRhLmVtYWlscy5sZW5ndGggXG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc2VuZCBpbnZpdGF0aW9ucycgfVxuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgdXNlciBpbmZvcm1hdGlvblxuICB1cGRhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFVzZXJVcGRhdGVEYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIC4uLnVwZGF0ZURhdGEsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBEZWFjdGl2YXRlIHVzZXJcbiAgZGVhY3RpdmF0ZVVzZXI6IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBpc19hY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVhY3RpdmF0ZSB1c2VyJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEFjdGl2YXRlIHVzZXJcbiAgYWN0aXZhdGVVc2VyOiBhc3luYyAodXNlcklkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYWN0aXZhdGUgdXNlcicgfVxuICAgIH1cbiAgfSxcblxuICAvLyBSZXNldCB1c2VyIHBhc3N3b3JkXG4gIHJlc2V0VXNlclBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZywgbmV3UGFzc3dvcmQ/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5ld1Bhc3N3b3JkKSB7XG4gICAgICAgIC8vIERpcmVjdCBwYXNzd29yZCByZXNldCAoYWRtaW4gZnVuY3Rpb24pXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguYWRtaW4udXBkYXRlVXNlckJ5SWQoXG4gICAgICAgICAgZW1haWwsIC8vIFRoaXMgc2hvdWxkIGJlIHVzZXIgSUQsIGJ1dCB3ZSdsbCBuZWVkIHRvIGdldCBpdCBmaXJzdFxuICAgICAgICAgIHsgcGFzc3dvcmQ6IG5ld1Bhc3N3b3JkIH1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtYWlsLWJhc2VkIHBhc3N3b3JkIHJlc2V0XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVzZXRQYXNzd29yZEZvckVtYWlsKGVtYWlsLCB7XG4gICAgICAgICAgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vcmVzZXQtcGFzc3dvcmRgXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHJlc2V0IHBhc3N3b3JkJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFByZXZpZXcgY2xlYW51cCBvcGVyYXRpb25zXG4gIHByZXZpZXdVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpbmFjdGl2ZVVzZXJzID0gMFxuICAgICAgbGV0IHVuY29uZmlybWVkVXNlcnMgPSAwXG4gICAgICBsZXQgZXhwaXJlZEludml0ZXMgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmx0KCdsYXN0X2xvZ2luJywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaW5hY3RpdmVVc2VycyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlVW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMudW5jb25maXJtZWREYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdhdXRoLnVzZXJzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5pcygnZW1haWxfY29uZmlybWVkX2F0JywgbnVsbClcbiAgICAgICAgICAubHQoJ2NyZWF0ZWRfYXQnLCBjdXRvZmZEYXRlKVxuXG4gICAgICAgIHVuY29uZmlybWVkVXNlcnMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUV4cGlyZWRJbnZpdGVzKSB7XG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgICAgIC5uZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG5cbiAgICAgICAgZXhwaXJlZEludml0ZXMgPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsVG9EZWxldGUgPSBpbmFjdGl2ZVVzZXJzICsgdW5jb25maXJtZWRVc2VycyArIGV4cGlyZWRJbnZpdGVzXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmFjdGl2ZVVzZXJzLFxuICAgICAgICAgIHVuY29uZmlybWVkVXNlcnMsXG4gICAgICAgICAgZXhwaXJlZEludml0ZXMsXG4gICAgICAgICAgdG90YWxUb0RlbGV0ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJldmlldyBjbGVhbnVwJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEV4ZWN1dGUgY2xlYW51cCBvcGVyYXRpb25zXG4gIGV4ZWN1dGVVc2VyQ2xlYW51cDogYXN5bmMgKG9wdGlvbnM6IENsZWFudXBPcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZWxldGVkQ291bnQgPSAwXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLmluYWN0aXZlRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBpbmFjdGl2ZSB1c2Vyc1xuICAgICAgICBjb25zdCB7IGRhdGE6IGluYWN0aXZlVXNlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgLmx0KCdsYXN0X2xvZ2luJywgY3V0b2ZmRGF0ZSlcbiAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgICAgaWYgKGluYWN0aXZlVXNlcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHVzZXIgb2YgaW5hY3RpdmVVc2Vycykge1xuICAgICAgICAgICAgLy8gRGVsZXRlIGF1dGggdXNlclxuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKHVzZXIuaWQpXG4gICAgICAgICAgICAvLyBEZWxldGUgcHJvZmlsZVxuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGVkQ291bnQgKz0gaW5hY3RpdmVVc2Vycy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVVbmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy51bmNvbmZpcm1lZERheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIFxuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgYWRtaW4gYWNjZXNzIHRvIGF1dGgudXNlcnMgdGFibGVcbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgbWFyayB0aGVtIGFzIGluYWN0aXZlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogdW5jb25maXJtZWRVc2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAubHQoJ2NyZWF0ZWRfYXQnLCBjdXRvZmZEYXRlKVxuICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICAgICAgICBpZiAodW5jb25maXJtZWRVc2Vycykge1xuICAgICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7IGlzX2FjdGl2ZTogZmFsc2UgfSlcbiAgICAgICAgICAgIC5pbignaWQnLCB1bmNvbmZpcm1lZFVzZXJzLm1hcCh1ID0+IHUuaWQpKVxuICAgICAgICAgIFxuICAgICAgICAgIGRlbGV0ZWRDb3VudCArPSB1bmNvbmZpcm1lZFVzZXJzLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZUV4cGlyZWRJbnZpdGVzKSB7XG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5sdCgnZXhwaXJlc19hdCcsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgICAgICAubmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuXG4gICAgICAgIGRlbGV0ZWRDb3VudCArPSBjb3VudCB8fCAwXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgZGVsZXRlZENvdW50IH0gfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGV4ZWN1dGUgY2xlYW51cCcgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWZhTWFuYWdlbWVudCA9IHtcbiAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgTUZBIGVuYWJsZWRcbiAgY2hlY2tNRkFTdGF0dXM6IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAuc2VsZWN0KCdtZmFfZW5hYmxlZCcpXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBtZmFFbmFibGVkOiBkYXRhPy5tZmFfZW5hYmxlZCB8fCBmYWxzZSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgTUZBIHN0YXR1czonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IG1mYUVuYWJsZWQ6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEVuYWJsZSBNRkEgZm9yIHVzZXJcbiAgZW5hYmxlTUZBOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVucm9sbCBmb3IgVE9UUCBNRkFcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLmVucm9sbCh7XG4gICAgICAgIGZhY3RvclR5cGU6ICd0b3RwJyxcbiAgICAgICAgZnJpZW5kbHlOYW1lOiAnRVRMQSBQbGF0Zm9ybSBUT1RQJ1xuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5hYmxpbmcgTUZBOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gVmVyaWZ5IE1GQSBzZXR1cFxuICB2ZXJpZnlNRkFTZXR1cDogYXN5bmMgKGZhY3RvcklkOiBzdHJpbmcsIGNvZGU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgY2hhbGxlbmdlIGZpcnN0XG4gICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLm1mYS5jaGFsbGVuZ2Uoe1xuICAgICAgICBmYWN0b3JJZFxuICAgICAgfSlcblxuICAgICAgaWYgKGNoYWxsZW5nZUVycm9yKSB0aHJvdyBjaGFsbGVuZ2VFcnJvclxuXG4gICAgICAvLyBWZXJpZnkgdGhlIGNvZGVcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLnZlcmlmeSh7XG4gICAgICAgIGZhY3RvcklkLFxuICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlLmlkLFxuICAgICAgICBjb2RlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHByb2ZpbGUgdG8gaW5kaWNhdGUgTUZBIGlzIGVuYWJsZWRcbiAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICBpZiAodXNlcikge1xuICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgICAgbWZhX2VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgTUZBIHNldHVwOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gRGlzYWJsZSBNRkEgZm9yIHVzZXJcbiAgZGlzYWJsZU1GQTogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgYWxsIGZhY3RvcnNcbiAgICAgIGNvbnN0IHsgZGF0YTogZmFjdG9ycywgZXJyb3I6IGZhY3RvcnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEubGlzdEZhY3RvcnMoKVxuICAgICAgXG4gICAgICBpZiAoZmFjdG9yc0Vycm9yKSB0aHJvdyBmYWN0b3JzRXJyb3JcblxuICAgICAgLy8gVW5lbnJvbGwgYWxsIFRPVFAgZmFjdG9yc1xuICAgICAgaWYgKGZhY3RvcnM/LnRvdHApIHtcbiAgICAgICAgZm9yIChjb25zdCBmYWN0b3Igb2YgZmFjdG9ycy50b3RwKSB7XG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEudW5lbnJvbGwoeyBmYWN0b3JJZDogZmFjdG9yLmlkIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHVzZXIgcHJvZmlsZVxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgICBtZmFfZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkaXNhYmxpbmcgTUZBOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gR2VuZXJhdGUgYmFja3VwIGNvZGVzIChzaW11bGF0ZWQgLSBpbiBwcm9kdWN0aW9uIHRoaXMgd291bGQgYmUgaGFuZGxlZCBieSB5b3VyIGJhY2tlbmQpXG4gIGdlbmVyYXRlQmFja3VwQ29kZXM6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhdGUgOCBiYWNrdXAgY29kZXNcbiAgICAgIGNvbnN0IGNvZGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogOCB9LCAoKSA9PiBcbiAgICAgICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpLnRvVXBwZXJDYXNlKClcbiAgICAgIClcblxuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IHdvdWxkIHN0b3JlIHRoZXNlIHNlY3VyZWx5IGluIHlvdXIgYmFja2VuZFxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCByZXR1cm4gdGhlbVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY29kZXMgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgYmFja3VwIGNvZGVzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gVmVyaWZ5IGJhY2t1cCBjb2RlIChzaW11bGF0ZWQgLSBpbiBwcm9kdWN0aW9uIHRoaXMgd291bGQgdmVyaWZ5IGFnYWluc3Qgc3RvcmVkIGNvZGVzKVxuICB2ZXJpZnlCYWNrdXBDb2RlOiBhc3luYyAoY29kZTogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSB3b3VsZCB2ZXJpZnkgdGhpcyBhZ2FpbnN0IHN0b3JlZCBiYWNrdXAgY29kZXNcbiAgICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCB3ZSdsbCBhY2NlcHQgYW55IDYrIGNoYXJhY3RlciBjb2RlXG4gICAgICBpZiAoY29kZS5sZW5ndGggPj0gNikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAgY29kZScpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGJhY2t1cCBjb2RlOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQWRkIHVzZXIgbWFuYWdlbWVudCBtZXRob2RzIHRvIHRoZSBtYWluIHN1cGFiYXNlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuT2JqZWN0LmFzc2lnbihzdXBhYmFzZSwgdXNlck1hbmFnZW1lbnQpXG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjcmVhdGVTdXBhYmFzZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4iLCJzdXBhYmFzZSIsInNpZ25JbldpdGhSb2xlIiwiZW1haWwiLCJwYXNzd29yZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJ1c2VyIiwicHJvZmlsZSIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwic2lnbk91dCIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VXNlciIsInVzZXJNYW5hZ2VtZW50IiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwiYXV0aERhdGEiLCJhdXRoRXJyb3IiLCJhZG1pbiIsImVtYWlsX2NvbmZpcm0iLCJ1c2VyX21ldGFkYXRhIiwiZnVsbF9uYW1lIiwicm9sZSIsInJvbGVfbGV2ZWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsInByb2ZpbGVFcnJvciIsImluc2VydCIsInBob25lIiwiZGVwYXJ0bWVudCIsImpvYl90aXRsZSIsInRlbmFudF9pZCIsImlzX2FjdGl2ZSIsImNhbl9pbnZpdGVfdXNlcnMiLCJjYW5fbWFuYWdlX3N1Yl9jbGllbnRzIiwicGVybWlzc2lvbl9zY29wZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlVXNlciIsInRlbmFudFVzZXJFcnJvciIsInVzZXJfaWQiLCJkZWxldGUiLCJhY3Rpb24iLCJyZXNvdXJjZV90eXBlIiwicmVzb3VyY2VfaWQiLCJkZXRhaWxzIiwiY3JlYXRlZF9ieSIsImlwX2FkZHJlc3MiLCJ1c2VyX2FnZW50Iiwic2V2ZXJpdHkiLCJhdWRpdEVycm9yIiwiY29uc29sZSIsIndhcm4iLCJpbnZpdGVVc2VycyIsImludml0YXRpb25EYXRhIiwiaW52aXRhdGlvbnMiLCJlbWFpbHMiLCJpbnZpdGF0aW9uIiwiaW52aXRlRXJyb3IiLCJleHBpcmVzX2F0Iiwibm93IiwiZXhwaXJlc19pbl9kYXlzIiwiZW1haWxFcnJvciIsImludml0ZVVzZXJCeUVtYWlsIiwicmVkaXJlY3RUbyIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiaW52aXRhdGlvbl9pZCIsInVwZGF0ZSIsInN0YXR1cyIsInB1c2giLCJzZW50IiwibGVuZ3RoIiwidG90YWwiLCJ1cGRhdGVVc2VyIiwidXNlcklkIiwidXBkYXRlRGF0YSIsImRlYWN0aXZhdGVVc2VyIiwiYWN0aXZhdGVVc2VyIiwicmVzZXRVc2VyUGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsInVwZGF0ZVVzZXJCeUlkIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwicHJldmlld1VzZXJDbGVhbnVwIiwib3B0aW9ucyIsImluYWN0aXZlVXNlcnMiLCJ1bmNvbmZpcm1lZFVzZXJzIiwiZXhwaXJlZEludml0ZXMiLCJkZWxldGVJbmFjdGl2ZVVzZXJzIiwiY3V0b2ZmRGF0ZSIsImluYWN0aXZlRGF5cyIsImNvdW50IiwiaGVhZCIsImx0IiwiZGVsZXRlVW5jb25maXJtZWRVc2VycyIsInVuY29uZmlybWVkRGF5cyIsImlzIiwiZGVsZXRlRXhwaXJlZEludml0ZXMiLCJuZXEiLCJ0b3RhbFRvRGVsZXRlIiwiZXhlY3V0ZVVzZXJDbGVhbnVwIiwiZGVsZXRlZENvdW50IiwiaW4iLCJtYXAiLCJ1IiwibWZhTWFuYWdlbWVudCIsImNoZWNrTUZBU3RhdHVzIiwibWZhRW5hYmxlZCIsIm1mYV9lbmFibGVkIiwiZW5hYmxlTUZBIiwibWZhIiwiZW5yb2xsIiwiZmFjdG9yVHlwZSIsImZyaWVuZGx5TmFtZSIsInZlcmlmeU1GQVNldHVwIiwiZmFjdG9ySWQiLCJjb2RlIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlRXJyb3IiLCJ2ZXJpZnkiLCJjaGFsbGVuZ2VJZCIsImRpc2FibGVNRkEiLCJmYWN0b3JzIiwiZmFjdG9yc0Vycm9yIiwibGlzdEZhY3RvcnMiLCJ0b3RwIiwiZmFjdG9yIiwidW5lbnJvbGwiLCJnZW5lcmF0ZUJhY2t1cENvZGVzIiwiY29kZXMiLCJBcnJheSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInRvVXBwZXJDYXNlIiwidmVyaWZ5QmFja3VwQ29kZSIsIkVycm9yIiwiT2JqZWN0IiwiYXNzaWduIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase.ts\n"));

/***/ })

});