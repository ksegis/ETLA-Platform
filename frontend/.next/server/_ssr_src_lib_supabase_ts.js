"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_src_lib_supabase_ts";
exports.ids = ["_ssr_src_lib_supabase_ts"];
exports.modules = {

/***/ "(ssr)/./src/lib/supabase.ts":
/*!*****************************!*\
  !*** ./src/lib/supabase.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   mfaManagement: () => (/* binding */ mfaManagement),\n/* harmony export */   signInWithRole: () => (/* binding */ signInWithRole),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   userManagement: () => (/* binding */ userManagement)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst supabaseUrl = \"https://placeholder.supabase.co\";\nconst supabaseAnonKey = \"placeholder_key\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Export createClient function for compatibility\nconst createClient = ()=>(0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Auth helpers\nconst signInWithRole = async (email, password)=>{\n    const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (data.user) {\n        // Get user profile with role and tenant\n        const { data: profile } = await supabase.from('users').select('role, tenant_id, first_name, last_name').eq('id', data.user.id).single();\n        return {\n            user: data.user,\n            profile,\n            error\n        };\n    }\n    return {\n        user: null,\n        profile: null,\n        error\n    };\n};\nconst signOut = async ()=>{\n    const { error } = await supabase.auth.signOut();\n    return {\n        error\n    };\n};\n// Database helpers\nconst getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) return null;\n    const { data: profile } = await supabase.from('users').select('*').eq('id', user.id).single();\n    return {\n        ...user,\n        profile\n    };\n};\n// User Management Methods\nconst userManagement = {\n    // Create a new user with complete RBAC setup\n    createUser: async (userData)=>{\n        try {\n            // First, create the auth user\n            const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n                email: userData.email,\n                password: userData.password,\n                email_confirm: true,\n                user_metadata: {\n                    full_name: userData.full_name,\n                    role: userData.role,\n                    role_level: userData.role_level\n                }\n            });\n            if (authError) {\n                return {\n                    success: false,\n                    error: authError.message\n                };\n            }\n            if (!authData.user) {\n                return {\n                    success: false,\n                    error: 'Failed to create user account'\n                };\n            }\n            // Create the user profile (FIXED: using 'profiles' not 'user_profiles')\n            const { error: profileError } = await supabase.from('profiles').insert({\n                id: authData.user.id,\n                email: userData.email,\n                full_name: userData.full_name,\n                phone: userData.phone,\n                department: userData.department,\n                job_title: userData.job_title,\n                role: userData.role,\n                role_level: userData.role_level,\n                tenant_id: userData.tenant_id,\n                is_active: true,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (profileError) {\n                // If profile creation fails, clean up the auth user\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                return {\n                    success: false,\n                    error: `Profile creation failed: ${profileError.message}`\n                };\n            }\n            // NEW: Create tenant_users record for RBAC\n            const { error: tenantUserError } = await supabase.from('tenant_users').insert({\n                tenant_id: userData.tenant_id,\n                user_id: authData.user.id,\n                role: userData.role,\n                role_level: userData.role_level,\n                can_invite_users: userData.can_invite_users,\n                can_manage_sub_clients: userData.can_manage_sub_clients,\n                permission_scope: userData.permission_scope,\n                is_active: true,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            });\n            if (tenantUserError) {\n                // If tenant_users creation fails, clean up auth user and profile\n                await supabase.auth.admin.deleteUser(authData.user.id);\n                await supabase.from('profiles').delete().eq('id', authData.user.id);\n                return {\n                    success: false,\n                    error: `Tenant assignment failed: ${tenantUserError.message}`\n                };\n            }\n            // OPTIONAL: Create audit log if table exists\n            try {\n                await supabase.from('audit_logs').insert({\n                    user_id: authData.user.id,\n                    tenant_id: userData.tenant_id,\n                    action: 'user_created',\n                    resource_type: 'user',\n                    resource_id: authData.user.id,\n                    details: {\n                        created_by: 'admin_interface',\n                        role: userData.role,\n                        role_level: userData.role_level,\n                        email: userData.email\n                    },\n                    ip_address: '127.0.0.1',\n                    user_agent: 'Admin Interface',\n                    severity: 'info',\n                    created_at: new Date().toISOString()\n                });\n            } catch (auditError) {\n                // Audit log is optional, don't fail the user creation\n                console.warn('Audit log creation failed:', auditError);\n            }\n            return {\n                success: true,\n                data: authData.user\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to create user'\n            };\n        }\n    },\n    // Invite users via email\n    inviteUsers: async (invitationData)=>{\n        try {\n            const invitations = [];\n            for (const email of invitationData.emails){\n                // Create invitation record\n                const { data: invitation, error: inviteError } = await supabase.from('user_invitations').insert({\n                    email,\n                    role: invitationData.role,\n                    role_level: invitationData.role_level,\n                    tenant_id: invitationData.tenant_id,\n                    message: invitationData.message,\n                    expires_at: new Date(Date.now() + invitationData.expires_in_days * 24 * 60 * 60 * 1000).toISOString(),\n                    created_at: new Date().toISOString()\n                }).select().single();\n                if (inviteError) {\n                    console.error(`Failed to create invitation for ${email}:`, inviteError);\n                    continue;\n                }\n                // Send invitation email using Supabase Auth\n                const { error: emailError } = await supabase.auth.admin.inviteUserByEmail(email, {\n                    redirectTo: `${window.location.origin}/accept-invitation?token=${invitation.id}`,\n                    data: {\n                        role: invitationData.role,\n                        role_level: invitationData.role_level,\n                        tenant_id: invitationData.tenant_id,\n                        invitation_id: invitation.id\n                    }\n                });\n                if (emailError) {\n                    console.error(`Failed to send invitation email to ${email}:`, emailError);\n                    // Mark invitation as failed\n                    await supabase.from('user_invitations').update({\n                        status: 'failed'\n                    }).eq('id', invitation.id);\n                } else {\n                    invitations.push(invitation);\n                }\n            }\n            return {\n                success: true,\n                data: {\n                    sent: invitations.length,\n                    total: invitationData.emails.length\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to send invitations'\n            };\n        }\n    },\n    // Update user information\n    updateUser: async (userId, updateData)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                ...updateData,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to update user'\n            };\n        }\n    },\n    // Deactivate user\n    deactivateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: false,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to deactivate user'\n            };\n        }\n    },\n    // Activate user\n    activateUser: async (userId)=>{\n        try {\n            const { error } = await supabase.from('profiles').update({\n                is_active: true,\n                updated_at: new Date().toISOString()\n            }).eq('id', userId);\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to activate user'\n            };\n        }\n    },\n    // Reset user password\n    resetUserPassword: async (email, newPassword)=>{\n        try {\n            if (newPassword) {\n                // Direct password reset (admin function)\n                const { error } = await supabase.auth.admin.updateUserById(email, {\n                    password: newPassword\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            } else {\n                // Email-based password reset\n                const { error } = await supabase.auth.resetPasswordForEmail(email, {\n                    redirectTo: `${window.location.origin}/reset-password`\n                });\n                if (error) {\n                    return {\n                        success: false,\n                        error: error.message\n                    };\n                }\n                return {\n                    success: true\n                };\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to reset password'\n            };\n        }\n    },\n    // Preview cleanup operations\n    previewUserCleanup: async (options)=>{\n        try {\n            let inactiveUsers = 0;\n            let unconfirmedUsers = 0;\n            let expiredInvites = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('profiles').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('last_login', cutoffDate).eq('is_active', true);\n                inactiveUsers = count || 0;\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                const { count } = await supabase.from('auth.users').select('*', {\n                    count: 'exact',\n                    head: true\n                }).is('email_confirmed_at', null).lt('created_at', cutoffDate);\n                unconfirmedUsers = count || 0;\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').select('*', {\n                    count: 'exact',\n                    head: true\n                }).lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                expiredInvites = count || 0;\n            }\n            const totalToDelete = inactiveUsers + unconfirmedUsers + expiredInvites;\n            return {\n                success: true,\n                data: {\n                    inactiveUsers,\n                    unconfirmedUsers,\n                    expiredInvites,\n                    totalToDelete\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to preview cleanup'\n            };\n        }\n    },\n    // Execute cleanup operations\n    executeUserCleanup: async (options)=>{\n        try {\n            let deletedCount = 0;\n            if (options.deleteInactiveUsers) {\n                const cutoffDate = new Date(Date.now() - options.inactiveDays * 24 * 60 * 60 * 1000).toISOString();\n                // Get inactive users\n                const { data: inactiveUsers } = await supabase.from('profiles').select('id').lt('last_login', cutoffDate).eq('is_active', true);\n                if (inactiveUsers) {\n                    for (const user of inactiveUsers){\n                        // Delete auth user\n                        await supabase.auth.admin.deleteUser(user.id);\n                        // Delete profile\n                        await supabase.from('profiles').delete().eq('id', user.id);\n                    }\n                    deletedCount += inactiveUsers.length;\n                }\n            }\n            if (options.deleteUnconfirmedUsers) {\n                const cutoffDate = new Date(Date.now() - options.unconfirmedDays * 24 * 60 * 60 * 1000).toISOString();\n                // This would require admin access to auth.users table\n                // For now, we'll mark them as inactive\n                const { data: unconfirmedUsers } = await supabase.from('profiles').select('id').lt('created_at', cutoffDate).eq('is_active', true);\n                if (unconfirmedUsers) {\n                    await supabase.from('profiles').update({\n                        is_active: false\n                    }).in('id', unconfirmedUsers.map((u)=>u.id));\n                    deletedCount += unconfirmedUsers.length;\n                }\n            }\n            if (options.deleteExpiredInvites) {\n                const { count } = await supabase.from('user_invitations').delete().lt('expires_at', new Date().toISOString()).neq('status', 'accepted');\n                deletedCount += count || 0;\n            }\n            return {\n                success: true,\n                data: {\n                    deletedCount\n                }\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message || 'Failed to execute cleanup'\n            };\n        }\n    }\n};\nconst mfaManagement = {\n    // Check if user has MFA enabled\n    checkMFAStatus: async (userId)=>{\n        try {\n            const { data, error } = await supabase.from('profiles').select('mfa_enabled').eq('id', userId).single();\n            if (error) throw error;\n            return {\n                mfaEnabled: data?.mfa_enabled || false\n            };\n        } catch (error) {\n            console.error('Error checking MFA status:', error);\n            return {\n                mfaEnabled: false,\n                error: error.message\n            };\n        }\n    },\n    // Enable MFA for user\n    enableMFA: async ()=>{\n        try {\n            // Enroll for TOTP MFA\n            const { data, error } = await supabase.auth.mfa.enroll({\n                factorType: 'totp',\n                friendlyName: 'ETLA Platform TOTP'\n            });\n            if (error) throw error;\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error enabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify MFA setup\n    verifyMFASetup: async (factorId, code)=>{\n        try {\n            // Create challenge first\n            const { data: challenge, error: challengeError } = await supabase.auth.mfa.challenge({\n                factorId\n            });\n            if (challengeError) throw challengeError;\n            // Verify the code\n            const { data, error } = await supabase.auth.mfa.verify({\n                factorId,\n                challengeId: challenge.id,\n                code\n            });\n            if (error) throw error;\n            // Update user profile to indicate MFA is enabled\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: true,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error verifying MFA setup:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Disable MFA for user\n    disableMFA: async ()=>{\n        try {\n            // Get all factors\n            const { data: factors, error: factorsError } = await supabase.auth.mfa.listFactors();\n            if (factorsError) throw factorsError;\n            // Unenroll all TOTP factors\n            if (factors?.totp) {\n                for (const factor of factors.totp){\n                    await supabase.auth.mfa.unenroll({\n                        factorId: factor.id\n                    });\n                }\n            }\n            // Update user profile\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                await supabase.from('profiles').update({\n                    mfa_enabled: false,\n                    updated_at: new Date().toISOString()\n                }).eq('id', user.id);\n            }\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error('Error disabling MFA:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Generate backup codes (simulated - in production this would be handled by your backend)\n    generateBackupCodes: async ()=>{\n        try {\n            // Generate 8 backup codes\n            const codes = Array.from({\n                length: 8\n            }, ()=>Math.random().toString(36).substring(2, 8).toUpperCase());\n            // In production, you would store these securely in your backend\n            // For now, we'll just return them\n            return {\n                success: true,\n                codes\n            };\n        } catch (error) {\n            console.error('Error generating backup codes:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    },\n    // Verify backup code (simulated - in production this would verify against stored codes)\n    verifyBackupCode: async (code)=>{\n        try {\n            // In production, you would verify this against stored backup codes\n            // For demo purposes, we'll accept any 6+ character code\n            if (code.length >= 6) {\n                return {\n                    success: true\n                };\n            } else {\n                throw new Error('Invalid backup code');\n            }\n        } catch (error) {\n            console.error('Error verifying backup code:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n};\n// Add user management methods to the main supabase object for backward compatibility\nObject.assign(supabase, userManagement);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSUMsU0FBUyxDQUFDLEdBQUcsR0FBR0MsV0FBVztZQUd4RCxnRUFBZ0U7WUFDaEUsa0NBQWtDO1lBQ2xDLE9BQU87Z0JBQUVsSCxTQUFTO2dCQUFNNEc7WUFBTTtRQUNoQyxFQUFFLE9BQU9wSSxPQUFZO1lBQ25CcUQsUUFBUXJELEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87Z0JBQUV3QixTQUFTO2dCQUFPeEIsT0FBT0EsTUFBTXlCLE9BQU87WUFBQztRQUNoRDtJQUNGO0lBRUEsd0ZBQXdGO0lBQ3hGa0gsa0JBQWtCLE9BQU9wQjtRQUN2QixJQUFJO1lBQ0YsbUVBQW1FO1lBQ25FLHdEQUF3RDtZQUN4RCxJQUFJQSxLQUFLNUMsTUFBTSxJQUFJLEdBQUc7Z0JBQ3BCLE9BQU87b0JBQUVuRCxTQUFTO2dCQUFLO1lBQ3pCLE9BQU87Z0JBQ0wsTUFBTSxJQUFJb0gsTUFBTTtZQUNsQjtRQUNGLEVBQUUsT0FBTzVJLE9BQVk7WUFDbkJxRCxRQUFRckQsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTztnQkFBRXdCLFNBQVM7Z0JBQU94QixPQUFPQSxNQUFNeUIsT0FBTztZQUFDO1FBQ2hEO0lBQ0Y7QUFDRixFQUFDO0FBRUQscUZBQXFGO0FBQ3JGb0gsT0FBT0MsTUFBTSxDQUFDbkosVUFBVWtCIiwic291cmNlcyI6WyIvaG9tZS91YnVudHUvRVRMQS1QbGF0Zm9ybS9mcm9udGVuZC9zcmMvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdXBhYmFzZS50c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IGFzIGNyZWF0ZVN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCFcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fVE9LRU4hXG5cbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXG5cbi8vIEV4cG9ydCBjcmVhdGVDbGllbnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBjb25zdCBjcmVhdGVDbGllbnQgPSAoKSA9PiBjcmVhdGVTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KVxuXG4vLyBEYXRhYmFzZSB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBXb3JrUmVxdWVzdCB7XG4gIGlkOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGNhdGVnb3J5OiBzdHJpbmdcbiAgcHJpb3JpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnXG4gIHVyZ2VuY3k6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAndXJnZW50J1xuICBzdGF0dXM6ICdzdWJtaXR0ZWQnIHwgJ3VuZGVyX3JldmlldycgfCAnYXBwcm92ZWQnIHwgJ3JlamVjdGVkJyB8ICdzY2hlZHVsZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCdcbiAgY3VzdG9tZXJfaWQ6IHN0cmluZ1xuICBhc3NpZ25lZF90bz86IHN0cmluZ1xuICBlc3RpbWF0ZWRfaG91cnM/OiBudW1iZXJcbiAgYWN0dWFsX2hvdXJzOiBudW1iZXJcbiAgYnVkZ2V0PzogbnVtYmVyXG4gIHJlcXVpcmVkX2NvbXBsZXRpb25fZGF0ZT86IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdCB7XG4gIGlkOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgd29ya19yZXF1ZXN0X2lkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xuICBzdGF0dXM6ICdzY2hlZHVsZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ29uX2hvbGQnIHwgJ2NhbmNlbGxlZCdcbiAgcHJpb3JpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnXG4gIGFzc2lnbmVkX3RlYW1fbGVhZDogc3RyaW5nXG4gIGVzdGltYXRlZF9ob3VyczogbnVtYmVyXG4gIGFjdHVhbF9ob3VyczogbnVtYmVyXG4gIGJ1ZGdldD86IG51bWJlclxuICBzdGFydF9kYXRlOiBzdHJpbmdcbiAgZW5kX2RhdGU6IHN0cmluZ1xuICBjb21wbGV0aW9uX3BlcmNlbnRhZ2U6IG51bWJlclxuICBjbGllbnRfc2F0aXNmYWN0aW9uX3Njb3JlPzogbnVtYmVyXG4gIG9uX3RpbWVfZGVsaXZlcnk/OiBib29sZWFuXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5hbnQge1xuICBpZDogc3RyaW5nXG4gIGNvbXBhbnlfbmFtZTogc3RyaW5nXG4gIHN1YmRvbWFpbj86IHN0cmluZ1xuICBpbmR1c3RyeT86IHN0cmluZ1xuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ3RyaWFsJyB8ICdzdXNwZW5kZWQnIHwgJ2NhbmNlbGxlZCdcbiAgc3Vic2NyaXB0aW9uX3BsYW46ICd0cmlhbCcgfCAncHJvZmVzc2lvbmFsJyB8ICdlbnRlcnByaXNlJ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGZpcnN0X25hbWU6IHN0cmluZ1xuICBsYXN0X25hbWU6IHN0cmluZ1xuICByb2xlOiAnaG9zdF9hZG1pbicgfCAncHJvZ3JhbV9tYW5hZ2VyJyB8ICdjbGllbnRfYWRtaW4nIHwgJ2NsaWVudF91c2VyJ1xuICB0ZW5hbnRfaWQ/OiBzdHJpbmdcbiAgaXNfYWN0aXZlOiBib29sZWFuXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xufVxuXG4vLyBFeHRlbmRlZCBVc2VyIGludGVyZmFjZSBmb3IgdXNlciBtYW5hZ2VtZW50XG5leHBvcnQgaW50ZXJmYWNlIEV4dGVuZGVkVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBmdWxsX25hbWU6IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBkZXBhcnRtZW50Pzogc3RyaW5nXG4gIGpvYl90aXRsZT86IHN0cmluZ1xuICByb2xlOiBzdHJpbmdcbiAgcm9sZV9sZXZlbDogc3RyaW5nXG4gIHRlbmFudF9pZDogc3RyaW5nXG4gIHRlbmFudF9uYW1lPzogc3RyaW5nXG4gIGlzX2FjdGl2ZTogYm9vbGVhblxuICBjYW5faW52aXRlX3VzZXJzOiBib29sZWFuXG4gIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IGJvb2xlYW5cbiAgcGVybWlzc2lvbl9zY29wZTogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbiAgbGFzdF9sb2dpbj86IHN0cmluZ1xufVxuXG4vLyBVc2VyIGNyZWF0aW9uIGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJDcmVhdGlvbkRhdGEge1xuICBlbWFpbDogc3RyaW5nXG4gIGZ1bGxfbmFtZTogc3RyaW5nXG4gIHBob25lPzogc3RyaW5nXG4gIGRlcGFydG1lbnQ/OiBzdHJpbmdcbiAgam9iX3RpdGxlPzogc3RyaW5nXG4gIHJvbGU6IHN0cmluZ1xuICByb2xlX2xldmVsOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICBjYW5faW52aXRlX3VzZXJzOiBib29sZWFuXG4gIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IGJvb2xlYW5cbiAgcGVybWlzc2lvbl9zY29wZTogc3RyaW5nXG59XG5cbi8vIFVzZXIgaW52aXRhdGlvbiBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBVc2VySW52aXRhdGlvbkRhdGEge1xuICBlbWFpbHM6IHN0cmluZ1tdXG4gIHJvbGU6IHN0cmluZ1xuICByb2xlX2xldmVsOiBzdHJpbmdcbiAgdGVuYW50X2lkOiBzdHJpbmdcbiAgbWVzc2FnZT86IHN0cmluZ1xuICBleHBpcmVzX2luX2RheXM6IG51bWJlclxufVxuXG4vLyBVc2VyIHVwZGF0ZSBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBVc2VyVXBkYXRlRGF0YSB7XG4gIGZ1bGxfbmFtZT86IHN0cmluZ1xuICBwaG9uZT86IHN0cmluZ1xuICBkZXBhcnRtZW50Pzogc3RyaW5nXG4gIGpvYl90aXRsZT86IHN0cmluZ1xuICByb2xlPzogc3RyaW5nXG4gIHJvbGVfbGV2ZWw/OiBzdHJpbmdcbiAgdGVuYW50X2lkPzogc3RyaW5nXG4gIGlzX2FjdGl2ZT86IGJvb2xlYW5cbiAgY2FuX2ludml0ZV91c2Vycz86IGJvb2xlYW5cbiAgY2FuX21hbmFnZV9zdWJfY2xpZW50cz86IGJvb2xlYW5cbiAgcGVybWlzc2lvbl9zY29wZT86IHN0cmluZ1xufVxuXG4vLyBDbGVhbnVwIG9wdGlvbnMgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIENsZWFudXBPcHRpb25zIHtcbiAgZGVsZXRlSW5hY3RpdmVVc2VyczogYm9vbGVhblxuICBkZWxldGVVbmNvbmZpcm1lZFVzZXJzOiBib29sZWFuXG4gIGRlbGV0ZUV4cGlyZWRJbnZpdGVzOiBib29sZWFuXG4gIGluYWN0aXZlRGF5czogbnVtYmVyXG4gIHVuY29uZmlybWVkRGF5czogbnVtYmVyXG59XG5cbi8vIEF1dGggaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNpZ25JbldpdGhSb2xlID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgIGVtYWlsLFxuICAgIHBhc3N3b3JkXG4gIH0pXG4gIFxuICBpZiAoZGF0YS51c2VyKSB7XG4gICAgLy8gR2V0IHVzZXIgcHJvZmlsZSB3aXRoIHJvbGUgYW5kIHRlbmFudFxuICAgIGNvbnN0IHsgZGF0YTogcHJvZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAuc2VsZWN0KCdyb2xlLCB0ZW5hbnRfaWQsIGZpcnN0X25hbWUsIGxhc3RfbmFtZScpXG4gICAgICAuZXEoJ2lkJywgZGF0YS51c2VyLmlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgXG4gICAgcmV0dXJuIHsgdXNlcjogZGF0YS51c2VyLCBwcm9maWxlLCBlcnJvciB9XG4gIH1cbiAgXG4gIHJldHVybiB7IHVzZXI6IG51bGwsIHByb2ZpbGU6IG51bGwsIGVycm9yIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNpZ25PdXQgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbk91dCgpXG4gIHJldHVybiB7IGVycm9yIH1cbn1cblxuLy8gRGF0YWJhc2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRVc2VyID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICBpZiAoIXVzZXIpIHJldHVybiBudWxsXG4gIFxuICBjb25zdCB7IGRhdGE6IHByb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3VzZXJzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAuc2luZ2xlKClcbiAgXG4gIHJldHVybiB7IC4uLnVzZXIsIHByb2ZpbGUgfVxufVxuXG4vLyBVc2VyIE1hbmFnZW1lbnQgTWV0aG9kc1xuZXhwb3J0IGNvbnN0IHVzZXJNYW5hZ2VtZW50ID0ge1xuICAvLyBDcmVhdGUgYSBuZXcgdXNlciB3aXRoIGNvbXBsZXRlIFJCQUMgc2V0dXBcbiAgY3JlYXRlVXNlcjogYXN5bmMgKHVzZXJEYXRhOiBVc2VyQ3JlYXRpb25EYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCBjcmVhdGUgdGhlIGF1dGggdXNlclxuICAgICAgY29uc3QgeyBkYXRhOiBhdXRoRGF0YSwgZXJyb3I6IGF1dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5jcmVhdGVVc2VyKHtcbiAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICBwYXNzd29yZDogdXNlckRhdGEucGFzc3dvcmQsXG4gICAgICAgIGVtYWlsX2NvbmZpcm06IHRydWUsXG4gICAgICAgIHVzZXJfbWV0YWRhdGE6IHtcbiAgICAgICAgICBmdWxsX25hbWU6IHVzZXJEYXRhLmZ1bGxfbmFtZSxcbiAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxuICAgICAgICAgIHJvbGVfbGV2ZWw6IHVzZXJEYXRhLnJvbGVfbGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKGF1dGhFcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGF1dGhFcnJvci5tZXNzYWdlIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRoRGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgdXNlciBhY2NvdW50JyB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgdXNlciBwcm9maWxlIChGSVhFRDogdXNpbmcgJ3Byb2ZpbGVzJyBub3QgJ3VzZXJfcHJvZmlsZXMnKVxuICAgICAgY29uc3QgeyBlcnJvcjogcHJvZmlsZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBpZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUsXG4gICAgICAgICAgcGhvbmU6IHVzZXJEYXRhLnBob25lLFxuICAgICAgICAgIGRlcGFydG1lbnQ6IHVzZXJEYXRhLmRlcGFydG1lbnQsXG4gICAgICAgICAgam9iX3RpdGxlOiB1c2VyRGF0YS5qb2JfdGl0bGUsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgIHRlbmFudF9pZDogdXNlckRhdGEudGVuYW50X2lkLFxuICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjYW5faW52aXRlX3VzZXJzOiB1c2VyRGF0YS5jYW5faW52aXRlX3VzZXJzLFxuICAgICAgICAgIGNhbl9tYW5hZ2Vfc3ViX2NsaWVudHM6IHVzZXJEYXRhLmNhbl9tYW5hZ2Vfc3ViX2NsaWVudHMsXG4gICAgICAgICAgcGVybWlzc2lvbl9zY29wZTogdXNlckRhdGEucGVybWlzc2lvbl9zY29wZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChwcm9maWxlRXJyb3IpIHtcbiAgICAgICAgLy8gSWYgcHJvZmlsZSBjcmVhdGlvbiBmYWlscywgY2xlYW4gdXAgdGhlIGF1dGggdXNlclxuICAgICAgICBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLmRlbGV0ZVVzZXIoYXV0aERhdGEudXNlci5pZClcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgUHJvZmlsZSBjcmVhdGlvbiBmYWlsZWQ6ICR7cHJvZmlsZUVycm9yLm1lc3NhZ2V9YCB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5FVzogQ3JlYXRlIHRlbmFudF91c2VycyByZWNvcmQgZm9yIFJCQUNcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHRlbmFudFVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3RlbmFudF91c2VycycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHRlbmFudF9pZDogdXNlckRhdGEudGVuYW50X2lkLFxuICAgICAgICAgIHVzZXJfaWQ6IGF1dGhEYXRhLnVzZXIuaWQsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICByb2xlX2xldmVsOiB1c2VyRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgIGNhbl9pbnZpdGVfdXNlcnM6IHVzZXJEYXRhLmNhbl9pbnZpdGVfdXNlcnMsXG4gICAgICAgICAgY2FuX21hbmFnZV9zdWJfY2xpZW50czogdXNlckRhdGEuY2FuX21hbmFnZV9zdWJfY2xpZW50cyxcbiAgICAgICAgICBwZXJtaXNzaW9uX3Njb3BlOiB1c2VyRGF0YS5wZXJtaXNzaW9uX3Njb3BlLFxuICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG5cbiAgICAgIGlmICh0ZW5hbnRVc2VyRXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGVuYW50X3VzZXJzIGNyZWF0aW9uIGZhaWxzLCBjbGVhbiB1cCBhdXRoIHVzZXIgYW5kIHByb2ZpbGVcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5kZWxldGVVc2VyKGF1dGhEYXRhLnVzZXIuaWQpXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuZGVsZXRlKCkuZXEoJ2lkJywgYXV0aERhdGEudXNlci5pZClcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgVGVuYW50IGFzc2lnbm1lbnQgZmFpbGVkOiAke3RlbmFudFVzZXJFcnJvci5tZXNzYWdlfWAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUFRJT05BTDogQ3JlYXRlIGF1ZGl0IGxvZyBpZiB0YWJsZSBleGlzdHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2F1ZGl0X2xvZ3MnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgdXNlcl9pZDogYXV0aERhdGEudXNlci5pZCxcbiAgICAgICAgICAgIHRlbmFudF9pZDogdXNlckRhdGEudGVuYW50X2lkLFxuICAgICAgICAgICAgYWN0aW9uOiAndXNlcl9jcmVhdGVkJyxcbiAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd1c2VyJyxcbiAgICAgICAgICAgIHJlc291cmNlX2lkOiBhdXRoRGF0YS51c2VyLmlkLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBjcmVhdGVkX2J5OiAnYWRtaW5faW50ZXJmYWNlJyxcbiAgICAgICAgICAgICAgcm9sZTogdXNlckRhdGEucm9sZSxcbiAgICAgICAgICAgICAgcm9sZV9sZXZlbDogdXNlckRhdGEucm9sZV9sZXZlbCxcbiAgICAgICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXBfYWRkcmVzczogJzEyNy4wLjAuMScsXG4gICAgICAgICAgICB1c2VyX2FnZW50OiAnQWRtaW4gSW50ZXJmYWNlJyxcbiAgICAgICAgICAgIHNldmVyaXR5OiAnaW5mbycsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoYXVkaXRFcnJvcikge1xuICAgICAgICAvLyBBdWRpdCBsb2cgaXMgb3B0aW9uYWwsIGRvbid0IGZhaWwgdGhlIHVzZXIgY3JlYXRpb25cbiAgICAgICAgY29uc29sZS53YXJuKCdBdWRpdCBsb2cgY3JlYXRpb24gZmFpbGVkOicsIGF1ZGl0RXJyb3IpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGF1dGhEYXRhLnVzZXIgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGNyZWF0ZSB1c2VyJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEludml0ZSB1c2VycyB2aWEgZW1haWxcbiAgaW52aXRlVXNlcnM6IGFzeW5jIChpbnZpdGF0aW9uRGF0YTogVXNlckludml0YXRpb25EYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGludml0YXRpb25zID0gW11cbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBlbWFpbCBvZiBpbnZpdGF0aW9uRGF0YS5lbWFpbHMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGludml0YXRpb24gcmVjb3JkXG4gICAgICAgIGNvbnN0IHsgZGF0YTogaW52aXRhdGlvbiwgZXJyb3I6IGludml0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VyX2ludml0YXRpb25zJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcm9sZTogaW52aXRhdGlvbkRhdGEucm9sZSxcbiAgICAgICAgICAgIHJvbGVfbGV2ZWw6IGludml0YXRpb25EYXRhLnJvbGVfbGV2ZWwsXG4gICAgICAgICAgICB0ZW5hbnRfaWQ6IGludml0YXRpb25EYXRhLnRlbmFudF9pZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGludml0YXRpb25EYXRhLm1lc3NhZ2UsXG4gICAgICAgICAgICBleHBpcmVzX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgaW52aXRhdGlvbkRhdGEuZXhwaXJlc19pbl9kYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgICAgaWYgKGludml0ZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBpbnZpdGF0aW9uIGZvciAke2VtYWlsfTpgLCBpbnZpdGVFcnJvcilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCBpbnZpdGF0aW9uIGVtYWlsIHVzaW5nIFN1cGFiYXNlIEF1dGhcbiAgICAgICAgY29uc3QgeyBlcnJvcjogZW1haWxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi5pbnZpdGVVc2VyQnlFbWFpbChlbWFpbCwge1xuICAgICAgICAgIHJlZGlyZWN0VG86IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2FjY2VwdC1pbnZpdGF0aW9uP3Rva2VuPSR7aW52aXRhdGlvbi5pZH1gLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJvbGU6IGludml0YXRpb25EYXRhLnJvbGUsXG4gICAgICAgICAgICByb2xlX2xldmVsOiBpbnZpdGF0aW9uRGF0YS5yb2xlX2xldmVsLFxuICAgICAgICAgICAgdGVuYW50X2lkOiBpbnZpdGF0aW9uRGF0YS50ZW5hbnRfaWQsXG4gICAgICAgICAgICBpbnZpdGF0aW9uX2lkOiBpbnZpdGF0aW9uLmlkXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChlbWFpbEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHNlbmQgaW52aXRhdGlvbiBlbWFpbCB0byAke2VtYWlsfTpgLCBlbWFpbEVycm9yKVxuICAgICAgICAgIC8vIE1hcmsgaW52aXRhdGlvbiBhcyBmYWlsZWRcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3VzZXJfaW52aXRhdGlvbnMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7IHN0YXR1czogJ2ZhaWxlZCcgfSlcbiAgICAgICAgICAgIC5lcSgnaWQnLCBpbnZpdGF0aW9uLmlkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludml0YXRpb25zLnB1c2goaW52aXRhdGlvbilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBcbiAgICAgICAgc3VjY2VzczogdHJ1ZSwgXG4gICAgICAgIGRhdGE6IHsgXG4gICAgICAgICAgc2VudDogaW52aXRhdGlvbnMubGVuZ3RoLCBcbiAgICAgICAgICB0b3RhbDogaW52aXRhdGlvbkRhdGEuZW1haWxzLmxlbmd0aCBcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBzZW5kIGludml0YXRpb25zJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFVwZGF0ZSB1c2VyIGluZm9ybWF0aW9uXG4gIHVwZGF0ZVVzZXI6IGFzeW5jICh1c2VySWQ6IHN0cmluZywgdXBkYXRlRGF0YTogVXNlclVwZGF0ZURhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgLi4udXBkYXRlRGF0YSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSB1c2VyJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIERlYWN0aXZhdGUgdXNlclxuICBkZWFjdGl2YXRlVXNlcjogYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGlzX2FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWFjdGl2YXRlIHVzZXInIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gQWN0aXZhdGUgdXNlclxuICBhY3RpdmF0ZVVzZXI6IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBhY3RpdmF0ZSB1c2VyJyB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFJlc2V0IHVzZXIgcGFzc3dvcmRcbiAgcmVzZXRVc2VyUGFzc3dvcmQ6IGFzeW5jIChlbWFpbDogc3RyaW5nLCBuZXdQYXNzd29yZD86IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAobmV3UGFzc3dvcmQpIHtcbiAgICAgICAgLy8gRGlyZWN0IHBhc3N3b3JkIHJlc2V0IChhZG1pbiBmdW5jdGlvbilcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi51cGRhdGVVc2VyQnlJZChcbiAgICAgICAgICBlbWFpbCwgLy8gVGhpcyBzaG91bGQgYmUgdXNlciBJRCwgYnV0IHdlJ2xsIG5lZWQgdG8gZ2V0IGl0IGZpcnN0XG4gICAgICAgICAgeyBwYXNzd29yZDogbmV3UGFzc3dvcmQgfVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW1haWwtYmFzZWQgcGFzc3dvcmQgcmVzZXRcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5yZXNldFBhc3N3b3JkRm9yRW1haWwoZW1haWwsIHtcbiAgICAgICAgICByZWRpcmVjdFRvOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9yZXNldC1wYXNzd29yZGBcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcmVzZXQgcGFzc3dvcmQnIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gUHJldmlldyBjbGVhbnVwIG9wZXJhdGlvbnNcbiAgcHJldmlld1VzZXJDbGVhbnVwOiBhc3luYyAob3B0aW9uczogQ2xlYW51cE9wdGlvbnMpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGluYWN0aXZlVXNlcnMgPSAwXG4gICAgICBsZXQgdW5jb25maXJtZWRVc2VycyA9IDBcbiAgICAgIGxldCBleHBpcmVkSW52aXRlcyA9IDBcblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlSW5hY3RpdmVVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMuaW5hY3RpdmVEYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgICAubHQoJ2xhc3RfbG9naW4nLCBjdXRvZmZEYXRlKVxuICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICAgICAgICBpbmFjdGl2ZVVzZXJzID0gY291bnQgfHwgMFxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxldGVVbmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gb3B0aW9ucy51bmNvbmZpcm1lZERheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2F1dGgudXNlcnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmlzKCdlbWFpbF9jb25maXJtZWRfYXQnLCBudWxsKVxuICAgICAgICAgIC5sdCgnY3JlYXRlZF9hdCcsIGN1dG9mZkRhdGUpXG5cbiAgICAgICAgdW5jb25maXJtZWRVc2VycyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlRXhwaXJlZEludml0ZXMpIHtcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgICAubHQoJ2V4cGlyZXNfYXQnLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXG4gICAgICAgICAgLm5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcblxuICAgICAgICBleHBpcmVkSW52aXRlcyA9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG90YWxUb0RlbGV0ZSA9IGluYWN0aXZlVXNlcnMgKyB1bmNvbmZpcm1lZFVzZXJzICsgZXhwaXJlZEludml0ZXNcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGluYWN0aXZlVXNlcnMsXG4gICAgICAgICAgdW5jb25maXJtZWRVc2VycyxcbiAgICAgICAgICBleHBpcmVkSW52aXRlcyxcbiAgICAgICAgICB0b3RhbFRvRGVsZXRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBwcmV2aWV3IGNsZWFudXAnIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gRXhlY3V0ZSBjbGVhbnVwIG9wZXJhdGlvbnNcbiAgZXhlY3V0ZVVzZXJDbGVhbnVwOiBhc3luYyAob3B0aW9uczogQ2xlYW51cE9wdGlvbnMpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRlbGV0ZWRDb3VudCA9IDBcblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlSW5hY3RpdmVVc2Vycykge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIG9wdGlvbnMuaW5hY3RpdmVEYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGluYWN0aXZlIHVzZXJzXG4gICAgICAgIGNvbnN0IHsgZGF0YTogaW5hY3RpdmVVc2VycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAubHQoJ2xhc3RfbG9naW4nLCBjdXRvZmZEYXRlKVxuICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICAgICAgICBpZiAoaW5hY3RpdmVVc2Vycykge1xuICAgICAgICAgIGZvciAoY29uc3QgdXNlciBvZiBpbmFjdGl2ZVVzZXJzKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgYXV0aCB1c2VyXG4gICAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5hdXRoLmFkbWluLmRlbGV0ZVVzZXIodXNlci5pZClcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwcm9maWxlXG4gICAgICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZWRDb3VudCArPSBpbmFjdGl2ZVVzZXJzLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGV0ZVVuY29uZmlybWVkVXNlcnMpIHtcbiAgICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBvcHRpb25zLnVuY29uZmlybWVkRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgXG4gICAgICAgIC8vIFRoaXMgd291bGQgcmVxdWlyZSBhZG1pbiBhY2Nlc3MgdG8gYXV0aC51c2VycyB0YWJsZVxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBtYXJrIHRoZW0gYXMgaW5hY3RpdmVcbiAgICAgICAgY29uc3QgeyBkYXRhOiB1bmNvbmZpcm1lZFVzZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgIC5sdCgnY3JlYXRlZF9hdCcsIGN1dG9mZkRhdGUpXG4gICAgICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuXG4gICAgICAgIGlmICh1bmNvbmZpcm1lZFVzZXJzKSB7XG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgICAudXBkYXRlKHsgaXNfYWN0aXZlOiBmYWxzZSB9KVxuICAgICAgICAgICAgLmluKCdpZCcsIHVuY29uZmlybWVkVXNlcnMubWFwKHUgPT4gdS5pZCkpXG4gICAgICAgICAgXG4gICAgICAgICAgZGVsZXRlZENvdW50ICs9IHVuY29uZmlybWVkVXNlcnMubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGVsZXRlRXhwaXJlZEludml0ZXMpIHtcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9pbnZpdGF0aW9ucycpXG4gICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgICAgIC5uZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG5cbiAgICAgICAgZGVsZXRlZENvdW50ICs9IGNvdW50IHx8IDBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBkZWxldGVkQ291bnQgfSB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZXhlY3V0ZSBjbGVhbnVwJyB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZmFNYW5hZ2VtZW50ID0ge1xuICAvLyBDaGVjayBpZiB1c2VyIGhhcyBNRkEgZW5hYmxlZFxuICBjaGVja01GQVN0YXR1czogYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJ21mYV9lbmFibGVkJylcbiAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB7IG1mYUVuYWJsZWQ6IGRhdGE/Lm1mYV9lbmFibGVkIHx8IGZhbHNlIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBNRkEgc3RhdHVzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgbWZhRW5hYmxlZDogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gRW5hYmxlIE1GQSBmb3IgdXNlclxuICBlbmFibGVNRkE6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRW5yb2xsIGZvciBUT1RQIE1GQVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEuZW5yb2xsKHtcbiAgICAgICAgZmFjdG9yVHlwZTogJ3RvdHAnLFxuICAgICAgICBmcmllbmRseU5hbWU6ICdFVExBIFBsYXRmb3JtIFRPVFAnXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbmFibGluZyBNRkE6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfSxcblxuICAvLyBWZXJpZnkgTUZBIHNldHVwXG4gIHZlcmlmeU1GQVNldHVwOiBhc3luYyAoZmFjdG9ySWQ6IHN0cmluZywgY29kZTogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBjaGFsbGVuZ2UgZmlyc3RcbiAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgubWZhLmNoYWxsZW5nZSh7XG4gICAgICAgIGZhY3RvcklkXG4gICAgICB9KVxuXG4gICAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHRocm93IGNoYWxsZW5nZUVycm9yXG5cbiAgICAgIC8vIFZlcmlmeSB0aGUgY29kZVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5tZmEudmVyaWZ5KHtcbiAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2UuaWQsXG4gICAgICAgIGNvZGVcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgLy8gVXBkYXRlIHVzZXIgcHJvZmlsZSB0byBpbmRpY2F0ZSBNRkEgaXMgZW5hYmxlZFxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgICBtZmFfZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBNRkEgc2V0dXA6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfSxcblxuICAvLyBEaXNhYmxlIE1GQSBmb3IgdXNlclxuICBkaXNhYmxlTUZBOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBhbGwgZmFjdG9yc1xuICAgICAgY29uc3QgeyBkYXRhOiBmYWN0b3JzLCBlcnJvcjogZmFjdG9yc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLm1mYS5saXN0RmFjdG9ycygpXG4gICAgICBcbiAgICAgIGlmIChmYWN0b3JzRXJyb3IpIHRocm93IGZhY3RvcnNFcnJvclxuXG4gICAgICAvLyBVbmVucm9sbCBhbGwgVE9UUCBmYWN0b3JzXG4gICAgICBpZiAoZmFjdG9ycz8udG90cCkge1xuICAgICAgICBmb3IgKGNvbnN0IGZhY3RvciBvZiBmYWN0b3JzLnRvdHApIHtcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5hdXRoLm1mYS51bmVucm9sbCh7IGZhY3RvcklkOiBmYWN0b3IuaWQgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdXNlciBwcm9maWxlXG4gICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC51cGRhdGUoeyBcbiAgICAgICAgICAgIG1mYV9lbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRpc2FibGluZyBNRkE6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfSxcblxuICAvLyBHZW5lcmF0ZSBiYWNrdXAgY29kZXMgKHNpbXVsYXRlZCAtIGluIHByb2R1Y3Rpb24gdGhpcyB3b3VsZCBiZSBoYW5kbGVkIGJ5IHlvdXIgYmFja2VuZClcbiAgZ2VuZXJhdGVCYWNrdXBDb2RlczogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZW5lcmF0ZSA4IGJhY2t1cCBjb2Rlc1xuICAgICAgY29uc3QgY29kZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA4IH0sICgpID0+IFxuICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCkudG9VcHBlckNhc2UoKVxuICAgICAgKVxuXG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3Ugd291bGQgc3RvcmUgdGhlc2Ugc2VjdXJlbHkgaW4geW91ciBiYWNrZW5kXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHJldHVybiB0aGVtXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBjb2RlcyB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBiYWNrdXAgY29kZXM6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfSxcblxuICAvLyBWZXJpZnkgYmFja3VwIGNvZGUgKHNpbXVsYXRlZCAtIGluIHByb2R1Y3Rpb24gdGhpcyB3b3VsZCB2ZXJpZnkgYWdhaW5zdCBzdG9yZWQgY29kZXMpXG4gIHZlcmlmeUJhY2t1cENvZGU6IGFzeW5jIChjb2RlOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IHdvdWxkIHZlcmlmeSB0aGlzIGFnYWluc3Qgc3RvcmVkIGJhY2t1cCBjb2Rlc1xuICAgICAgLy8gRm9yIGRlbW8gcHVycG9zZXMsIHdlJ2xsIGFjY2VwdCBhbnkgNisgY2hhcmFjdGVyIGNvZGVcbiAgICAgIGlmIChjb2RlLmxlbmd0aCA+PSA2KSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhY2t1cCBjb2RlJylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgYmFja3VwIGNvZGU6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBZGQgdXNlciBtYW5hZ2VtZW50IG1ldGhvZHMgdG8gdGhlIG1haW4gc3VwYWJhc2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5PYmplY3QuYXNzaWduKHN1cGFiYXNlLCB1c2VyTWFuYWdlbWVudClcblxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImNyZWF0ZVN1cGFiYXNlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9UT0tFTiIsInN1cGFiYXNlIiwic2lnbkluV2l0aFJvbGUiLCJlbWFpbCIsInBhc3N3b3JkIiwiZGF0YSIsImVycm9yIiwiYXV0aCIsInNpZ25JbldpdGhQYXNzd29yZCIsInVzZXIiLCJwcm9maWxlIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiaWQiLCJzaW5nbGUiLCJzaWduT3V0IiwiZ2V0Q3VycmVudFVzZXIiLCJnZXRVc2VyIiwidXNlck1hbmFnZW1lbnQiLCJjcmVhdGVVc2VyIiwidXNlckRhdGEiLCJhdXRoRGF0YSIsImF1dGhFcnJvciIsImFkbWluIiwiZW1haWxfY29uZmlybSIsInVzZXJfbWV0YWRhdGEiLCJmdWxsX25hbWUiLCJyb2xlIiwicm9sZV9sZXZlbCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwicHJvZmlsZUVycm9yIiwiaW5zZXJ0IiwicGhvbmUiLCJkZXBhcnRtZW50Iiwiam9iX3RpdGxlIiwidGVuYW50X2lkIiwiaXNfYWN0aXZlIiwiY2FuX2ludml0ZV91c2VycyIsImNhbl9tYW5hZ2Vfc3ViX2NsaWVudHMiLCJwZXJtaXNzaW9uX3Njb3BlIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRfYXQiLCJkZWxldGVVc2VyIiwidGVuYW50VXNlckVycm9yIiwidXNlcl9pZCIsImRlbGV0ZSIsImFjdGlvbiIsInJlc291cmNlX3R5cGUiLCJyZXNvdXJjZV9pZCIsImRldGFpbHMiLCJjcmVhdGVkX2J5IiwiaXBfYWRkcmVzcyIsInVzZXJfYWdlbnQiLCJzZXZlcml0eSIsImF1ZGl0RXJyb3IiLCJjb25zb2xlIiwid2FybiIsImludml0ZVVzZXJzIiwiaW52aXRhdGlvbkRhdGEiLCJpbnZpdGF0aW9ucyIsImVtYWlscyIsImludml0YXRpb24iLCJpbnZpdGVFcnJvciIsImV4cGlyZXNfYXQiLCJub3ciLCJleHBpcmVzX2luX2RheXMiLCJlbWFpbEVycm9yIiwiaW52aXRlVXNlckJ5RW1haWwiLCJyZWRpcmVjdFRvIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJpbnZpdGF0aW9uX2lkIiwidXBkYXRlIiwic3RhdHVzIiwicHVzaCIsInNlbnQiLCJsZW5ndGgiLCJ0b3RhbCIsInVwZGF0ZVVzZXIiLCJ1c2VySWQiLCJ1cGRhdGVEYXRhIiwiZGVhY3RpdmF0ZVVzZXIiLCJhY3RpdmF0ZVVzZXIiLCJyZXNldFVzZXJQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwidXBkYXRlVXNlckJ5SWQiLCJyZXNldFBhc3N3b3JkRm9yRW1haWwiLCJwcmV2aWV3VXNlckNsZWFudXAiLCJvcHRpb25zIiwiaW5hY3RpdmVVc2VycyIsInVuY29uZmlybWVkVXNlcnMiLCJleHBpcmVkSW52aXRlcyIsImRlbGV0ZUluYWN0aXZlVXNlcnMiLCJjdXRvZmZEYXRlIiwiaW5hY3RpdmVEYXlzIiwiY291bnQiLCJoZWFkIiwibHQiLCJkZWxldGVVbmNvbmZpcm1lZFVzZXJzIiwidW5jb25maXJtZWREYXlzIiwiaXMiLCJkZWxldGVFeHBpcmVkSW52aXRlcyIsIm5lcSIsInRvdGFsVG9EZWxldGUiLCJleGVjdXRlVXNlckNsZWFudXAiLCJkZWxldGVkQ291bnQiLCJpbiIsIm1hcCIsInUiLCJtZmFNYW5hZ2VtZW50IiwiY2hlY2tNRkFTdGF0dXMiLCJtZmFFbmFibGVkIiwibWZhX2VuYWJsZWQiLCJlbmFibGVNRkEiLCJtZmEiLCJlbnJvbGwiLCJmYWN0b3JUeXBlIiwiZnJpZW5kbHlOYW1lIiwidmVyaWZ5TUZBU2V0dXAiLCJmYWN0b3JJZCIsImNvZGUiLCJjaGFsbGVuZ2UiLCJjaGFsbGVuZ2VFcnJvciIsInZlcmlmeSIsImNoYWxsZW5nZUlkIiwiZGlzYWJsZU1GQSIsImZhY3RvcnMiLCJmYWN0b3JzRXJyb3IiLCJsaXN0RmFjdG9ycyIsInRvdHAiLCJmYWN0b3IiLCJ1bmVucm9sbCIsImdlbmVyYXRlQmFja3VwQ29kZXMiLCJjb2RlcyIsIkFycmF5IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwidG9VcHBlckNhc2UiLCJ2ZXJpZnlCYWNrdXBDb2RlIiwiRXJyb3IiLCJPYmplY3QiLCJhc3NpZ24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/lib/supabase.ts\n");

/***/ })

};
;